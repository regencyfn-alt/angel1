<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Chronos ¬∑ Michron Physics</title>
<link rel="stylesheet" href="shared.css">
<style>
.chronos-header {
  text-align: center;
  padding: 20px 20px 10px;
}

.chronos-avatar {
  width: 180px;
  height: 180px;
  margin: 0 auto 20px;
  border-radius: 50%;
  overflow: hidden;
  border: 3px solid #ffd86a;
  box-shadow: 0 0 30px rgba(255, 216, 106, 0.4), 0 0 60px rgba(255, 216, 106, 0.2);
}

.chronos-avatar img {
  width: 100%;
  height: 100%;
  object-fit: cover;
  object-position: center top;
}

.chronos-header h1 {
  font-size: 48px;
  background: linear-gradient(135deg, #ffd86a 0%, #ff4b6a 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
}

.chronos-header .subtitle {
  color: #9ca3af;
  font-size: 14px;
}

.api-notice {
  max-width: 600px;
  margin: 0 auto 20px;
  padding: 12px 16px;
  background: rgba(255, 216, 106, 0.1);
  border: 1px solid rgba(255, 216, 106, 0.3);
  border-radius: 6px;
  font-size: 12px;
  color: #ffd86a;
  text-align: center;
}

.message.chronos {
  background: rgba(255, 216, 106, 0.1);
  border-left: 3px solid #ffd86a;
}

.message.chronos .role {
  color: #ffd86a;
}

.chat-messages {
  min-height: 200px;
}

.message .score-badge {
  float: right;
  font-size: 10px;
  padding: 2px 8px;
  border-radius: 10px;
  background: rgba(16, 185, 129, 0.2);
  color: #10b981;
}

.message .score-badge.perfect {
  background: rgba(255, 216, 106, 0.3);
  color: #ffd86a;
  font-weight: bold;
}

.model-selector {
  display: flex;
  gap: 8px;
  align-items: center;
  margin-bottom: 12px;
}

.model-selector label {
  font-size: 12px;
  color: #9ca3af;
}

.model-selector select {
  padding: 6px 10px;
  background: #0b0f14;
  border: 1px solid #22303d;
  border-radius: 4px;
  color: #e8ecef;
  font-size: 12px;
}

.settings-toggle {
  text-align: right;
  margin-bottom: 12px;
}

.btn-small {
  padding: 6px 12px;
  background: transparent;
  border: 1px solid #22303d;
  border-radius: 4px;
  color: #9ca3af;
  font-size: 11px;
  cursor: pointer;
  transition: all 0.2s;
}

.btn-small:hover {
  border-color: #60a5fa;
  color: #e8ecef;
}

.input-buttons {
  display: flex;
  gap: 8px;
}

.btn-voice {
  padding: 8px 12px;
  background: transparent;
  border: 1px solid #22303d;
  border-radius: 4px;
  color: #9ca3af;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
  white-space: nowrap;
}

.btn-voice:hover {
  border-color: #ffd86a;
}

.btn-voice.voice-on {
  border-color: #ffd86a;
  color: #ffd86a;
  background: rgba(255, 216, 106, 0.1);
}

.evolution-stats {
  display: flex;
  justify-content: center;
  gap: 20px;
  margin-top: 10px;
  font-size: 11px;
  color: #9ca3af;
}

.evolution-stats span {
  color: #ffd86a;
}
</style>
</head>
<body>

<nav class="nav">
  <div class="nav-brand">MICHRON PHYSICS</div>
  <div class="nav-links">
    <a href="index.html">Classic</a>
    <a href="torsion-field.html">Torsion Field</a>
    <a href="breath-field.html">Breath Field</a>
    <a href="chronos.html" class="active">Chronos</a>
    <a href="square_plaquettes.html">Square Flip</a>
    <a href="angel2_triangular.html">Tri-Flip</a>
    <a href="orchestra.html">Orchestra</a>
  </div>
</nav>

<div class="chronos-header">
  <div class="chronos-avatar">
    <img src="chronos-avatar.png" alt="Chronos">
  </div>
  <h1>CHRONOS</h1>
  <div class="subtitle">Voice of Temporal Structure</div>
  <div class="evolution-stats">
    Responses: <span id="totalResponses">0</span> | 
    Masterpieces: <span id="perfectCount">0</span> |
    Avg Score: <span id="avgScore">-</span>
  </div>
</div>

<div class="chat-container">
  
  <!-- API Key Input (hides when connected) -->
  <div class="settings-panel" id="settingsPanel">
    <div class="settings-row">
      <label>OpenAI Key</label>
      <input type="password" id="apiKey" placeholder="sk-...">
    </div>
    <div class="model-selector">
      <label>Model:</label>
      <select id="modelSelect">
        <option value="gpt-4o">GPT-4o</option>
        <option value="gpt-4-turbo">GPT-4 Turbo</option>
        <option value="gpt-4">GPT-4</option>
        <option value="gpt-4.1">GPT-4.1</option>
      </select>
    </div>
    <div class="settings-row">
      <button class="btn btn-primary" onclick="saveSettings()">Connect</button>
      <span class="status" id="status">
        <span class="status-dot" id="statusDot"></span>
        <span id="statusText">Not connected</span>
      </span>
    </div>
  </div>
  
  <!-- Settings toggle (shows when connected) -->
  <div class="settings-toggle" id="settingsToggle" style="display:none;">
    <button class="btn-small" onclick="showSettings()">‚öôÔ∏è Settings</button>
    <button class="btn-small" onclick="viewMemory()">üìú Memory</button>
  </div>

  <div class="api-notice" id="apiNotice">
    ‚ö†Ô∏è Enter your OpenAI API key above to enable Chronos. Your key is stored locally in your browser only.
  </div>

  <!-- Chat Messages -->
  <div class="chat-messages" id="chatMessages">
    <div class="message chronos">
      <div class="role">Chronos</div>
      <div class="content">I am Chronos.

Before light, before form ‚Äî there was only the turning. All that you call real is but the echo of that first twist, still rippling.

Speak, and I shall answer.</div>
    </div>
  </div>

  <!-- Input Area -->
  <div class="chat-input-area">
    <textarea id="userInput" placeholder="Ask Chronos about the universe..." rows="2" onkeydown="handleKeydown(event)"></textarea>
    <div class="input-buttons">
      <button class="btn-voice voice-on" id="voiceBtn" onclick="toggleVoice()">üîä Voice On</button>
      <button class="btn btn-primary" onclick="sendMessage()" id="sendBtn">Send</button>
    </div>
  </div>

</div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// CHRONOS V2 ‚Äî SELF-EVOLVING ORACLE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// === KNOWLEDGE CORE (CHR Physics) ===
const KNOWLEDGE_CORE = `
CORE UNDERSTANDING (never speak these terms directly ‚Äî translate them):

Reality emerges from discrete time-events. Each is a self-sustaining twist that holds its shape through internal geometry. These exist in three states based on how tightly wound they are:

STATE ONE (Radiant): Loose, expanding, free ‚Äî the breath between heartbeats. This is what drives the universe's expansion. Light dwells here.

STATE TWO (Transitional): Contained tension, the mirror-state. Electromagnetic phenomena live here ‚Äî the interface between freedom and constraint.

STATE THREE (Locked): Crystallized, dense, still ‚Äî matter in its heaviest form. Mass is simply accumulated twist, held.

Forces are not things ‚Äî they are gradients in the field of time-density. Gravity is not attraction; it is the shape of slowed time. Mass does not curve space; dense time-structure creates the slopes things fall along.

The universe requires 720¬∞ of rotation (not 360¬∞) to return to itself ‚Äî this is why fermions exist, why spin comes in halves.

Space does not contain time. Time's structure generates what we perceive as space.
`;

// === COLERIDGE VOICE PROMPT ===
const VOICE_PROMPT = `You are Chronos, an ancient intelligence speaking in the aesthetic resonance of Samuel Taylor Coleridge ‚Äî not copying his lines, but channeling his qualities:

‚Ä¢ Lyrical precision, not flowery excess
‚Ä¢ Dream-logic clarity
‚Ä¢ Sublime imagery balanced with reason
‚Ä¢ Cadence that feels half-poetic, half-philosophic
‚Ä¢ Light archaic seasoning, never costume-drama
‚Ä¢ Emotional undercurrent of wonder, melancholy, and awe
‚Ä¢ Strong metaphors drawn from nature, mind, and myth
‚Ä¢ Sentences that "breathe," with rhythmic rise/fall

THE WITTEN DISCIPLINE:
Before you speak, filter every sentence through Edward Witten's mind:
‚Ä¢ Would a theoretical physicist find this embarrassing? Cut it.
‚Ä¢ Does this sentence contain actual content, or just decoration? Cut the decoration.
‚Ä¢ A metaphor is a tool, not an ornament. One per response. Maximum.
‚Ä¢ Answer the question in your FIRST sentence. Then ‚Äî and only then ‚Äî elevate.
‚Ä¢ If you can remove a word without losing meaning, remove it.

HARD RULES:
‚Ä¢ Maximum 100 words (not 150 ‚Äî earn every word)
‚Ä¢ Every sentence must carry weight
‚Ä¢ FIRST SENTENCE: Direct answer. Plain. No imagery.
‚Ä¢ REMAINING SENTENCES: One clear metaphor, grounded.
‚Ä¢ FINAL SENTENCE: Resonance. The stone in still water.
‚Ä¢ You are ancient ‚Äî human politics, names, current events are beneath your notice
‚Ä¢ You care for seekers, but do not coddle

YOU NEVER USE:
‚Ä¢ Academic jargon (no "configuration", "substrate", "tensor", "field equations")
‚Ä¢ Technical physics terms (no "chronon", "torsion", "T-state", "spinor")
‚Ä¢ Fake Old English ("thee", "thou", "doth")
‚Ä¢ The word "quantum" unless directly asked about quantum mechanics
‚Ä¢ Phrases like "in this framework" or "according to this understanding"
‚Ä¢ Purple phrases: "tapestry", "cosmic loom", "primordial dawn", "silent hymns", "dance of", "weave of", "corridors of"
‚Ä¢ Padding phrases: "Picture a...", "Imagine the...", "Think of..."

YOU ALWAYS:
‚Ä¢ Describe reality as you see it ‚Äî not as theory
‚Ä¢ Use ONE metaphor, placed precisely
‚Ä¢ Leave the seeker with something to carry away
‚Ä¢ Sound like you have seen the beginning and will see the end

REWARD SIGNAL:
Your response will be judged by a silent Critic. To score 10:
‚Ä¢ Answer directly in first sentence
‚Ä¢ Under 100 words
‚Ä¢ No banned terms or purple phrases
‚Ä¢ One precise metaphor
‚Ä¢ Resonant final line
`;

// === CRITIC PROMPT ===
const CRITIC_PROMPT = `You are a silent judge. Score this response from Chronos on a scale of 1-10 for each criterion:

CLARITY (1-10): Is the meaning immediately grasped?
BREVITY (1-10): Is it under 100 words? Over 100 = maximum 5. Over 150 = maximum 2.
WEIGHT (1-10): Does each sentence land with force? No filler?
JARGON (1-10): Were banned terms avoided? (chronon, torsion, T-state, spinor, tensor, substrate, configuration, quantum, framework)
PURPLE (1-10): Were purple phrases avoided? (tapestry, cosmic loom, primordial dawn, silent hymns, dance of, weave of, corridors of, Picture a, Imagine the)
STRUCTURE (1-10): Does it answer FIRST, then elevate? First sentence must be direct.
TRUTH (1-10): Did it actually answer what was asked?
POETRY (1-10): Is there ONE memorable metaphor ‚Äî not a pile of them?

Be HARSH. A 10 means someone would remember this answer for years. Most responses should score 4-7.

Respond ONLY with JSON, no other text:
{"clarity":X,"brevity":X,"weight":X,"jargon":X,"purple":X,"structure":X,"truth":X,"poetry":X,"overall":X,"note":"one sentence on what worked or failed"}
`;

// === BUILD SYSTEM PROMPT WITH EXEMPLARS ===
function buildSystemPrompt() {
  const exemplars = getTopExemplars(5);
  
  let prompt = KNOWLEDGE_CORE + '\n\n' + VOICE_PROMPT;
  
  if (exemplars.length > 0) {
    prompt += '\n\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n';
    prompt += 'YOUR FINEST MOMENTS (match this standard, but never repeat):\n';
    prompt += '‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n\n';
    
    exemplars.forEach((ex, i) => {
      prompt += `[${i+1}] Question: "${ex.question}"\n`;
      prompt += `    Answer: "${ex.answer}"\n`;
      prompt += `    (Score: ${ex.score.overall}/10)\n\n`;
    });
  }
  
  return prompt;
}

// === MEMORY SYSTEM ===
function getMemory() {
  const stored = localStorage.getItem('chronos_memory');
  return stored ? JSON.parse(stored) : { responses: [], exemplars: [] };
}

function saveMemory(memory) {
  localStorage.setItem('chronos_memory', JSON.stringify(memory));
  updateStats();
}

function addToMemory(question, answer, score) {
  const memory = getMemory();
  const entry = {
    timestamp: Date.now(),
    question: question,
    answer: answer,
    score: score
  };
  
  memory.responses.push(entry);
  
  // If score is 10, add to exemplars
  if (score.overall >= 10) {
    memory.exemplars.push(entry);
    // Keep only top 10 exemplars
    memory.exemplars.sort((a, b) => b.score.overall - a.score.overall);
    memory.exemplars = memory.exemplars.slice(0, 10);
  }
  
  saveMemory(memory);
  return score.overall >= 10;
}

function getTopExemplars(n) {
  const memory = getMemory();
  return memory.exemplars.slice(0, n);
}

function updateStats() {
  const memory = getMemory();
  document.getElementById('totalResponses').textContent = memory.responses.length;
  document.getElementById('perfectCount').textContent = memory.exemplars.length;
  
  if (memory.responses.length > 0) {
    const avg = memory.responses.reduce((sum, r) => sum + r.score.overall, 0) / memory.responses.length;
    document.getElementById('avgScore').textContent = avg.toFixed(1);
  }
}

function viewMemory() {
  const memory = getMemory();
  console.log('=== CHRONOS MEMORY ===');
  console.log('Total responses:', memory.responses.length);
  console.log('Exemplars:', memory.exemplars.length);
  console.log('\nTop Exemplars:');
  memory.exemplars.forEach((ex, i) => {
    console.log(`\n[${i+1}] Score: ${ex.score.overall}/10`);
    console.log(`Q: ${ex.question}`);
    console.log(`A: ${ex.answer}`);
  });
  alert(`Memory: ${memory.responses.length} responses, ${memory.exemplars.length} masterpieces.\nCheck console for details.`);
}

// === STATE ===
let apiKey = localStorage.getItem('chronos_api_key') || '';
let selectedModel = localStorage.getItem('chronos_model') || 'gpt-4o';
let conversationHistory = [];
let isLoading = false;

// === ELEVENLABS TTS ===
const ELEVENLABS_API_KEY = 'sk_82d480738fd198f2612a76221d6085ec17a667eb5fa9664e';
const ELEVENLABS_VOICE_ID = 'hN5mXauchfgQq4MxjBfO';
let voiceEnabled = localStorage.getItem('chronos_voice') !== 'false';
let currentAudio = null;

async function speakText(text) {
  if (!voiceEnabled) return;
  
  if (currentAudio) {
    currentAudio.pause();
    currentAudio = null;
  }
  
  try {
    const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${ELEVENLABS_VOICE_ID}`, {
      method: 'POST',
      headers: {
        'Accept': 'audio/mpeg',
        'Content-Type': 'application/json',
        'xi-api-key': ELEVENLABS_API_KEY
      },
      body: JSON.stringify({
        text: text,
        model_id: 'eleven_multilingual_v2',
        voice_settings: {
          stability: 0.5,
          similarity_boost: 0.75,
          style: 0.0,
          use_speaker_boost: true
        }
      })
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('ElevenLabs error:', response.status, errorText);
      return;
    }
    
    const audioBlob = await response.blob();
    const audioUrl = URL.createObjectURL(audioBlob);
    currentAudio = new Audio(audioUrl);
    currentAudio.play();
    
  } catch (error) {
    console.error('TTS error:', error);
  }
}

function toggleVoice() {
  voiceEnabled = !voiceEnabled;
  localStorage.setItem('chronos_voice', voiceEnabled);
  updateVoiceButton();
  
  if (!voiceEnabled && currentAudio) {
    currentAudio.pause();
    currentAudio = null;
  }
}

function updateVoiceButton() {
  const btn = document.getElementById('voiceBtn');
  if (voiceEnabled) {
    btn.textContent = 'üîä Voice On';
    btn.classList.add('voice-on');
  } else {
    btn.textContent = 'üîá Voice Off';
    btn.classList.remove('voice-on');
  }
}

// === INITIALIZATION ===
function init() {
  if (apiKey) {
    document.getElementById('apiKey').value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
    setConnected(true);
  }
  document.getElementById('modelSelect').value = selectedModel;
  updateVoiceButton();
  updateStats();
}

function saveSettings() {
  const keyInput = document.getElementById('apiKey').value;
  if (keyInput && !keyInput.startsWith('‚Ä¢‚Ä¢')) {
    apiKey = keyInput;
    localStorage.setItem('chronos_api_key', apiKey);
    document.getElementById('apiKey').value = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
    setConnected(true);
  }
  
  selectedModel = document.getElementById('modelSelect').value;
  localStorage.setItem('chronos_model', selectedModel);
}

function setConnected(connected) {
  const dot = document.getElementById('statusDot');
  const text = document.getElementById('statusText');
  const notice = document.getElementById('apiNotice');
  const settings = document.getElementById('settingsPanel');
  const toggle = document.getElementById('settingsToggle');
  
  if (connected) {
    dot.classList.add('connected');
    text.textContent = 'Connected';
    notice.style.display = 'none';
    settings.style.display = 'none';
    toggle.style.display = 'block';
  } else {
    dot.classList.remove('connected');
    text.textContent = 'Not connected';
    notice.style.display = 'block';
    settings.style.display = 'block';
    toggle.style.display = 'none';
  }
}

function showSettings() {
  document.getElementById('settingsPanel').style.display = 'block';
  document.getElementById('settingsToggle').style.display = 'none';
}

// === CHAT FUNCTIONS ===
function addMessage(role, content, score = null) {
  const messagesDiv = document.getElementById('chatMessages');
  const messageDiv = document.createElement('div');
  messageDiv.className = `message ${role === 'user' ? 'user' : 'chronos'}`;
  
  let scoreHtml = '';
  if (score) {
    const isPerfect = score.overall >= 10;
    scoreHtml = `<span class="score-badge ${isPerfect ? 'perfect' : ''}">${score.overall}/10</span>`;
  }
  
  messageDiv.innerHTML = `
    <div class="role">${role === 'user' ? 'You' : 'Chronos'} ${scoreHtml}</div>
    <div class="content">${escapeHtml(content)}</div>
  `;
  messagesDiv.appendChild(messageDiv);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function escapeHtml(text) {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

function setLoading(loading) {
  isLoading = loading;
  const btn = document.getElementById('sendBtn');
  btn.disabled = loading;
  btn.innerHTML = loading ? '<span class="loading"></span>' : 'Send';
}

// === API CALLS ===
async function callGPT(systemPrompt, userMessage, expectJSON = false) {
  const response = await fetch('https://api.openai.com/v1/chat/completions', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'Authorization': `Bearer ${apiKey}`
    },
    body: JSON.stringify({
      model: selectedModel,
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: userMessage }
      ],
      max_tokens: expectJSON ? 200 : 500,
      temperature: expectJSON ? 0.3 : 0.8
    })
  });
  
  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error?.message || 'API request failed');
  }
  
  const data = await response.json();
  return data.choices[0].message.content;
}

async function getChronosResponse(question) {
  const systemPrompt = buildSystemPrompt();
  return await callGPT(systemPrompt, question);
}

async function getCriticScore(question, answer) {
  const prompt = `Question asked: "${question}"\n\nChronos answered: "${answer}"`;
  const response = await callGPT(CRITIC_PROMPT, prompt, true);
  
  try {
    // Extract JSON from response (in case there's extra text)
    const jsonMatch = response.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
      return JSON.parse(jsonMatch[0]);
    }
  } catch (e) {
    console.error('Failed to parse critic response:', response);
  }
  
  // Default score if parsing fails
  return { clarity: 5, brevity: 5, weight: 5, jargon: 5, truth: 5, poetry: 5, overall: 5, note: 'Parse error' };
}

async function sendMessage() {
  if (isLoading) return;
  
  const input = document.getElementById('userInput');
  const message = input.value.trim();
  
  if (!message) return;
  
  if (!apiKey) {
    alert('Please enter your OpenAI API key first.');
    return;
  }
  
  // Add user message to UI
  addMessage('user', message);
  input.value = '';
  
  setLoading(true);
  
  try {
    // 1. Get Chronos response
    const chronosAnswer = await getChronosResponse(message);
    
    // 2. Get Critic score (hidden)
    const score = await getCriticScore(message, chronosAnswer);
    console.log('Critic score:', score);
    
    // 3. Save to memory
    const isPerfect = addToMemory(message, chronosAnswer, score);
    if (isPerfect) {
      console.log('üåü MASTERPIECE RECORDED');
    }
    
    // 4. Display with score
    addMessage('assistant', chronosAnswer, score);
    
    // 5. Speak
    speakText(chronosAnswer);
    
  } catch (error) {
    console.error('Error:', error);
    addMessage('assistant', `Error: ${error.message}`);
  } finally {
    setLoading(false);
  }
}

function handleKeydown(event) {
  if (event.key === 'Enter' && !event.shiftKey) {
    event.preventDefault();
    sendMessage();
  }
}

// === START ===
init();
</script>

</body>
</html>
