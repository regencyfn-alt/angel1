<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ANGEL-2 · C2 Network Dynamics</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;400;500&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #030508;
  color: #e0e6ed;
  font-family: 'Rajdhani', sans-serif;
  min-height: 100vh;
  display: flex;
}

/* Main canvas area */
.canvas-area {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

#grid-container {
  display: grid;
  gap: 4px;
  background: rgba(20, 30, 40, 0.5);
  padding: 16px;
  border-radius: 8px;
  border: 1px solid rgba(106, 255, 216, 0.1);
}

/* Individual plaquette */
.plaquette {
  width: 64px;
  height: 64px;
  background: rgba(40, 50, 60, 0.6);
  border: 2px solid rgba(100, 110, 120, 0.3);
  border-radius: 6px;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s ease;
}

.plaquette.dormant {
  background: rgba(40, 50, 60, 0.4);
  border-color: rgba(80, 90, 100, 0.3);
}

.plaquette.state-1 {
  background: rgba(255, 80, 80, 0.15);
  border-color: rgba(255, 80, 80, 0.5);
  box-shadow: 0 0 15px rgba(255, 80, 80, 0.2);
}

.plaquette.state-2 {
  background: rgba(80, 255, 120, 0.15);
  border-color: rgba(80, 255, 120, 0.5);
  box-shadow: 0 0 15px rgba(80, 255, 120, 0.2);
}

.plaquette.state-3 {
  background: rgba(80, 150, 255, 0.15);
  border-color: rgba(80, 150, 255, 0.5);
  box-shadow: 0 0 15px rgba(80, 150, 255, 0.2);
}

/* Speed channel flash for electron neutrino */
.plaquette.channel-flash {
  background: rgba(80, 150, 255, 0.3) !important;
  border-color: rgba(80, 150, 255, 0.7) !important;
}

/* Tau bomb flash */
.plaquette.bomb-flash {
  background: rgba(255, 255, 150, 0.5) !important;
  border-color: rgba(255, 255, 150, 0.9) !important;
  box-shadow: 0 0 30px rgba(255, 255, 150, 0.5) !important;
}

/* Polarity arrows */
.arrow-left, .arrow-right {
  position: absolute;
  width: 12px;
  height: 12px;
  font-size: 14px;
  color: rgba(150, 160, 170, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.2s ease;
}

.arrow-left { left: 4px; top: 50%; transform: translateY(-50%); }
.arrow-right { right: 4px; top: 50%; transform: translateY(-50%); }

.plaquette.state-1 .arrow-left,
.plaquette.state-1 .arrow-right { color: rgba(255, 120, 120, 0.9); }

.plaquette.state-2 .arrow-left,
.plaquette.state-2 .arrow-right { color: rgba(120, 255, 150, 0.9); }

.plaquette.state-3 .arrow-left,
.plaquette.state-3 .arrow-right { color: rgba(120, 180, 255, 0.9); }

/* Central donut */
.donut {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  border: 4px solid rgba(100, 110, 120, 0.4);
  position: relative;
  transition: all 0.15s ease;
}

.plaquette.state-1 .donut {
  border-color: rgba(255, 100, 100, 0.8);
  border-width: 6px; /* Thicker when contracted */
  width: 24px;
  height: 24px;
}

.plaquette.state-2 .donut {
  border-color: rgba(100, 255, 140, 0.8);
  border-width: 4px;
}

.plaquette.state-3 .donut {
  border-color: rgba(100, 170, 255, 0.8);
  border-width: 3px; /* Thinner when expanded */
  width: 32px;
  height: 32px;
}

/* Chevron inside donut */
.chevron {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 10px;
  color: rgba(150, 160, 170, 0.5);
  transition: all 0.1s ease;
}

.plaquette.state-1 .chevron { color: rgba(255, 150, 150, 0.9); }
.plaquette.state-2 .chevron { color: rgba(150, 255, 180, 0.9); }
.plaquette.state-3 .chevron { color: rgba(150, 200, 255, 0.9); }

/* Polarity flip animation */
@keyframes polarityFlip {
  0% { transform: scaleX(1); }
  50% { transform: scaleX(0); }
  100% { transform: scaleX(1); }
}

.plaquette.flipping {
  animation: polarityFlip 0.3s ease;
}

/* Resonance group highlights */
.plaquette.resonance-group-1 { box-shadow: 0 0 12px rgba(255, 100, 200, 0.7), inset 0 0 8px rgba(255, 100, 200, 0.3); }
.plaquette.resonance-group-2 { box-shadow: 0 0 12px rgba(100, 255, 200, 0.7), inset 0 0 8px rgba(100, 255, 200, 0.3); }
.plaquette.resonance-group-3 { box-shadow: 0 0 12px rgba(200, 100, 255, 0.7), inset 0 0 8px rgba(200, 100, 255, 0.3); }
.plaquette.resonance-group-4 { box-shadow: 0 0 12px rgba(255, 200, 100, 0.7), inset 0 0 8px rgba(255, 200, 100, 0.3); }
.plaquette.resonance-group-5 { box-shadow: 0 0 12px rgba(100, 200, 255, 0.7), inset 0 0 8px rgba(100, 200, 255, 0.3); }
.plaquette.resonance-group-6 { box-shadow: 0 0 12px rgba(255, 255, 100, 0.7), inset 0 0 8px rgba(255, 255, 100, 0.3); }

/* Skip/hold indicator */
.skip-indicator {
  position: absolute;
  top: 3px;
  right: 3px;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background: rgba(255, 200, 100, 0.8);
  opacity: 0;
  transition: opacity 0.2s;
}

.plaquette.skipping .skip-indicator {
  opacity: 1;
}

/* Control Panel */
.control-panel {
  width: 300px;
  background: rgba(8, 16, 24, 0.95);
  border-left: 1px solid rgba(106, 255, 216, 0.2);
  padding: 20px;
  overflow-y: auto;
}

.panel-title {
  font-family: 'Orbitron', monospace;
  font-size: 14px;
  color: #6affd8;
  letter-spacing: 2px;
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 1px solid rgba(106, 255, 216, 0.2);
}

.control-section {
  margin-bottom: 24px;
}

.section-title {
  font-size: 11px;
  color: #8a9bae;
  letter-spacing: 1px;
  text-transform: uppercase;
  margin-bottom: 12px;
}

.btn {
  width: 100%;
  padding: 12px 16px;
  background: linear-gradient(135deg, rgba(106, 255, 216, 0.15), rgba(106, 255, 216, 0.05));
  border: 1px solid rgba(106, 255, 216, 0.4);
  border-radius: 4px;
  color: #6affd8;
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  letter-spacing: 2px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  margin-bottom: 8px;
}

.btn:hover {
  background: linear-gradient(135deg, rgba(106, 255, 216, 0.25), rgba(106, 255, 216, 0.1));
  box-shadow: 0 0 20px rgba(106, 255, 216, 0.3);
}

.btn.electron {
  border-color: rgba(100, 170, 255, 0.6);
  color: #6af;
  background: linear-gradient(135deg, rgba(100, 170, 255, 0.15), rgba(100, 170, 255, 0.05));
}
.btn.electron:hover {
  box-shadow: 0 0 20px rgba(100, 170, 255, 0.3);
}

.btn.muon {
  border-color: rgba(100, 255, 140, 0.6);
  color: #6fa;
  background: linear-gradient(135deg, rgba(100, 255, 140, 0.15), rgba(100, 255, 140, 0.05));
}
.btn.muon:hover {
  box-shadow: 0 0 20px rgba(100, 255, 140, 0.3);
}

.btn.tau {
  border-color: rgba(255, 100, 100, 0.6);
  color: #f66;
  background: linear-gradient(135deg, rgba(255, 100, 100, 0.15), rgba(255, 100, 100, 0.05));
}
.btn.tau:hover {
  box-shadow: 0 0 20px rgba(255, 100, 100, 0.3);
}

.btn-row {
  display: flex;
  gap: 8px;
}

.btn-row .btn {
  flex: 1;
  padding: 10px 8px;
  font-size: 10px;
}

.slider-container {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
}

.slider-label {
  font-size: 11px;
  color: #8a9bae;
  min-width: 80px;
}

.slider {
  flex: 1;
  -webkit-appearance: none;
  height: 4px;
  background: rgba(106, 255, 216, 0.2);
  border-radius: 2px;
  outline: none;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  background: #6affd8;
  border-radius: 50%;
  cursor: pointer;
}

.slider-value {
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  color: #6affd8;
  min-width: 35px;
  text-align: right;
}

/* Metrics */
.metrics {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 6px;
  padding: 12px;
}

.metric-row {
  display: flex;
  justify-content: space-between;
  padding: 6px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.metric-row:last-child { border-bottom: none; }

.metric-label {
  font-size: 11px;
  color: #8a9bae;
}

.metric-value {
  font-family: 'Orbitron', monospace;
  font-size: 12px;
  color: #fff;
}

.metric-value.red { color: #ff6666; }
.metric-value.green { color: #66ff99; }
.metric-value.blue { color: #66aaff; }

/* Legend */
.legend {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 12px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 11px;
  color: #8a9bae;
}

.legend-dot {
  width: 12px;
  height: 12px;
  border-radius: 3px;
}

.legend-dot.red { background: rgba(255, 80, 80, 0.6); border: 1px solid #f66; }
.legend-dot.green { background: rgba(80, 255, 120, 0.6); border: 1px solid #6f8; }
.legend-dot.blue { background: rgba(80, 150, 255, 0.6); border: 1px solid #6af; }

/* Event log */
.event-log {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  pointer-events: none;
  z-index: 100;
}

.event-msg {
  background: rgba(8, 16, 24, 0.9);
  border: 1px solid rgba(106, 255, 216, 0.3);
  border-radius: 4px;
  padding: 8px 16px;
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  color: #6affd8;
  animation: fadeOut 3s ease forwards;
}

.event-msg.electron { border-color: rgba(100, 170, 255, 0.5); color: #6af; }
.event-msg.muon { border-color: rgba(100, 255, 140, 0.5); color: #6fa; }
.event-msg.tau { border-color: rgba(255, 100, 100, 0.5); color: #f66; }

@keyframes fadeOut {
  0% { opacity: 0; transform: translateY(10px); }
  10% { opacity: 1; transform: translateY(0); }
  80% { opacity: 1; }
  100% { opacity: 0; }
}

/* Title */
.main-title {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 100;
}

.main-title h1 {
  font-family: 'Orbitron', monospace;
  font-size: 20px;
  color: #6affd8;
  letter-spacing: 3px;
}

.main-title .subtitle {
  font-size: 10px;
  color: #8a9bae;
  letter-spacing: 2px;
  margin-top: 4px;
}
</style>
</head>
<body>

<div class="main-title">
  <h1>ANGEL-2</h1>
  <div class="subtitle">C2 NETWORK PLAQUETTE DYNAMICS</div>
</div>

<div class="canvas-area">
  <div id="grid-container"></div>
</div>

<div class="control-panel">
  <div class="panel-title">NETWORK CONTROLS</div>
  
  <div class="control-section">
    <div class="section-title">Launch Neutrino</div>
    <button class="btn electron" id="launchElectron">e⁻ ELECTRON (~0.45 eV)</button>
    <button class="btn muon" id="launchMuon">μ MUON (Bootstrap)</button>
    <button class="btn tau" id="launchTau">τ TAU (Bomb)</button>
  </div>
  
  <div class="control-section">
    <div class="section-title">Grid Size</div>
    <div class="btn-row">
      <button class="btn" id="addRow">+ Row</button>
      <button class="btn" id="addCol">+ Col</button>
    </div>
    <div class="btn-row">
      <button class="btn" id="removeRow">- Row</button>
      <button class="btn" id="removeCol">- Col</button>
    </div>
  </div>
  
  <div class="control-section">
    <div class="section-title">Simulation</div>
    <div class="slider-container">
      <span class="slider-label">Speed</span>
      <input type="range" class="slider" id="speedSlider" min="0.2" max="2" step="0.1" value="1">
      <span class="slider-value" id="speedValue">1.0x</span>
    </div>
    <button class="btn" id="resetBtn">Reset Network</button>
    <button class="btn" id="pauseBtn">Pause</button>
    <button class="btn" id="resonanceBtn">Resonance Trace: OFF</button>
    <button class="btn" id="audioBtn">Audio: OFF</button>
  </div>
  
  <div class="control-section">
    <div class="section-title">Network State</div>
    <div class="metrics">
      <div class="metric-row">
        <span class="metric-label">Active</span>
        <span class="metric-value" id="activeCount">0 / 16</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">State 1 (Red)</span>
        <span class="metric-value red" id="redCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">State 2 (Green)</span>
        <span class="metric-value green" id="greenCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">State 3 (Blue)</span>
        <span class="metric-value blue" id="blueCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Contacts</span>
        <span class="metric-value" id="contactCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Resonance Groups</span>
        <span class="metric-value" id="resonanceCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Status</span>
        <span class="metric-value" id="statusValue">DORMANT</span>
      </div>
    </div>
    
    <div class="legend">
      <div class="legend-item">
        <div class="legend-dot red"></div>
        <span>State 1 — Contracted (virtual C3)</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot green"></div>
        <span>State 2 — Equilibrium (true C2)</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot blue"></div>
        <span>State 3 — Expanded (virtual C1)</span>
      </div>
    </div>
  </div>
</div>

<div class="event-log" id="eventLog"></div>

<script>
// ============================================================================
// ANGEL-2: C2 NETWORK PLAQUETTE DYNAMICS
// Three states within C2 class, three neutrino interaction types
// ============================================================================

// === STATES ===
const DORMANT = 0;
const STATE_1 = 1;  // Red - contracted, dense, can skip/hold (virtual C3)
const STATE_2 = 2;  // Green - equilibrium, normal oscillation (true C2)
const STATE_3 = 3;  // Blue - expanded, thin, MUST release (virtual C1)

// === SIMULATION PARAMETERS ===
const TICK_INTERVAL = 100; // ms per tick base
let speedMultiplier = 1;
let paused = false;
let tickTimer = null;

// === GRID STATE ===
let gridRows = 4;
let gridCols = 4;
let grid = []; // 2D array of plaquette objects
let contactCount = 0;

// === PLAQUETTE OBJECT ===
function createPlaquette(row, col) {
  return {
    row,
    col,
    state: DORMANT,
    polarity: Math.random() > 0.5 ? 1 : -1, // 1 = right, -1 = left
    phase: 0, // 0, 1, 2 within oscillation cycle
    skipping: false,
    skipCount: 0,
    element: null
  };
}

// === INITIALIZATION ===
function init() {
  createGrid();
  setupEventListeners();
  startSimulation();
}

function createGrid() {
  const container = document.getElementById('grid-container');
  container.innerHTML = '';
  container.style.gridTemplateColumns = `repeat(${gridCols}, 64px)`;
  
  grid = [];
  
  for (let r = 0; r < gridRows; r++) {
    const row = [];
    for (let c = 0; c < gridCols; c++) {
      const plaquette = createPlaquette(r, c);
      const element = createPlaquetteElement(plaquette);
      plaquette.element = element;
      container.appendChild(element);
      row.push(plaquette);
    }
    grid.push(row);
  }
  
  updateMetrics();
}

function createPlaquetteElement(plaquette) {
  const el = document.createElement('div');
  el.className = 'plaquette dormant';
  el.innerHTML = `
    <div class="arrow-left">▲</div>
    <div class="arrow-right">▼</div>
    <div class="donut">
      <div class="chevron">●</div>
    </div>
    <div class="skip-indicator"></div>
  `;
  return el;
}

function updatePlaquetteVisual(plaquette) {
  const el = plaquette.element;
  
  // Remove all state classes
  el.classList.remove('dormant', 'state-1', 'state-2', 'state-3', 'skipping');
  
  // Add current state class
  if (plaquette.state === DORMANT) {
    el.classList.add('dormant');
  } else {
    el.classList.add(`state-${plaquette.state}`);
  }
  
  // Skipping indicator
  if (plaquette.skipping) {
    el.classList.add('skipping');
  }
  
  // Update arrows based on polarity
  const leftArrow = el.querySelector('.arrow-left');
  const rightArrow = el.querySelector('.arrow-right');
  
  if (plaquette.polarity === 1) {
    leftArrow.textContent = '▲';
    rightArrow.textContent = '▼';
  } else {
    leftArrow.textContent = '▼';
    rightArrow.textContent = '▲';
  }
  
  // Update chevron based on phase
  const chevron = el.querySelector('.chevron');
  const chevrons = ['◀', '●', '▶'];
  chevron.textContent = plaquette.state === DORMANT ? '○' : chevrons[plaquette.phase];
}

// === SIMULATION TICK ===
function tick() {
  if (paused) return;
  
  // Process each active plaquette
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const p = grid[r][c];
      if (p.state === DORMANT) continue;
      
      // Check if should skip
      if (shouldSkip(p)) {
        p.skipping = true;
        p.skipCount++;
        // Max 2 skips for virtual C3 behavior
        if (p.skipCount > 2) {
          p.skipping = false;
          p.skipCount = 0;
        }
      } else {
        p.skipping = false;
        p.skipCount = 0;
        
        // Advance phase
        advancePhase(p);
        
        // Check contacts at state 3 (expanded)
        if (p.state === STATE_3) {
          checkContacts(p);
        }
      }
      
      updatePlaquetteVisual(p);
    }
  }
  
  updateMetrics();
  updateResonanceVisualization();
  updateAudio();
}

function shouldSkip(plaquette) {
  // Skip when surrounded by same-state neighbors (no gradient)
  const neighbors = getNeighbors(plaquette);
  const activeNeighbors = neighbors.filter(n => n.state !== DORMANT);
  
  if (activeNeighbors.length === 0) return false;
  
  // Check if all active neighbors are same state
  const allSame = activeNeighbors.every(n => n.state === plaquette.state);
  
  // Only state 1 (contracted) can skip
  return allSame && plaquette.state === STATE_1;
}

function advancePhase(plaquette) {
  plaquette.phase = (plaquette.phase + 1) % 3;
  
  // State transitions based on phase
  // Phase 0 → contracting toward state 1
  // Phase 1 → neutral state 2
  // Phase 2 → expanding toward state 3
  
  if (plaquette.phase === 0) {
    plaquette.state = STATE_1;
  } else if (plaquette.phase === 1) {
    plaquette.state = STATE_2;
  } else {
    plaquette.state = STATE_3;
  }
}

function getNeighbors(plaquette) {
  const neighbors = [];
  const dirs = [[-1, 0], [1, 0], [0, -1], [0, 1]];
  
  for (const [dr, dc] of dirs) {
    const nr = plaquette.row + dr;
    const nc = plaquette.col + dc;
    if (nr >= 0 && nr < gridRows && nc >= 0 && nc < gridCols) {
      neighbors.push(grid[nr][nc]);
    }
  }
  
  return neighbors;
}

function checkContacts(plaquette) {
  const neighbors = getNeighbors(plaquette);
  
  for (const neighbor of neighbors) {
    // Contact happens when expanded (state 3) meets anything - including dormant!
    handleContact(plaquette, neighbor);
  }
}

function handleContact(p1, p2) {
  // p1 is always the expanded (state 3) node initiating contact
  
  // Play contact sound
  playContactSound(p1.state, p2.state);
  
  if (p2.state === DORMANT) {
    // Wake up dormant neighbor! This is the bootstrap propagation
    p2.state = STATE_2;  // Activate at equilibrium
    p2.phase = 1;
    contactCount++;
    
    // p1 transfers energy, drops to state 2
    p1.state = STATE_2;
    p1.phase = 1;
    
    // Both flip polarity
    flipPolarity(p1);
    flipPolarity(p2);
    
    updatePlaquetteVisual(p1);
    updatePlaquetteVisual(p2);
    logEvent(`BOOTSTRAP SPREAD: dormant → active`, 'muon');
    return;
  }
  
  contactCount++;
  
  // Both flip polarity on ANY contact
  flipPolarity(p1);
  flipPolarity(p2);
  
  // State exchange logic
  if (p1.state !== p2.state) {
    // Different states → both move toward state 2
    if (p1.state === STATE_3 && p2.state === STATE_1) {
      // 3 + 1 = both become 2
      p1.state = STATE_2;
      p1.phase = 1;
      p2.state = STATE_2;
      p2.phase = 1;
      logEvent('CONTACT: 3+1 → 2+2', 'muon');
    } else if (p1.state === STATE_3 && p2.state === STATE_2) {
      // 3 + 2: energy flows, 3→2, 2→3
      p1.state = STATE_2;
      p1.phase = 1;
      p2.state = STATE_3;
      p2.phase = 2;
    } else if (p1.state === STATE_1 && p2.state === STATE_2) {
      // 1 + 2: energy flows, 1→2, 2→1
      p1.state = STATE_2;
      p1.phase = 1;
      p2.state = STATE_1;
      p2.phase = 0;
    }
  }
  // Same states: just polarity flip, no state change
  
  updatePlaquetteVisual(p1);
  updatePlaquetteVisual(p2);
}

function flipPolarity(plaquette) {
  plaquette.polarity *= -1;
  plaquette.element.classList.add('flipping');
  setTimeout(() => {
    plaquette.element.classList.remove('flipping');
  }, 300);
}

// === NEUTRINO LAUNCHES ===
function launchElectronNeutrino() {
  logEvent('e⁻ NEUTRINO (0.45 eV) — Sub-threshold, speed channel only', 'electron');
  
  // Play speed channel whoosh
  if (audioEnabled && audioContext) {
    const osc = audioContext.createOscillator();
    const oscGain = audioContext.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(2000, audioContext.currentTime);
    osc.frequency.exponentialRampToValueAtTime(500, audioContext.currentTime + 0.3);
    osc.connect(oscGain);
    oscGain.connect(gainNode);
    oscGain.gain.setValueAtTime(0.1, audioContext.currentTime);
    oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
    osc.start();
    osc.stop(audioContext.currentTime + 0.3);
  }
  
  // Pick a random row to pass through
  const row = Math.floor(Math.random() * gridRows);
  
  // Flash each cell in the row sequentially
  let col = 0;
  const flashInterval = setInterval(() => {
    if (col >= gridCols) {
      clearInterval(flashInterval);
      return;
    }
    
    const p = grid[row][col];
    p.element.classList.add('channel-flash');
    
    setTimeout(() => {
      p.element.classList.remove('channel-flash');
    }, 200);
    
    col++;
  }, 80);
  
  // No state changes - just geometric alignment flash
}

function launchMuonNeutrino() {
  logEvent('μ NEUTRINO — Bootstrap sequence', 'muon');
  
  // Play bootstrap activation sound
  if (audioEnabled && audioContext) {
    const osc = audioContext.createOscillator();
    const oscGain = audioContext.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(330, audioContext.currentTime);
    osc.frequency.setValueAtTime(440, audioContext.currentTime + 0.1);
    osc.frequency.setValueAtTime(550, audioContext.currentTime + 0.2);
    osc.connect(oscGain);
    oscGain.connect(gainNode);
    oscGain.gain.setValueAtTime(0.2, audioContext.currentTime);
    oscGain.gain.setTargetAtTime(0.001, audioContext.currentTime + 0.2, 0.1);
    osc.start();
    osc.stop(audioContext.currentTime + 0.4);
  }
  
  // Find a dormant cell to activate, preferring edges
  let target = null;
  
  // Try edges first
  const edges = [];
  for (let c = 0; c < gridCols; c++) {
    edges.push(grid[0][c]);
    edges.push(grid[gridRows-1][c]);
  }
  for (let r = 1; r < gridRows-1; r++) {
    edges.push(grid[r][0]);
    edges.push(grid[r][gridCols-1]);
  }
  
  const dormantEdges = edges.filter(p => p.state === DORMANT);
  if (dormantEdges.length > 0) {
    target = dormantEdges[Math.floor(Math.random() * dormantEdges.length)];
  } else {
    // Find any dormant cell
    const allDormant = [];
    for (let r = 0; r < gridRows; r++) {
      for (let c = 0; c < gridCols; c++) {
        if (grid[r][c].state === DORMANT) {
          allDormant.push(grid[r][c]);
        }
      }
    }
    if (allDormant.length > 0) {
      target = allDormant[Math.floor(Math.random() * allDormant.length)];
    }
  }
  
  if (target) {
    // Activate at state 2 (equilibrium)
    target.state = STATE_2;
    target.phase = 1;
    updatePlaquetteVisual(target);
    logEvent(`Bootstrap at [${target.row}, ${target.col}]`, 'muon');
  } else {
    logEvent('No dormant cells to bootstrap', 'muon');
  }
}

function launchTauNeutrino() {
  logEvent('τ NEUTRINO — ATOM BOMB', 'tau');
  
  // Play bomb sound
  if (audioEnabled && audioContext) {
    const osc = audioContext.createOscillator();
    const oscGain = audioContext.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(880, audioContext.currentTime);
    osc.frequency.exponentialRampToValueAtTime(55, audioContext.currentTime + 0.5);
    osc.connect(oscGain);
    oscGain.connect(gainNode);
    oscGain.gain.setValueAtTime(0.3, audioContext.currentTime);
    oscGain.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.5);
    osc.start();
    osc.stop(audioContext.currentTime + 0.5);
  }
  
  // Pick impact point (center-ish)
  const centerR = Math.floor(gridRows / 2);
  const centerC = Math.floor(gridCols / 2);
  
  // Instant activation of center
  const center = grid[centerR][centerC];
  center.state = STATE_3;
  center.phase = 2;
  center.element.classList.add('bomb-flash');
  updatePlaquetteVisual(center);
  
  // Shockwave ripples outward
  const maxDist = Math.max(gridRows, gridCols);
  
  for (let dist = 1; dist <= maxDist; dist++) {
    setTimeout(() => {
      // Activate all cells at this distance
      for (let r = 0; r < gridRows; r++) {
        for (let c = 0; c < gridCols; c++) {
          const d = Math.abs(r - centerR) + Math.abs(c - centerC);
          if (d === dist) {
            const p = grid[r][c];
            p.state = STATE_3;
            p.phase = 2;
            p.element.classList.add('bomb-flash');
            updatePlaquetteVisual(p);
            
            setTimeout(() => {
              p.element.classList.remove('bomb-flash');
            }, 300);
          }
        }
      }
      
      // Previous ring contracts
      if (dist > 1) {
        for (let r = 0; r < gridRows; r++) {
          for (let c = 0; c < gridCols; c++) {
            const d = Math.abs(r - centerR) + Math.abs(c - centerC);
            if (d === dist - 1) {
              const p = grid[r][c];
              p.element.classList.remove('bomb-flash');
            }
          }
        }
      }
    }, dist * 150);
  }
  
  // Remove center flash
  setTimeout(() => {
    center.element.classList.remove('bomb-flash');
  }, 300);
}

// === UI ===
function updateMetrics() {
  let active = 0, reds = 0, greens = 0, blues = 0;
  
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const p = grid[r][c];
      if (p.state !== DORMANT) {
        active++;
        if (p.state === STATE_1) reds++;
        else if (p.state === STATE_2) greens++;
        else if (p.state === STATE_3) blues++;
      }
    }
  }
  
  const total = gridRows * gridCols;
  document.getElementById('activeCount').textContent = `${active} / ${total}`;
  document.getElementById('redCount').textContent = reds;
  document.getElementById('greenCount').textContent = greens;
  document.getElementById('blueCount').textContent = blues;
  document.getElementById('contactCount').textContent = contactCount;
  document.getElementById('resonanceCount').textContent = countResonanceGroups();
  
  // Status
  const statusEl = document.getElementById('statusValue');
  if (active === 0) {
    statusEl.textContent = 'DORMANT';
    statusEl.style.color = '#8a9bae';
  } else if (greens === active && active === total) {
    statusEl.textContent = 'EQUILIBRIUM';
    statusEl.style.color = '#66ff99';
  } else {
    statusEl.textContent = 'OSCILLATING';
    statusEl.style.color = '#ffb46a';
  }
}

function logEvent(message, type = '') {
  const log = document.getElementById('eventLog');
  const div = document.createElement('div');
  div.className = 'event-msg' + (type ? ` ${type}` : '');
  div.textContent = message;
  log.appendChild(div);
  setTimeout(() => div.remove(), 3000);
}

function resetNetwork() {
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const p = grid[r][c];
      p.state = DORMANT;
      p.phase = 0;
      p.polarity = Math.random() > 0.5 ? 1 : -1;
      p.skipping = false;
      p.skipCount = 0;
      updatePlaquetteVisual(p);
    }
  }
  contactCount = 0;
  updateMetrics();
  logEvent('NETWORK RESET');
}

function startSimulation() {
  if (tickTimer) clearInterval(tickTimer);
  tickTimer = setInterval(tick, TICK_INTERVAL / speedMultiplier);
}

// === EVENT LISTENERS ===
function setupEventListeners() {
  document.getElementById('launchElectron').addEventListener('click', launchElectronNeutrino);
  document.getElementById('launchMuon').addEventListener('click', launchMuonNeutrino);
  document.getElementById('launchTau').addEventListener('click', launchTauNeutrino);
  document.getElementById('resetBtn').addEventListener('click', resetNetwork);
  
  document.getElementById('pauseBtn').addEventListener('click', () => {
    paused = !paused;
    document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
  });
  
  document.getElementById('resonanceBtn').addEventListener('click', () => {
    resonanceMode = !resonanceMode;
    document.getElementById('resonanceBtn').textContent = `Resonance Trace: ${resonanceMode ? 'ON' : 'OFF'}`;
    updateResonanceVisualization();
  });
  
  document.getElementById('audioBtn').addEventListener('click', () => {
    audioEnabled = !audioEnabled;
    document.getElementById('audioBtn').textContent = `Audio: ${audioEnabled ? 'ON' : 'OFF'}`;
    if (audioEnabled) {
      initAudio();
      if (audioContext.state === 'suspended') {
        audioContext.resume();
      }
    }
  });
  
  document.getElementById('addRow').addEventListener('click', () => {
    if (gridRows < 12) { gridRows++; createGrid(); }
  });
  document.getElementById('addCol').addEventListener('click', () => {
    if (gridCols < 12) { gridCols++; createGrid(); }
  });
  document.getElementById('removeRow').addEventListener('click', () => {
    if (gridRows > 2) { gridRows--; createGrid(); }
  });
  document.getElementById('removeCol').addEventListener('click', () => {
    if (gridCols > 2) { gridCols--; createGrid(); }
  });
  
  document.getElementById('speedSlider').addEventListener('input', (e) => {
    speedMultiplier = parseFloat(e.target.value);
    document.getElementById('speedValue').textContent = `${speedMultiplier.toFixed(1)}x`;
    startSimulation(); // Restart with new speed
  });
  
  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    if (e.code === 'KeyE') launchElectronNeutrino();
    else if (e.code === 'KeyM') launchMuonNeutrino();
    else if (e.code === 'KeyT') launchTauNeutrino();
    else if (e.code === 'KeyR') resetNetwork();
    else if (e.code === 'Space') {
      e.preventDefault();
      paused = !paused;
      document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
    }
  });
}

// === RESONANCE & AUDIO ===
let resonanceMode = false;
let audioEnabled = false;
let audioContext = null;
let oscillators = {};
let gainNode = null;

// Base frequencies for the three states (pentatonic-ish)
const STATE_FREQUENCIES = {
  1: 220,   // Red - A3
  2: 330,   // Green - E4  
  3: 440    // Blue - A4
};

function playContactSound(state1, state2) {
  if (!audioEnabled || !audioContext) return;
  
  // Create a short blip for contact
  const osc = audioContext.createOscillator();
  const oscGain = audioContext.createGain();
  
  // Frequency based on states involved
  let freq = 200;
  if (state1 === STATE_3 && state2 === STATE_1) {
    freq = 523; // C5 - harmonious resolution (3+1=2+2)
  } else if (state2 === DORMANT) {
    freq = 392; // G4 - bootstrap spread
  } else {
    freq = 349; // F4 - normal contact
  }
  
  osc.type = 'triangle';
  osc.frequency.value = freq;
  osc.connect(oscGain);
  oscGain.connect(gainNode);
  
  // Quick attack, fast decay
  oscGain.gain.setValueAtTime(0.2, audioContext.currentTime);
  oscGain.gain.exponentialDecayTo = 0.01;
  oscGain.gain.setTargetAtTime(0.001, audioContext.currentTime + 0.05, 0.05);
  
  osc.start();
  osc.stop(audioContext.currentTime + 0.15);
}

function initAudio() {
  if (audioContext) return;
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  gainNode = audioContext.createGain();
  gainNode.gain.value = 0.1;
  gainNode.connect(audioContext.destination);
}

function updateAudio() {
  if (!audioEnabled || !audioContext) return;
  
  // Count states
  let counts = { 1: 0, 2: 0, 3: 0 };
  let total = 0;
  
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const p = grid[r][c];
      if (p.state !== DORMANT) {
        counts[p.state]++;
        total++;
      }
    }
  }
  
  if (total === 0) {
    // Silence
    Object.values(oscillators).forEach(osc => {
      osc.gain.gain.setTargetAtTime(0, audioContext.currentTime, 0.1);
    });
    return;
  }
  
  // Adjust oscillator volumes based on state proportions
  [1, 2, 3].forEach(state => {
    if (!oscillators[state]) {
      const osc = audioContext.createOscillator();
      const oscGain = audioContext.createGain();
      osc.type = 'sine';
      osc.frequency.value = STATE_FREQUENCIES[state];
      osc.connect(oscGain);
      oscGain.connect(gainNode);
      oscGain.gain.value = 0;
      osc.start();
      oscillators[state] = { osc, gain: oscGain };
    }
    
    const proportion = counts[state] / total;
    oscillators[state].gain.gain.setTargetAtTime(proportion * 0.3, audioContext.currentTime, 0.05);
    
    // Slight detune based on resonance (locked groups create beating)
    const resonanceGroups = countResonanceGroups();
    const detune = resonanceGroups > 3 ? Math.sin(Date.now() / 200) * 10 : 0;
    oscillators[state].osc.detune.setTargetAtTime(detune, audioContext.currentTime, 0.1);
  });
}

function countResonanceGroups() {
  // Quick count of distinct resonance groups
  const visited = new Set();
  let groups = 0;
  
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const key = `${r},${c}`;
      if (visited.has(key)) continue;
      
      const p = grid[r][c];
      if (p.state === DORMANT) continue;
      
      // BFS to find group
      const queue = [p];
      visited.add(key);
      let groupSize = 0;
      
      while (queue.length > 0) {
        const current = queue.shift();
        groupSize++;
        
        const neighbors = getNeighbors(current);
        for (const n of neighbors) {
          const nKey = `${n.row},${n.col}`;
          if (visited.has(nKey)) continue;
          if (n.state === DORMANT) continue;
          
          // Phase-locked if same state, same polarity, same phase
          if (n.state === current.state && n.polarity === current.polarity && n.phase === current.phase) {
            visited.add(nKey);
            queue.push(n);
          }
        }
      }
      
      if (groupSize >= 2) groups++;
    }
  }
  
  return groups;
}

function findResonanceGroups() {
  // Find all phase-locked groups and assign group IDs
  const groupMap = new Map(); // key -> group ID
  let groupId = 0;
  
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const key = `${r},${c}`;
      if (groupMap.has(key)) continue;
      
      const p = grid[r][c];
      if (p.state === DORMANT) continue;
      
      // BFS to find connected phase-locked nodes
      const queue = [p];
      const group = [p];
      groupMap.set(key, groupId);
      
      while (queue.length > 0) {
        const current = queue.shift();
        
        const neighbors = getNeighbors(current);
        for (const n of neighbors) {
          const nKey = `${n.row},${n.col}`;
          if (groupMap.has(nKey)) continue;
          if (n.state === DORMANT) continue;
          
          // Phase-locked: same state AND same polarity AND phase within ±1
          const phaseDiff = Math.abs(n.phase - current.phase);
          const phaseClose = phaseDiff <= 1 || phaseDiff === 2; // wrapping
          
          if (n.state === current.state && n.polarity === current.polarity && phaseClose) {
            groupMap.set(nKey, groupId);
            queue.push(n);
            group.push(n);
          }
        }
      }
      
      // Only count as a group if 2+ members
      if (group.length >= 2) {
        groupId++;
      } else {
        groupMap.delete(key);
      }
    }
  }
  
  return groupMap;
}

function updateResonanceVisualization() {
  if (!resonanceMode) {
    // Clear all resonance classes
    for (let r = 0; r < gridRows; r++) {
      for (let c = 0; c < gridCols; c++) {
        const el = grid[r][c].element;
        for (let i = 1; i <= 6; i++) {
          el.classList.remove(`resonance-group-${i}`);
        }
      }
    }
    return;
  }
  
  const groupMap = findResonanceGroups();
  
  for (let r = 0; r < gridRows; r++) {
    for (let c = 0; c < gridCols; c++) {
      const key = `${r},${c}`;
      const el = grid[r][c].element;
      
      // Clear previous
      for (let i = 1; i <= 6; i++) {
        el.classList.remove(`resonance-group-${i}`);
      }
      
      // Add new group class if in a group
      if (groupMap.has(key)) {
        const gId = groupMap.get(key) % 6 + 1;
        el.classList.add(`resonance-group-${gId}`);
      }
    }
  }
}

// === START ===
init();
</script>

</body>
</html>
