<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ANGEL-1 ¬∑ Breath Field ¬∑ Sound</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Cormorant+Garamond:wght@300;400&family=Space+Mono:wght@400&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            background: #0a0a0c;
            color: #e8e4dc;
            font-family: 'Cormorant Garamond', serif;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        header {
            position: sticky;
            top: 0;
            z-index: 200;
            padding: 1rem 2rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid rgba(255,255,255,0.06);
            background: #0a0a0c;
        }
        
        .logo {
            font-size: 0.85rem;
            letter-spacing: 0.3em;
            color: #c9a55a;
            font-family: 'Space Mono', monospace;
        }
        
        nav { display: flex; gap: 2rem; }
        
        nav a {
            color: #666;
            text-decoration: none;
            font-size: 0.8rem;
            letter-spacing: 0.15em;
            font-family: 'Space Mono', monospace;
            transition: color 0.3s;
        }
        
        nav a:hover, nav a.active { color: #e8e4dc; }
        
        .epigraph {
            text-align: center;
            padding: 1.5rem;
            font-size: 1rem;
            color: #888;
            font-style: italic;
        }
        
        .epigraph em { color: #a89060; }
        
        main {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem 2rem 3rem;
        }
        
        .canvas-container {
            position: relative;
            border: 1px solid rgba(255,255,255,0.08);
            overflow: hidden;
            box-shadow: 0 0 60px rgba(169, 144, 96, 0.05);
        }
        
        #field-canvas {
            display: block;
            background: #050507;
            cursor: crosshair;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            margin-top: 1.5rem;
            padding: 1rem 1.5rem;
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.06);
            justify-content: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        
        .control-group label {
            font-size: 0.65rem;
            letter-spacing: 0.15em;
            color: #666;
            font-family: 'Space Mono', monospace;
            text-transform: uppercase;
        }
        
        .control-group input[type="range"] {
            width: 120px;
            height: 2px;
            -webkit-appearance: none;
            background: rgba(255,255,255,0.1);
            cursor: pointer;
        }
        
        .control-group input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 10px;
            height: 10px;
            background: #c9a55a;
            border-radius: 50%;
            cursor: pointer;
        }
        
        .control-row {
            display: flex;
            gap: 0.8rem;
            margin-top: 1rem;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        button {
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            letter-spacing: 0.08em;
            padding: 0.5rem 1rem;
            background: transparent;
            border: 1px solid rgba(255,255,255,0.15);
            color: #e8e4dc;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: rgba(201, 165, 90, 0.1);
            border-color: #c9a55a;
        }
        
        button.active {
            background: rgba(201, 165, 90, 0.15);
            border-color: #c9a55a;
            color: #c9a55a;
        }
        
        button.sound-on {
            background: rgba(16, 185, 129, 0.2);
            border-color: #10b981;
            color: #10b981;
        }
        
        .visualization-modes {
            display: flex;
            gap: 0.4rem;
            margin-top: 1rem;
        }
        
        .mode-btn {
            padding: 0.35rem 0.7rem;
            font-size: 0.6rem;
        }
        
        .metrics {
            display: flex;
            gap: 1.5rem;
            margin-top: 1rem;
            font-family: 'Space Mono', monospace;
            font-size: 0.65rem;
            color: #555;
            flex-wrap: wrap;
            justify-content: center;
        }
        
        .metric {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.2rem;
        }
        
        .metric-value {
            font-size: 1rem;
            color: #c9a55a;
        }
        
        .metric-label {
            letter-spacing: 0.1em;
            text-transform: uppercase;
            font-size: 0.55rem;
        }
        
        .probe-panel {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(10, 10, 12, 0.95);
            border: 1px solid rgba(201, 165, 90, 0.3);
            padding: 0.8rem 1.2rem;
            font-family: 'Space Mono', monospace;
            font-size: 0.7rem;
            min-width: 180px;
            display: none;
            z-index: 100;
        }
        
        .probe-panel.active { display: block; }
        
        .probe-title {
            color: #c9a55a;
            font-size: 0.6rem;
            letter-spacing: 0.15em;
            margin-bottom: 0.6rem;
            text-transform: uppercase;
        }
        
        .probe-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.3rem;
        }
        
        .probe-row .label { color: #666; }
        .probe-row .value { color: #e8e4dc; }
        .probe-row.highlight .value { color: #c9a55a; }
        
        .probe-coords {
            color: #555;
            font-size: 0.6rem;
            margin-top: 0.6rem;
            padding-top: 0.4rem;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        .sound-controls {
            background: rgba(16, 185, 129, 0.05);
            border: 1px solid rgba(16, 185, 129, 0.2);
            padding: 1rem;
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            justify-content: center;
            align-items: center;
        }
        
        .sound-controls .control-group label {
            color: #10b981;
        }
    </style>
</head>
<body>
    <header>
        <div class="logo">MICHRON PHYSICS</div>
        <nav>
            <a href="index.html">Classic</a>
            <a href="torsion-field.html">Torsion Field</a>
            <a href="breath-field.html">Breath</a>
            <a href="breath-field-sound.html" class="active">Breath+Sound</a>
            <a href="chronos.html">Chronos</a>
        </nav>
    </header>
    
    <div class="epigraph">
        The field breathes. Heat falls into cool. The vortex is the stable form that persists.
    </div>
    
    <div class="probe-panel" id="probe-panel">
        <div class="probe-title">Field Probe</div>
        <div class="probe-row">
            <span class="label">Amplitude</span>
            <span class="value" id="probe-amp">‚Äî</span>
        </div>
        <div class="probe-row">
            <span class="label">Phase</span>
            <span class="value" id="probe-phase">‚Äî</span>
        </div>
        <div class="probe-row">
            <span class="label">Velocity</span>
            <span class="value" id="probe-vel">‚Äî</span>
        </div>
        <div class="probe-row highlight">
            <span class="label">Vorticity</span>
            <span class="value" id="probe-vort">‚Äî</span>
        </div>
        <div class="probe-row">
            <span class="label">State</span>
            <span class="value" id="probe-state">‚Äî</span>
        </div>
        <div class="probe-coords" id="probe-coords">Hover over field</div>
    </div>
    
    <main>
        <div class="canvas-container">
            <canvas id="field-canvas" width="900" height="600"></canvas>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Breath Rate</label>
                <input type="range" id="breath-rate" min="0.1" max="2" step="0.1" value="0.8">
            </div>
            <div class="control-group">
                <label>Coupling</label>
                <input type="range" id="coupling" min="0.01" max="0.3" step="0.01" value="0.12">
            </div>
            <div class="control-group">
                <label>Initial Twist</label>
                <input type="range" id="twist" min="0" max="5" step="0.5" value="2">
            </div>
            <div class="control-group">
                <label>Damping</label>
                <input type="range" id="damping" min="0.99" max="1" step="0.001" value="0.997">
            </div>
            <div class="control-group">
                <label>Color Theme</label>
                <select id="color-theme" style="background: #1a1a1c; color: #e8e4dc; border: 1px solid rgba(255,255,255,0.15); padding: 0.3rem; font-family: 'Space Mono', monospace; font-size: 0.65rem;">
                    <option value="gold">Gold/Amber</option>
                    <option value="ocean">Ocean Blue</option>
                    <option value="forest">Forest Green</option>
                    <option value="violet">Violet</option>
                    <option value="fire">Fire</option>
                    <option value="thermal">Thermal</option>
                    <option value="mono">Monochrome</option>
                </select>
            </div>
            <div class="control-group">
                <label>Grid Scale</label>
                <select id="grid-scale" style="background: #1a1a1c; color: #e8e4dc; border: 1px solid rgba(255,255,255,0.15); padding: 0.3rem; font-family: 'Space Mono', monospace; font-size: 0.65rem;">
                    <option value="1">1x (180√ó120)</option>
                    <option value="2">2x (360√ó240)</option>
                    <option value="3">3x (540√ó360)</option>
                    <option value="4">4x (720√ó480)</option>
                </select>
            </div>
            <div class="control-group">
                <label>Zoom</label>
                <input type="range" id="zoom" min="0.5" max="2" step="0.1" value="1">
            </div>
        </div>
        
        <div class="control-row">
            <button id="pause-btn">Pause</button>
            <button id="reset-btn">Reset</button>
            <button id="perturb-btn">Perturbation</button>
            <button id="vortex-btn">Seed Vortex</button>
            <button id="sound-btn">üîá Enable Sound</button>
            <button id="export-btn">Export Data</button>
            <button id="record-btn">‚è∫ Record Session</button>
        </div>
        
        <div class="sound-controls" id="sound-controls" style="display: none;">
            <div class="control-group">
                <label>Master Volume</label>
                <input type="range" id="master-vol" min="0" max="100" step="5" value="50">
            </div>
            <div class="control-group">
                <label>Thunder (Low)</label>
                <input type="range" id="thunder-vol" min="0" max="100" step="5" value="60">
            </div>
            <div class="control-group">
                <label>Foundation (432Hz)</label>
                <input type="range" id="foundation-vol" min="0" max="100" step="5" value="40">
            </div>
            <div class="control-group">
                <label>Sparkle (528Hz)</label>
                <input type="range" id="sparkle-vol" min="0" max="100" step="5" value="30">
            </div>
            <div class="control-group">
                <label>Sustain (Pedal)</label>
                <input type="range" id="sustain" min="0" max="100" step="5" value="70">
            </div>
        </div>
        
        <div class="visualization-modes">
            <button class="mode-btn active" data-mode="amplitude">Amplitude</button>
            <button class="mode-btn" data-mode="phase">Phase</button>
            <button class="mode-btn" data-mode="vorticity">Vorticity</button>
            <button class="mode-btn" data-mode="breath">Breath</button>
        </div>
        
        <div class="metrics">
            <div class="metric">
                <span class="metric-value" id="vortex-count">0</span>
                <span class="metric-label">Vortices</span>
            </div>
            <div class="metric">
                <span class="metric-value" id="total-energy">0</span>
                <span class="metric-label">Energy</span>
            </div>
            <div class="metric">
                <span class="metric-value" id="avg-phase">0</span>
                <span class="metric-label">Coherence</span>
            </div>
            <div class="metric">
                <span class="metric-value" id="tick">0</span>
                <span class="metric-label">Tick</span>
            </div>
            <div class="metric">
                <span class="metric-value" id="breath-phase">‚Äî</span>
                <span class="metric-label">Breath</span>
            </div>
            <div class="metric" id="recording-indicator" style="display: none;">
                <span class="metric-value" style="color: #ef4444;">‚óè</span>
                <span class="metric-label">REC</span>
            </div>
        </div>
    </main>
    
    <script>
        // ========================================
        // BREATH FIELD WITH SOUND
        // Piano voices, 432Hz tuning, breath as tide
        // ========================================
        
        const canvas = document.getElementById('field-canvas');
        const ctx = canvas.getContext('2d');
        
        // Field dimensions (mutable for grid scaling)
        let GRID_W = 180;
        let GRID_H = 120;
        let CELL_W = canvas.width / GRID_W;
        let CELL_H = canvas.height / GRID_H;
        let gridScale = 1;
        let zoom = 1;
        
        // Metrics history - flight recorder
        const metricsHistory = [];
        const MAX_HISTORY = 2000; // Keep last 2000 ticks
        
        // Long-duration recording
        let recording = false;
        let recordingData = {
            startTime: null,
            params: null,
            soundParams: null,
            events: [],           // perturbations, vortex seeds, param changes
            metrics: [],          // every tick: compact [tick, vortices, energy, coherence, amp, breathTide]
            snapshots: []         // every N ticks: full field state
        };
        const SNAPSHOT_INTERVAL = 500; // Full snapshot every 500 ticks
        
        // Field state
        let field = {
            amplitude: [],
            phase: [],
            velocity: [],
            vorticity: []
        };
        
        // Simulation parameters
        let params = {
            breathRate: 0.8,
            coupling: 0.12,
            initialTwist: 2,
            damping: 0.997
        };
        
        // Global state
        let running = true;
        let tick = 0;
        let vizMode = 'amplitude';
        let globalBreathPhase = 0;
        const BREATH_PERIOD = 200;
        const REST_AMPLITUDE = 0.25;
        
        // Previous vortex count for detecting new vortices
        let prevVortexPositions = new Set();
        
        // Color themes
        const themes = {
            gold:    { primary: 35,  secondary: 45,  accent: 55,  sat: 70 },
            ocean:   { primary: 200, secondary: 220, accent: 180, sat: 65 },
            forest:  { primary: 120, secondary: 90,  accent: 150, sat: 50 },
            violet:  { primary: 280, secondary: 260, accent: 300, sat: 60 },
            fire:    { primary: 15,  secondary: 30,  accent: 0,   sat: 80 },
            thermal: { primary: 240, secondary: 0,   accent: 60,  sat: 75 },
            mono:    { primary: 0,   secondary: 0,   accent: 0,   sat: 0 }
        };
        let currentTheme = 'gold';
        
        // ========================================
        // SOUND SYSTEM - 432Hz Tuning
        // ========================================
        
        let audioCtx = null;
        let soundEnabled = false;
        
        // Master chain
        let masterGain = null;
        let masterCompressor = null;
        
        // Voices
        let thunderOsc = null;      // 54Hz - sub-harmonic rumble
        let thunderGain = null;
        let foundationOsc = null;   // 432Hz - warm presence
        let foundationGain = null;
        let reverbNode = null;
        
        // Sound parameters
        let soundParams = {
            master: 0.5,
            thunder: 0.6,
            foundation: 0.4,
            sparkle: 0.3,
            sustain: 0.7
        };
        
        // Piano-like envelope for sparkle notes
        function createPianoEnvelope(audioCtx, duration, velocity = 0.5) {
            const envelope = audioCtx.createGain();
            const now = audioCtx.currentTime;
            const attack = 0.01;
            const decay = duration * 0.3;
            const sustainLevel = 0.3 * velocity;
            const release = duration * soundParams.sustain;
            
            envelope.gain.setValueAtTime(0, now);
            envelope.gain.linearRampToValueAtTime(velocity, now + attack);
            envelope.gain.exponentialRampToValueAtTime(sustainLevel + 0.001, now + attack + decay);
            envelope.gain.exponentialRampToValueAtTime(0.001, now + duration + release);
            
            return envelope;
        }
        
        // Create convolution reverb
        function createReverb(audioCtx, duration = 2, decay = 2) {
            const sampleRate = audioCtx.sampleRate;
            const length = sampleRate * duration;
            const impulse = audioCtx.createBuffer(2, length, sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
                }
            }
            
            const convolver = audioCtx.createConvolver();
            convolver.buffer = impulse;
            return convolver;
        }
        
        function initAudio() {
            if (audioCtx) return;
            
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            // Master compressor for smooth dynamics
            masterCompressor = audioCtx.createDynamicsCompressor();
            masterCompressor.threshold.value = -24;
            masterCompressor.knee.value = 30;
            masterCompressor.ratio.value = 4;
            masterCompressor.attack.value = 0.003;
            masterCompressor.release.value = 0.25;
            masterCompressor.connect(audioCtx.destination);
            
            // Master gain
            masterGain = audioCtx.createGain();
            masterGain.gain.value = soundParams.master * 0.3;
            masterGain.connect(masterCompressor);
            
            // Reverb for space
            reverbNode = createReverb(audioCtx, 3, 2.5);
            const reverbGain = audioCtx.createGain();
            reverbGain.gain.value = 0.3;
            reverbNode.connect(reverbGain);
            reverbGain.connect(masterGain);
            
            // Thunder voice - 54Hz (sub-harmonic of 432)
            thunderOsc = audioCtx.createOscillator();
            thunderOsc.type = 'sine';
            thunderOsc.frequency.value = 54; // 432 / 8
            
            // Add slight detuned layer for richness
            const thunderOsc2 = audioCtx.createOscillator();
            thunderOsc2.type = 'sine';
            thunderOsc2.frequency.value = 54.5;
            
            thunderGain = audioCtx.createGain();
            thunderGain.gain.value = 0;
            
            // Low-pass filter for thunder
            const thunderFilter = audioCtx.createBiquadFilter();
            thunderFilter.type = 'lowpass';
            thunderFilter.frequency.value = 100;
            thunderFilter.Q.value = 1;
            
            thunderOsc.connect(thunderGain);
            thunderOsc2.connect(thunderGain);
            thunderGain.connect(thunderFilter);
            thunderFilter.connect(masterGain);
            thunderFilter.connect(reverbNode);
            
            thunderOsc.start();
            thunderOsc2.start();
            
            // Foundation voice - 432Hz
            foundationOsc = audioCtx.createOscillator();
            foundationOsc.type = 'sine';
            foundationOsc.frequency.value = 432;
            
            // Add subtle harmonics
            const foundationOsc2 = audioCtx.createOscillator();
            foundationOsc2.type = 'sine';
            foundationOsc2.frequency.value = 216; // Octave below
            
            foundationGain = audioCtx.createGain();
            foundationGain.gain.value = 0;
            
            const foundationFilter = audioCtx.createBiquadFilter();
            foundationFilter.type = 'lowpass';
            foundationFilter.frequency.value = 800;
            
            foundationOsc.connect(foundationGain);
            foundationOsc2.connect(foundationGain);
            foundationGain.connect(foundationFilter);
            foundationFilter.connect(masterGain);
            foundationFilter.connect(reverbNode);
            
            foundationOsc.start();
            foundationOsc2.start();
        }
        
        // Play sparkle note when vortex forms
        function playVortexSparkle(x, y, vorticity) {
            if (!audioCtx || !soundEnabled) return;
            
            // 528Hz base, with variation based on position
            const baseFreq = 528;
            const freqVariation = 1 + (y / GRID_H - 0.5) * 0.2; // Higher at top
            const freq = baseFreq * freqVariation;
            
            const osc = audioCtx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = freq;
            
            // Add harmonic
            const osc2 = audioCtx.createOscillator();
            osc2.type = 'sine';
            osc2.frequency.value = freq * 2; // Octave up, quieter
            
            const osc2Gain = audioCtx.createGain();
            osc2Gain.gain.value = 0.2;
            
            const envelope = createPianoEnvelope(audioCtx, 0.5, soundParams.sparkle * 0.15);
            
            // Stereo panning based on x position
            const panner = audioCtx.createStereoPanner();
            panner.pan.value = (x / GRID_W) * 2 - 1;
            
            osc.connect(envelope);
            osc2.connect(osc2Gain);
            osc2Gain.connect(envelope);
            envelope.connect(panner);
            panner.connect(masterGain);
            panner.connect(reverbNode);
            
            const now = audioCtx.currentTime;
            osc.start(now);
            osc2.start(now);
            osc.stop(now + 1.5);
            osc2.stop(now + 1.5);
        }
        
        // Update continuous sounds based on field state
        function updateSound(avgAmplitude, coherence, vortexCount, breathTide) {
            if (!audioCtx || !soundEnabled) return;
            
            const now = audioCtx.currentTime;
            
            // Thunder swells on exhale (breathTide > 0), fades on inhale
            const thunderTarget = Math.max(0, breathTide) * avgAmplitude * soundParams.thunder * 0.15;
            thunderGain.gain.linearRampToValueAtTime(thunderTarget, now + 0.1);
            
            // Foundation tied to coherence - more coherent = louder, clearer
            const foundationTarget = coherence * soundParams.foundation * 0.08;
            foundationGain.gain.linearRampToValueAtTime(foundationTarget, now + 0.1);
            
            // Slight pitch drift based on average amplitude
            const pitchDrift = 1 + (avgAmplitude - 0.5) * 0.01;
            foundationOsc.frequency.linearRampToValueAtTime(432 * pitchDrift, now + 0.1);
        }
        
        function toggleSound() {
            soundEnabled = !soundEnabled;
            const btn = document.getElementById('sound-btn');
            const controls = document.getElementById('sound-controls');
            
            if (soundEnabled) {
                initAudio();
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                btn.textContent = 'üîä Sound On';
                btn.classList.add('sound-on');
                controls.style.display = 'flex';
            } else {
                btn.textContent = 'üîá Enable Sound';
                btn.classList.remove('sound-on');
                controls.style.display = 'none';
                
                if (audioCtx) {
                    const now = audioCtx.currentTime;
                    thunderGain.gain.linearRampToValueAtTime(0, now + 0.3);
                    foundationGain.gain.linearRampToValueAtTime(0, now + 0.3);
                }
            }
        }
        
        // ========================================
        // FIELD SIMULATION
        // ========================================
        
        function updateCanvasSize() {
            GRID_W = 180 * gridScale;
            GRID_H = 120 * gridScale;
            canvas.width = 900 * zoom;
            canvas.height = 600 * zoom;
            CELL_W = canvas.width / GRID_W;
            CELL_H = canvas.height / GRID_H;
        }
        
        function initField() {
            updateCanvasSize();
            metricsHistory.length = 0; // Clear history on reset
            
            field.amplitude = [];
            field.phase = [];
            field.velocity = [];
            field.vorticity = [];
            
            const twist = params.initialTwist;
            
            for (let y = 0; y < GRID_H; y++) {
                field.amplitude[y] = [];
                field.phase[y] = [];
                field.velocity[y] = [];
                field.vorticity[y] = [];
                
                for (let x = 0; x < GRID_W; x++) {
                    const nx = x / GRID_W;
                    const ny = y / GRID_H;
                    
                    const basePhase = twist * (
                        Math.sin(nx * Math.PI * 4) * Math.cos(ny * Math.PI * 3) +
                        0.5 * Math.sin(nx * Math.PI * 7 + ny * Math.PI * 5) +
                        0.3 * Math.sin((nx + ny) * Math.PI * 11)
                    );
                    
                    const noise = (Math.random() - 0.5) * 0.5;
                    
                    field.amplitude[y][x] = REST_AMPLITUDE + 0.05 * Math.sin(nx * Math.PI * 2) * Math.sin(ny * Math.PI * 2) + (Math.random() - 0.5) * 0.05;
                    field.phase[y][x] = basePhase + noise;
                    field.velocity[y][x] = (Math.random() - 0.5) * 0.05;
                    field.vorticity[y][x] = 0;
                }
            }
            
            tick = 0;
            globalBreathPhase = 0;
            prevVortexPositions.clear();
        }
        
        function getPhase(x, y) {
            const wx = ((x % GRID_W) + GRID_W) % GRID_W;
            const wy = ((y % GRID_H) + GRID_H) % GRID_H;
            return field.phase[wy][wx];
        }
        
        function getAmplitude(x, y) {
            const wx = ((x % GRID_W) + GRID_W) % GRID_W;
            const wy = ((y % GRID_H) + GRID_H) % GRID_H;
            return field.amplitude[wy][wx];
        }
        
        function phaseDiff(p1, p2) {
            let diff = p1 - p2;
            while (diff > Math.PI) diff -= 2 * Math.PI;
            while (diff < -Math.PI) diff += 2 * Math.PI;
            return diff;
        }
        
        function computeVorticity(x, y) {
            const pN = getPhase(x, y - 1);
            const pS = getPhase(x, y + 1);
            const pE = getPhase(x + 1, y);
            const pW = getPhase(x - 1, y);
            const pNE = getPhase(x + 1, y - 1);
            const pNW = getPhase(x - 1, y - 1);
            const pSE = getPhase(x + 1, y + 1);
            const pSW = getPhase(x - 1, y + 1);
            
            let circulation = 0;
            circulation += phaseDiff(pE, pNE);
            circulation += phaseDiff(pSE, pE);
            circulation += phaseDiff(pS, pSE);
            circulation += phaseDiff(pSW, pS);
            circulation += phaseDiff(pW, pSW);
            circulation += phaseDiff(pNW, pW);
            circulation += phaseDiff(pN, pNW);
            circulation += phaseDiff(pNE, pN);
            
            return circulation / (2 * Math.PI);
        }
        
        function updateField() {
            const dt = 0.1 * params.breathRate;
            const coupling = params.coupling;
            const damping = params.damping;
            
            globalBreathPhase += (2 * Math.PI / BREATH_PERIOD) * params.breathRate;
            const breathTide = Math.sin(globalBreathPhase);
            const isInhaling = breathTide < 0;
            const isExhaling = breathTide > 0;
            
            const newPhase = [];
            const newVelocity = [];
            const newAmplitude = [];
            
            for (let y = 0; y < GRID_H; y++) {
                newPhase[y] = [];
                newVelocity[y] = [];
                newAmplitude[y] = [];
                
                for (let x = 0; x < GRID_W; x++) {
                    const currentPhase = field.phase[y][x];
                    const currentVel = field.velocity[y][x];
                    const currentAmp = field.amplitude[y][x];
                    
                    const pN = getPhase(x, y - 1);
                    const pS = getPhase(x, y + 1);
                    const pE = getPhase(x + 1, y);
                    const pW = getPhase(x - 1, y);
                    
                    const aN = getAmplitude(x, y - 1);
                    const aS = getAmplitude(x, y + 1);
                    const aE = getAmplitude(x + 1, y);
                    const aW = getAmplitude(x - 1, y);
                    
                    let phaseForce = 0;
                    phaseForce += aN * Math.sin(phaseDiff(pN, currentPhase));
                    phaseForce += aS * Math.sin(phaseDiff(pS, currentPhase));
                    phaseForce += aE * Math.sin(phaseDiff(pE, currentPhase));
                    phaseForce += aW * Math.sin(phaseDiff(pW, currentPhase));
                    phaseForce *= coupling;
                    
                    const ampLaplacian = (aN + aS + aE + aW - 4 * currentAmp);
                    const vort = Math.abs(field.vorticity[y][x]);
                    const stabilization = 1.0 / (1.0 + vort * 3);
                    
                    let newVel = currentVel + phaseForce * dt * stabilization;
                    newVel *= damping;
                    
                    let newPh = currentPhase + newVel * dt;
                    
                    const springForce = (REST_AMPLITUDE - currentAmp) * 0.02;
                    const tideInfluence = breathTide * 0.015 * (1 - Math.min(vort, 0.8));
                    
                    let vortexGrowth = 0;
                    if (vort > 0.3) {
                        if (isExhaling) {
                            vortexGrowth = vort * 0.005 * Math.max(0, 1 - currentAmp);
                        } else {
                            vortexGrowth = -vort * 0.003;
                        }
                    }
                    
                    const diffusion = 0.01 * ampLaplacian * dt;
                    
                    let newAmp = currentAmp + springForce + tideInfluence + vortexGrowth + diffusion;
                    newAmp = Math.max(0.05, Math.min(1.0, newAmp));
                    
                    newPhase[y][x] = newPh;
                    newVelocity[y][x] = newVel;
                    newAmplitude[y][x] = newAmp;
                }
            }
            
            // Track new vortices for sound
            const currentVortexPositions = new Set();
            
            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    field.phase[y][x] = newPhase[y][x];
                    field.velocity[y][x] = newVelocity[y][x];
                    field.amplitude[y][x] = newAmplitude[y][x];
                    field.vorticity[y][x] = computeVorticity(x, y);
                    
                    // Track strong vortices
                    if (Math.abs(field.vorticity[y][x]) > 0.6) {
                        const key = `${x},${y}`;
                        currentVortexPositions.add(key);
                        
                        // Play sparkle for new vortices (limit rate)
                        if (!prevVortexPositions.has(key) && Math.random() < 0.1) {
                            playVortexSparkle(x, y, field.vorticity[y][x]);
                        }
                    }
                }
            }
            
            prevVortexPositions = currentVortexPositions;
            tick++;
        }
        
        // Color functions with theme support
        function amplitudeColor(amp, phase) {
            const t = themes[currentTheme];
            const h = t.primary + amp * 20;
            const s = t.sat > 0 ? (40 + amp * 30) : 0;
            const l = amp * 50;
            return `hsl(${h}, ${s}%, ${l}%)`;
        }
        
        function phaseColor(phase, amp) {
            const t = themes[currentTheme];
            let h = ((phase % (2 * Math.PI)) / (2 * Math.PI)) * 360;
            if (h < 0) h += 360;
            const s = t.sat > 0 ? 60 : 0;
            const l = 20 + amp * 40;
            return `hsl(${h}, ${s}%, ${l}%)`;
        }
        
        function vorticityColor(vort, amp) {
            const t = themes[currentTheme];
            const absVort = Math.abs(vort);
            if (absVort < 0.1) {
                const l = amp * 15;
                return `hsl(${t.secondary}, ${t.sat > 0 ? 20 : 0}%, ${l}%)`;
            }
            // Positive = accent hue, negative = secondary hue
            const h = vort > 0 ? t.accent : t.secondary;
            const s = t.sat > 0 ? 70 : 0;
            const l = 15 + absVort * 60;
            return `hsl(${h}, ${s}%, ${l}%)`;
        }
        
        function breathColor(amp, vel) {
            const t = themes[currentTheme];
            const tideFactor = Math.sin(globalBreathPhase);
            const localBreath = Math.tanh(vel * 5);
            const combined = tideFactor * 0.6 + localBreath * 0.4;
            
            if (combined < 0) {
                // Inhale - use secondary/cooler hue
                const intensity = Math.abs(combined);
                const l = 8 + intensity * amp * 45;
                const h = t.secondary;
                return `hsl(${h}, ${t.sat > 0 ? 65 : 0}%, ${l}%)`;
            } else {
                // Exhale - use primary/warmer hue
                const intensity = combined;
                const l = 8 + intensity * amp * 45;
                const h = t.primary;
                return `hsl(${h}, ${t.sat > 0 ? 75 : 0}%, ${l}%)`;
            }
        }
        
        function render() {
            ctx.fillStyle = '#050507';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    const amp = field.amplitude[y][x];
                    const phase = field.phase[y][x];
                    const vort = field.vorticity[y][x];
                    const vel = field.velocity[y][x];
                    
                    let color;
                    switch (vizMode) {
                        case 'amplitude': color = amplitudeColor(amp, phase); break;
                        case 'phase': color = phaseColor(phase, amp); break;
                        case 'vorticity': color = vorticityColor(vort, amp); break;
                        case 'breath': color = breathColor(amp, vel); break;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fillRect(x * CELL_W, y * CELL_H, CELL_W + 0.5, CELL_H + 0.5);
                }
            }
            
            if (vizMode !== 'vorticity') {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.25)';
                ctx.lineWidth = 1 * zoom;
                
                for (let y = 2; y < GRID_H - 2; y++) {
                    for (let x = 2; x < GRID_W - 2; x++) {
                        const vort = Math.abs(field.vorticity[y][x]);
                        if (vort > 0.4) {
                            const cx = (x + 0.5) * CELL_W;
                            const cy = (y + 0.5) * CELL_H;
                            const r = vort * 6 * zoom;
                            
                            ctx.beginPath();
                            ctx.arc(cx, cy, r, 0, Math.PI * 2);
                            ctx.stroke();
                        }
                    }
                }
            }
        }
        
        function computeMetrics() {
            let vortexCount = 0;
            let totalEnergy = 0;
            let sumCos = 0, sumSin = 0;
            let totalAmp = 0;
            
            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    const amp = field.amplitude[y][x];
                    const vel = field.velocity[y][x];
                    const vort = Math.abs(field.vorticity[y][x]);
                    const phase = field.phase[y][x];
                    
                    totalEnergy += 0.5 * vel * vel + 0.5 * amp * amp;
                    totalAmp += amp;
                    if (vort > 0.5) vortexCount++;
                    
                    sumCos += Math.cos(phase);
                    sumSin += Math.sin(phase);
                }
            }
            
            const n = GRID_W * GRID_H;
            const avgAmp = totalAmp / n;
            const phaseCoherence = Math.sqrt(sumCos * sumCos + sumSin * sumSin) / n;
            const breathTide = Math.sin(globalBreathPhase);
            
            document.getElementById('vortex-count').textContent = vortexCount;
            document.getElementById('total-energy').textContent = totalEnergy.toFixed(0);
            document.getElementById('avg-phase').textContent = phaseCoherence.toFixed(3);
            document.getElementById('tick').textContent = tick;
            document.getElementById('breath-phase').textContent = breathTide > 0 ? '‚Üë' : '‚Üì';
            
            // Log to history (flight recorder)
            metricsHistory.push({
                tick: tick,
                vortexCount: vortexCount,
                energy: totalEnergy,
                coherence: phaseCoherence,
                avgAmplitude: avgAmp,
                breathTide: breathTide
            });
            
            // Trim history if too long
            if (metricsHistory.length > MAX_HISTORY) {
                metricsHistory.shift();
            }
            
            // Long-duration recording
            if (recording) {
                // Compact metrics every tick: [tick, vortices, energy, coherence, amp, breathTide]
                recordingData.metrics.push([
                    tick,
                    vortexCount,
                    +totalEnergy.toFixed(1),
                    +phaseCoherence.toFixed(4),
                    +avgAmp.toFixed(4),
                    +breathTide.toFixed(3)
                ]);
                
                // Full snapshot every N ticks
                if (tick % SNAPSHOT_INTERVAL === 0) {
                    const snapshot = {
                        tick: tick,
                        amplitude: [],
                        vorticity: []
                    };
                    // Store only amplitude and vorticity (phase/velocity can be inferred)
                    for (let y = 0; y < GRID_H; y++) {
                        for (let x = 0; x < GRID_W; x++) {
                            snapshot.amplitude.push(+field.amplitude[y][x].toFixed(3));
                            snapshot.vorticity.push(+field.vorticity[y][x].toFixed(3));
                        }
                    }
                    recordingData.snapshots.push(snapshot);
                }
            }
            
            // Update sound
            updateSound(avgAmp, phaseCoherence, vortexCount, breathTide);
        }
        
        function addPerturbation() {
            const cx = Math.floor(Math.random() * GRID_W);
            const cy = Math.floor(Math.random() * GRID_H);
            const radius = (10 + Math.random() * 15) * gridScale;
            const strength = (Math.random() - 0.5) * 3;
            
            // Log event
            if (recording) {
                recordingData.events.push({
                    type: 'perturbation',
                    tick: tick,
                    x: cx, y: cy,
                    radius: +radius.toFixed(1),
                    strength: +strength.toFixed(2)
                });
            }
            
            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    const dx = x - cx;
                    const dy = y - cy;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius) {
                        const falloff = Math.cos((dist / radius) * Math.PI / 2);
                        field.velocity[y][x] += strength * falloff;
                        field.amplitude[y][x] += Math.abs(strength) * 0.1 * falloff;
                    }
                }
            }
        }
        
        function seedVortex() {
            const cx = Math.floor(GRID_W * 0.2 + Math.random() * GRID_W * 0.6);
            const cy = Math.floor(GRID_H * 0.2 + Math.random() * GRID_H * 0.6);
            const sign = Math.random() > 0.5 ? 1 : -1;
            const radius = (8 + Math.random() * 8) * gridScale;
            
            // Log event
            if (recording) {
                recordingData.events.push({
                    type: 'vortex_seed',
                    tick: tick,
                    x: cx, y: cy,
                    chirality: sign,
                    radius: +radius.toFixed(1)
                });
            }
            
            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    const dx = x - cx;
                    const dy = y - cy;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dist < radius && dist > 0) {
                        const angle = Math.atan2(dy, dx);
                        const falloff = 1 - dist / radius;
                        field.phase[y][x] += sign * angle * falloff;
                        field.amplitude[y][x] += 0.3 * falloff;
                    }
                }
            }
        }
        
        function updateProbe(x, y) {
            if (x < 0 || x >= GRID_W || y < 0 || y >= GRID_H) return;
            
            const amp = field.amplitude[y][x];
            const phase = field.phase[y][x];
            const vel = field.velocity[y][x];
            const vort = field.vorticity[y][x];
            
            let phaseDeg = ((phase % (2 * Math.PI)) / (2 * Math.PI)) * 360;
            if (phaseDeg < 0) phaseDeg += 360;
            
            let state = 'stable';
            if (Math.abs(vort) > 0.5) state = vort > 0 ? 'vortex +' : 'vortex ‚àí';
            else if (Math.abs(vel) > 0.3) state = vel > 0 ? 'exhaling' : 'inhaling';
            else if (amp > 0.6) state = 'tensed';
            else if (amp < 0.15) state = 'relaxed';
            
            document.getElementById('probe-amp').textContent = amp.toFixed(4);
            document.getElementById('probe-phase').textContent = phaseDeg.toFixed(1) + '¬∞';
            document.getElementById('probe-vel').textContent = vel.toFixed(4);
            document.getElementById('probe-vort').textContent = vort.toFixed(4);
            document.getElementById('probe-state').textContent = state;
            document.getElementById('probe-coords').textContent = `[${x}, ${y}]`;
            
            document.getElementById('probe-panel').classList.add('active');
        }
        
        function animate() {
            if (running) {
                updateField();
            }
            render();
            computeMetrics();
            requestAnimationFrame(animate);
        }
        
        // Event listeners
        document.getElementById('breath-rate').addEventListener('input', e => {
            params.breathRate = parseFloat(e.target.value);
        });
        
        document.getElementById('coupling').addEventListener('input', e => {
            params.coupling = parseFloat(e.target.value);
        });
        
        document.getElementById('twist').addEventListener('input', e => {
            params.initialTwist = parseFloat(e.target.value);
        });
        
        document.getElementById('damping').addEventListener('input', e => {
            params.damping = parseFloat(e.target.value);
        });
        
        document.getElementById('color-theme').addEventListener('change', e => {
            currentTheme = e.target.value;
        });
        
        document.getElementById('grid-scale').addEventListener('change', e => {
            gridScale = parseInt(e.target.value);
            initField();
        });
        
        document.getElementById('zoom').addEventListener('input', e => {
            zoom = parseFloat(e.target.value);
            updateCanvasSize();
        });
        
        document.getElementById('record-btn').addEventListener('click', () => {
            recording = !recording;
            const btn = document.getElementById('record-btn');
            
            if (recording) {
                // Start new recording
                recordingData = {
                    startTime: new Date().toISOString(),
                    startTick: tick,
                    params: { ...params },
                    soundParams: { ...soundParams },
                    soundEnabled: soundEnabled,
                    gridScale: gridScale,
                    dimensions: { width: GRID_W, height: GRID_H },
                    events: [],
                    metrics: [],
                    snapshots: []
                };
                btn.textContent = '‚èπ Stop & Save';
                btn.classList.add('active');
                btn.style.background = 'rgba(239, 68, 68, 0.3)';
                btn.style.borderColor = '#ef4444';
                btn.style.color = '#ef4444';
                document.getElementById('recording-indicator').style.display = 'flex';
            } else {
                // Stop and download
                recordingData.endTime = new Date().toISOString();
                recordingData.endTick = tick;
                recordingData.duration = tick - recordingData.startTick;
                
                const blob = new Blob([JSON.stringify(recordingData)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `breath-session-${recordingData.startTick}-${tick}.json`;
                a.click();
                URL.revokeObjectURL(url);
                
                btn.textContent = '‚è∫ Record Session';
                btn.classList.remove('active');
                btn.style.background = '';
                btn.style.borderColor = '';
                btn.style.color = '';
                document.getElementById('recording-indicator').style.display = 'none';
            }
        });
        
        document.getElementById('pause-btn').addEventListener('click', e => {
            running = !running;
            e.target.textContent = running ? 'Pause' : 'Resume';
            e.target.classList.toggle('active', !running);
        });
        
        document.getElementById('reset-btn').addEventListener('click', initField);
        document.getElementById('perturb-btn').addEventListener('click', addPerturbation);
        document.getElementById('vortex-btn').addEventListener('click', seedVortex);
        document.getElementById('sound-btn').addEventListener('click', toggleSound);
        
        document.getElementById('export-btn').addEventListener('click', () => {
            const wasRunning = running;
            running = false;
            
            const data = {
                tick: tick,
                breathPhase: globalBreathPhase,
                breathTide: Math.sin(globalBreathPhase),
                params: { ...params },
                soundParams: { ...soundParams },
                soundEnabled: soundEnabled,
                currentTheme: currentTheme,
                gridScale: gridScale,
                zoom: zoom,
                dimensions: { width: GRID_W, height: GRID_H },
                // Full metrics history (flight recorder)
                history: metricsHistory.slice(),
                // Current field state
                amplitude: [],
                phase: [],
                velocity: [],
                vorticity: []
            };
            
            for (let y = 0; y < GRID_H; y++) {
                for (let x = 0; x < GRID_W; x++) {
                    data.amplitude.push(+field.amplitude[y][x].toFixed(4));
                    data.phase.push(+field.phase[y][x].toFixed(4));
                    data.velocity.push(+field.velocity[y][x].toFixed(4));
                    data.vorticity.push(+field.vorticity[y][x].toFixed(4));
                }
            }
            
            const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `breath-field-${tick}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            if (wasRunning) running = true;
        });
        
        // Sound control listeners
        document.getElementById('master-vol').addEventListener('input', e => {
            soundParams.master = e.target.value / 100;
            if (masterGain) masterGain.gain.value = soundParams.master * 0.3;
        });
        
        document.getElementById('thunder-vol').addEventListener('input', e => {
            soundParams.thunder = e.target.value / 100;
        });
        
        document.getElementById('foundation-vol').addEventListener('input', e => {
            soundParams.foundation = e.target.value / 100;
        });
        
        document.getElementById('sparkle-vol').addEventListener('input', e => {
            soundParams.sparkle = e.target.value / 100;
        });
        
        document.getElementById('sustain').addEventListener('input', e => {
            soundParams.sustain = e.target.value / 100;
        });
        
        document.querySelectorAll('.mode-btn').forEach(btn => {
            btn.addEventListener('click', e => {
                document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
                e.target.classList.add('active');
                vizMode = e.target.dataset.mode;
            });
        });
        
        canvas.addEventListener('click', e => {
            const rect = canvas.getBoundingClientRect();
            const cx = Math.floor((e.clientX - rect.left) / CELL_W);
            const cy = Math.floor((e.clientY - rect.top) / CELL_H);
            
            if (e.shiftKey) {
                const radius = 12 * gridScale;
                const strength = 2;
                
                for (let y = 0; y < GRID_H; y++) {
                    for (let x = 0; x < GRID_W; x++) {
                        const dx = x - cx;
                        const dy = y - cy;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        if (dist < radius) {
                            const falloff = Math.cos((dist / radius) * Math.PI / 2);
                            field.velocity[y][x] += strength * falloff;
                        }
                    }
                }
            }
            
            updateProbe(cx, cy);
        });
        
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            const cx = Math.floor((e.clientX - rect.left) / CELL_W);
            const cy = Math.floor((e.clientY - rect.top) / CELL_H);
            
            if (cx >= 0 && cx < GRID_W && cy >= 0 && cy < GRID_H) {
                updateProbe(cx, cy);
            }
        });
        
        canvas.addEventListener('mouseleave', () => {
            document.getElementById('probe-coords').textContent = 'Hover over field';
        });
        
        // Start
        initField();
        animate();
    </script>
</body>
</html>
