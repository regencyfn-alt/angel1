<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ANGEL-2 ¬∑ Triangular C2 Network</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Rajdhani:wght@300;400;500&display=swap');

* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #030508;
  color: #e0e6ed;
  font-family: 'Rajdhani', sans-serif;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

.canvas-area {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 20px;
}

#mesh-container {
  position: relative;
}

canvas {
  background: rgba(20, 30, 40, 0.5);
  border-radius: 8px;
  border: 1px solid rgba(106, 255, 216, 0.1);
}

/* Control Panel */
.control-panel {
  width: 300px;
  background: rgba(8, 16, 24, 0.95);
  border-left: 1px solid rgba(106, 255, 216, 0.2);
  padding: 20px;
  overflow-y: auto;
  max-height: calc(100vh - 60px);
  position: sticky;
  top: 60px;
}

.panel-title {
  font-family: 'Orbitron', monospace;
  font-size: 14px;
  color: #6affd8;
  letter-spacing: 2px;
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 1px solid rgba(106, 255, 216, 0.2);
}

.control-section {
  margin-bottom: 24px;
}

.section-title {
  font-size: 11px;
  color: #8a9bae;
  letter-spacing: 1px;
  text-transform: uppercase;
  margin-bottom: 12px;
}

.btn {
  width: 100%;
  padding: 12px 16px;
  background: linear-gradient(135deg, rgba(106, 255, 216, 0.15), rgba(106, 255, 216, 0.05));
  border: 1px solid rgba(106, 255, 216, 0.4);
  border-radius: 4px;
  color: #6affd8;
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  letter-spacing: 2px;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  margin-bottom: 8px;
}

.btn:hover {
  background: linear-gradient(135deg, rgba(106, 255, 216, 0.25), rgba(106, 255, 216, 0.1));
  box-shadow: 0 0 20px rgba(106, 255, 216, 0.3);
}

.btn.electron {
  border-color: rgba(100, 170, 255, 0.6);
  color: #6af;
  background: linear-gradient(135deg, rgba(100, 170, 255, 0.15), rgba(100, 170, 255, 0.05));
}

.btn.muon {
  border-color: rgba(100, 255, 140, 0.6);
  color: #6fa;
  background: linear-gradient(135deg, rgba(100, 255, 140, 0.15), rgba(100, 255, 140, 0.05));
}

.btn.tau {
  border-color: rgba(255, 100, 100, 0.6);
  color: #f66;
  background: linear-gradient(135deg, rgba(255, 100, 100, 0.15), rgba(255, 100, 100, 0.05));
}

.btn-row {
  display: flex;
  gap: 8px;
}

.btn-row .btn {
  flex: 1;
  padding: 10px 8px;
  font-size: 10px;
}

.shape-btn.active {
  background: linear-gradient(135deg, rgba(106, 255, 216, 0.4), rgba(106, 255, 216, 0.2));
  box-shadow: 0 0 15px rgba(106, 255, 216, 0.3);
}

.slider-container {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-bottom: 12px;
}

.slider-label {
  font-size: 11px;
  color: #8a9bae;
  min-width: 80px;
}

.slider {
  flex: 1;
  -webkit-appearance: none;
  height: 4px;
  background: rgba(106, 255, 216, 0.2);
  border-radius: 2px;
  outline: none;
}

.slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  background: #6affd8;
  border-radius: 50%;
  cursor: pointer;
}

.slider-value {
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  color: #6affd8;
  min-width: 35px;
  text-align: right;
}

.metrics {
  background: rgba(0, 0, 0, 0.3);
  border-radius: 6px;
  padding: 12px;
}

.metric-row {
  display: flex;
  justify-content: space-between;
  padding: 6px 0;
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}

.metric-row:last-child { border-bottom: none; }

.metric-label { font-size: 11px; color: #8a9bae; }

.metric-value {
  font-family: 'Orbitron', monospace;
  font-size: 12px;
  color: #fff;
}

.metric-value.red { color: #ff6666; }
.metric-value.green { color: #66ff99; }
.metric-value.blue { color: #66aaff; }

.legend {
  display: flex;
  flex-direction: column;
  gap: 8px;
  margin-top: 12px;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 11px;
  color: #8a9bae;
}

.legend-dot {
  width: 12px;
  height: 12px;
  border-radius: 3px;
}

.legend-dot.red { background: rgba(255, 80, 80, 0.6); border: 1px solid #f66; }
.legend-dot.green { background: rgba(80, 255, 120, 0.6); border: 1px solid #6f8; }
.legend-dot.blue { background: rgba(80, 150, 255, 0.6); border: 1px solid #6af; }
.legend-dot.gray { background: rgba(100, 110, 120, 0.6); border: 1px solid #888; }



.event-log {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  pointer-events: none;
  z-index: 100;
}

.event-msg {
  background: rgba(8, 16, 24, 0.9);
  border: 1px solid rgba(106, 255, 216, 0.3);
  border-radius: 4px;
  padding: 8px 16px;
  font-family: 'Orbitron', monospace;
  font-size: 11px;
  color: #6affd8;
  animation: fadeOut 3s ease forwards;
}

@keyframes fadeOut {
  0% { opacity: 0; transform: translateY(10px); }
  10% { opacity: 1; transform: translateY(0); }
  80% { opacity: 1; }
  100% { opacity: 0; }
}

/* Navigation */
.nav {
  background: linear-gradient(135deg, #1a1f2e 0%, #0f1620 100%);
  border-bottom: 2px solid rgba(106, 255, 216, 0.2);
  padding: 12px 20px;
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-shrink: 0;
}

.nav-brand {
  font-family: 'Orbitron', monospace;
  font-size: 16px;
  font-weight: 700;
  color: #6affd8;
}

.nav-links {
  display: flex;
  gap: 6px;
}

.nav-links a {
  padding: 6px 12px;
  border-radius: 4px;
  text-decoration: none;
  color: #8a9bae;
  font-size: 12px;
  font-weight: 500;
  transition: all 0.2s;
  border: 1px solid transparent;
}

.nav-links a:hover {
  color: #6affd8;
  background: rgba(106, 255, 216, 0.1);
}

.nav-links a.active {
  color: #6affd8;
  background: rgba(106, 255, 216, 0.15);
  border-color: rgba(106, 255, 216, 0.4);
}

.main-content {
  display: flex;
  flex: 1;
  overflow: hidden;
}

</style>
  <link rel="stylesheet" href="shared.css">
</head>
<body>

<nav class="nav">
  <div class="nav-brand">MICHRON PHYSICS</div>
  <div class="nav-links">
    <a href="index.html">Classic</a>
    <a href="torsion-field.html">Torsion Field</a>
    <a href="breath-field.html">Breath Field</a>
    <a href="chronos.html">Chronos</a>
    <a href="square_plaquettes.html">Square Flip</a>
    <a href="angel2_triangular.html" class="active">Tri-Flip</a>
    <a href="orchestra.html">Orchestra</a>
  </div>
</nav>

<div class="main-content">
<div class="canvas-area">
  <div id="mesh-container">
    <canvas id="meshCanvas" width="800" height="700"></canvas>
  </div>
</div>


<div class="control-panel">
  <div class="panel-title">NETWORK CONTROLS</div>
  
  <div class="control-section">
    <div class="section-title">Launch Neutrino</div>
    <button class="btn electron" id="launchElectron">e‚Åª ELECTRON (~0.45 eV)</button>
    <button class="btn muon" id="launchMuon">Œº MUON (Bootstrap)</button>
    <button class="btn tau" id="launchTau">œÑ TAU (Bomb)</button>
  </div>
  
  <div class="control-section">
    <div class="section-title">Mesh Size & Shape</div>
    <div class="slider-container">
      <span class="slider-label">Rings</span>
      <input type="range" class="slider" id="ringsSlider" min="2" max="8" step="1" value="4">
      <span class="slider-value" id="ringsValue">4</span>
    </div>
    <div class="btn-row">
      <button class="btn shape-btn active" id="shapeHex">HEX</button>
      <button class="btn shape-btn" id="shapeOct">OCT</button>
      <button class="btn shape-btn" id="shapeRect">RECT</button>
    </div>
    <button class="btn" id="rebuildBtn">Rebuild Mesh</button>
    <button class="btn" id="carveAllBtn">Carve All</button>
  </div>
  
  <div class="control-section">
    <div class="section-title">Simulation</div>
    <div class="slider-container">
      <span class="slider-label">Speed</span>
      <input type="range" class="slider" id="speedSlider" min="0.2" max="2" step="0.1" value="1">
      <span class="slider-value" id="speedValue">1.0x</span>
    </div>
    <button class="btn" id="resetBtn">Reset Network</button>
    <button class="btn" id="allGreenBtn">Set All Green</button>
    <button class="btn" id="pauseBtn">Pause</button>
    <button class="btn" id="carveModeBtn">Carve Mode: OFF</button>
    <button class="btn" id="buildModeBtn">Build Mode: OFF</button>
    <button class="btn" id="isolationDecayBtn">Isolation Decay: OFF</button>
  </div>
  
  <div class="control-section">
    <div class="section-title">Network State</div>
    <div class="metrics">
      <div class="metric-row">
        <span class="metric-label">Triangles</span>
        <span class="metric-value" id="totalCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Active</span>
        <span class="metric-value" id="activeCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">State 1 (Red)</span>
        <span class="metric-value red" id="redCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">State 2 (Green)</span>
        <span class="metric-value green" id="greenCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">State 3 (Blue)</span>
        <span class="metric-value blue" id="blueCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Contacts</span>
        <span class="metric-value" id="contactCount">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Status</span>
        <span class="metric-value" id="statusValue">DORMANT</span>
      </div>
    </div>
    
    <div class="legend">
      <div class="legend-item">
        <div class="legend-dot gray"></div>
        <span>Dormant ‚Äî Inert node</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot red"></div>
        <span>State 1 ‚Äî Contracted (virtual C3)</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot green"></div>
        <span>State 2 ‚Äî Equilibrium (true C2)</span>
      </div>
      <div class="legend-item">
        <div class="legend-dot blue"></div>
        <span>State 3 ‚Äî Expanded (virtual C1)</span>
      </div>
    </div>
  </div>
  
  <div class="control-section">
    <div class="section-title">Recording</div>
    <button class="btn" id="recordBtn">‚è∫ Record</button>
    <button class="btn" id="playBtn" disabled>‚ñ∂ Play</button>
    <button class="btn" id="stopPlaybackBtn" disabled>‚èπ Stop</button>
    <div class="btn-row">
      <button class="btn" id="exportBtn" disabled>üíæ Export</button>
      <button class="btn" id="importBtn">üìÇ Import</button>
    </div>
    <input type="file" id="importFile" accept=".json" style="display:none">
    <div class="metric-row" style="margin-top:8px">
      <span class="metric-label">Frames</span>
      <span class="metric-value" id="frameCount">0</span>
    </div>
    <div class="metric-row">
      <span class="metric-label">Status</span>
      <span class="metric-value" id="recorderStatus">IDLE</span>
    </div>
  </div>
</div>

<div class="event-log" id="eventLog"></div>

<script>
// ============================================================================
// ANGEL-2: TRIANGULAR C2 NETWORK
// 3-neighbor topology - no contradictory 4-way instructions
// Each triangular face is a pane/plaquette with exactly 3 neighbors
// ============================================================================

const canvas = document.getElementById('meshCanvas');
const ctx = canvas.getContext('2d');

// === STATES ===
const DORMANT = 0;
const STATE_1 = 1;  // Red - contracted
const STATE_2 = 2;  // Green - equilibrium
const STATE_3 = 3;  // Blue - expanded

// === COLORS ===
const COLORS = {
  [DORMANT]: { fill: 'rgba(60, 70, 80, 0.4)', stroke: 'rgba(100, 110, 120, 0.5)' },
  [STATE_1]: { fill: 'rgba(255, 80, 80, 0.5)', stroke: 'rgba(255, 100, 100, 0.8)' },
  [STATE_2]: { fill: 'rgba(80, 255, 120, 0.5)', stroke: 'rgba(100, 255, 140, 0.8)' },
  [STATE_3]: { fill: 'rgba(80, 150, 255, 0.5)', stroke: 'rgba(100, 170, 255, 0.8)' }
};

// === SIMULATION STATE ===
let triangles = [];
let nodes = [];
let numRings = 4;
let meshShape = 'hex'; // 'hex', 'oct', 'rect'
let carveMode = false;
let buildMode = false;
let isolationDecay = false;
let speedMultiplier = 1;
let paused = false;
let contactCount = 0;
let tickTimer = null;

// === RECORDER STATE ===
let recorder = {
  frames: [],
  recording: false,
  playing: false,
  playIndex: 0,
  playbackTimer: null,
  tickCount: 0
};

// Neutrino trail system
let neutrinos = []; // Active neutrino particles
const NEUTRINO_COLORS = {
  electron: { main: '#6af', trail: 'rgba(100, 170, 255, 0.6)' },
  muon: { main: '#6fa', trail: 'rgba(100, 255, 140, 0.6)' },
  tau: { main: '#f66', trail: 'rgba(255, 100, 100, 0.6)' }
};

const TICK_INTERVAL = 150;
const CENTER_X = canvas.width / 2;
const CENTER_Y = canvas.height / 2;
const TRI_SIZE = 45;

// === TRIANGLE OBJECT ===
function createTriangle(id, vertices, centroid) {
  return {
    id,
    vertices,      // Array of 3 vertex indices
    centroid,      // {x, y} center point
    neighbors: [], // Array of neighbor triangle ids (max 3)
    state: DORMANT,
    polarity: Math.random() > 0.5 ? 1 : -1,
    phase: 0,
    skipping: false,
    skipCount: 0,
    pointsUp: false // orientation
  };
}

// === BUILD TRIANGULAR MESH ===
function buildMesh() {
  triangles = [];
  nodes = [];
  
  const triHeight = TRI_SIZE * Math.sqrt(3) / 2;
  const halfSize = TRI_SIZE / 2;
  const rows = numRings * 2;
  const cols = numRings * 2;
  
  // Grid to store triangle references for neighbor lookup
  const grid = [];
  
  let triId = 0;
  
  for (let row = 0; row < rows; row++) {
    grid[row] = [];
    const baseY = CENTER_Y - (rows / 2 * triHeight) + (row * triHeight);
    
    for (let col = 0; col < cols; col++) {
      const baseX = CENTER_X - (cols / 2 * halfSize) + (col * halfSize);
      
      // Each grid cell has an up-pointing and down-pointing triangle
      // But we alternate based on row+col parity
      const pointsUp = (row + col) % 2 === 0;
      
      let v1, v2, v3;
      if (pointsUp) {
        v1 = { x: baseX + halfSize, y: baseY };                  // top
        v2 = { x: baseX, y: baseY + triHeight };                 // bottom-left
        v3 = { x: baseX + TRI_SIZE, y: baseY + triHeight };      // bottom-right
      } else {
        v1 = { x: baseX + halfSize, y: baseY + triHeight };      // bottom
        v2 = { x: baseX, y: baseY };                              // top-left
        v3 = { x: baseX + TRI_SIZE, y: baseY };                   // top-right
      }
      
      const centroid = {
        x: (v1.x + v2.x + v3.x) / 3,
        y: (v1.y + v2.y + v3.y) / 3
      };
      
      const tri = createTriangle(triId, [v1, v2, v3], centroid);
      tri.pointsUp = pointsUp;
      tri.row = row;
      tri.col = col;
      triangles.push(tri);
      grid[row][col] = tri;
      triId++;
    }
  }
  
  // Set neighbors based on grid position
  // Each triangle has up to 3 neighbors depending on orientation
  for (let row = 0; row < rows; row++) {
    for (let col = 0; col < cols; col++) {
      const tri = grid[row][col];
      const neighbors = [];
      
      // Left neighbor (same row, col-1)
      if (col > 0) {
        neighbors.push(grid[row][col - 1].id);
      }
      
      // Right neighbor (same row, col+1)
      if (col < cols - 1) {
        neighbors.push(grid[row][col + 1].id);
      }
      
      // Third neighbor depends on orientation
      if (tri.pointsUp) {
        // Up-pointing: neighbor is above (row-1, same col if parity matches)
        if (row > 0) {
          neighbors.push(grid[row - 1][col].id);
        }
      } else {
        // Down-pointing: neighbor is below (row+1, same col if parity matches)
        if (row < rows - 1) {
          neighbors.push(grid[row + 1][col].id);
        }
      }
      
      tri.neighbors = neighbors;
    }
  }
  
  // Trim to selected shape
  const maxDist = numRings * triHeight * 0.9;
  const keepTriangles = triangles.filter(t => {
    const dx = t.centroid.x - CENTER_X;
    const dy = t.centroid.y - CENTER_Y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (meshShape === 'hex') {
      // Circular/hexagonal clip
      return dist < maxDist;
    } else if (meshShape === 'oct') {
      // Octagonal clip - cut corners of square
      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      const cornerCut = maxDist * 0.4;
      return absX < maxDist && absY < maxDist && (absX + absY) < maxDist * 1.4;
    } else if (meshShape === 'rect') {
      // Rectangular clip
      return Math.abs(dx) < maxDist * 1.2 && Math.abs(dy) < maxDist * 0.8;
    }
    return dist < maxDist;
  });
  
  // Rebuild with new IDs
  const idMap = new Map();
  keepTriangles.forEach((t, newIdx) => idMap.set(t.id, newIdx));
  
  triangles = keepTriangles.map((t, newIdx) => {
    t.id = newIdx;
    t.neighbors = t.neighbors
      .filter(nId => idMap.has(nId))
      .map(nId => idMap.get(nId));
    t._originalNeighbors = [...t.neighbors]; // Store for restoration
    t._removed = false;
    return t;
  });
  
  updateMetrics();
  render();
}

function sharesEdge(t1, t2) {
  // Check if two triangles share exactly 2 vertices (within tolerance)
  const tolerance = 2;
  let sharedCount = 0;
  
  for (const v1 of t1.vertices) {
    for (const v2 of t2.vertices) {
      const dx = v1.x - v2.x;
      const dy = v1.y - v2.y;
      if (Math.sqrt(dx*dx + dy*dy) < tolerance) {
        sharedCount++;
        break;
      }
    }
  }
  
  return sharedCount >= 2;
}

// === RENDERING ===
function render() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  // Draw triangles
  triangles.forEach(tri => {
    // Show removed triangles as visible ghosts (for restoration)
    if (tri._removed) {
      ctx.beginPath();
      ctx.moveTo(tri.vertices[0].x, tri.vertices[0].y);
      ctx.lineTo(tri.vertices[1].x, tri.vertices[1].y);
      ctx.lineTo(tri.vertices[2].x, tri.vertices[2].y);
      ctx.closePath();
      ctx.fillStyle = 'rgba(40, 50, 60, 0.5)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(100, 120, 140, 0.6)';
      ctx.lineWidth = 1;
      ctx.stroke();
      return;
    }
    
    const colors = COLORS[tri.state];
    
    ctx.beginPath();
    ctx.moveTo(tri.vertices[0].x, tri.vertices[0].y);
    ctx.lineTo(tri.vertices[1].x, tri.vertices[1].y);
    ctx.lineTo(tri.vertices[2].x, tri.vertices[2].y);
    ctx.closePath();
    
    // Muon flash effect
    if (tri._muonFlash) {
      ctx.fillStyle = 'rgba(100, 255, 140, 0.8)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(150, 255, 180, 1)';
      ctx.lineWidth = 4;
      ctx.stroke();
      
      // Draw glow
      ctx.shadowColor = 'rgba(100, 255, 140, 0.8)';
      ctx.shadowBlur = 20;
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else if (tri._tauFlash) {
      ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(255, 150, 150, 1)';
      ctx.lineWidth = 4;
      ctx.stroke();
      
      // Draw glow
      ctx.shadowColor = 'rgba(255, 100, 100, 0.8)';
      ctx.shadowBlur = 20;
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else if (tri._flash) {
      // Electron speed channel flash
      ctx.fillStyle = 'rgba(100, 170, 255, 0.6)';
      ctx.fill();
      ctx.strokeStyle = 'rgba(150, 200, 255, 1)';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      ctx.shadowColor = 'rgba(100, 170, 255, 0.8)';
      ctx.shadowBlur = 15;
      ctx.stroke();
      ctx.shadowBlur = 0;
    } else {
      ctx.fillStyle = colors.fill;
      ctx.fill();
      
      ctx.strokeStyle = colors.stroke;
      ctx.lineWidth = tri.state === DORMANT ? 1 : 2;
      ctx.stroke();
    }
    
    // Draw polarity indicator for active triangles
    if (tri.state !== DORMANT) {
      drawPolarityIndicator(tri);
    }
    
    // Draw skip indicator
    if (tri.skipping) {
      ctx.fillStyle = 'rgba(255, 200, 100, 0.8)';
      ctx.beginPath();
      ctx.arc(tri.centroid.x + 10, tri.centroid.y - 10, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  });
  
  // Draw node points at vertices (only for active triangles)
  const drawnNodes = new Set();
  triangles.forEach(tri => {
    if (tri._removed) return;
    tri.vertices.forEach(v => {
      const key = `${Math.round(v.x)},${Math.round(v.y)}`;
      if (!drawnNodes.has(key)) {
        drawnNodes.add(key);
        ctx.fillStyle = 'rgba(200, 200, 100, 0.8)';
        ctx.beginPath();
        ctx.arc(v.x, v.y, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    });
  });
  
  // Draw neutrino particles and trails
  neutrinos.forEach(neutrino => {
    const colors = NEUTRINO_COLORS[neutrino.type];
    
    // Draw trail
    if (neutrino.trail.length > 1) {
      ctx.beginPath();
      ctx.moveTo(neutrino.trail[0].x, neutrino.trail[0].y);
      for (let i = 1; i < neutrino.trail.length; i++) {
        ctx.lineTo(neutrino.trail[i].x, neutrino.trail[i].y);
      }
      ctx.strokeStyle = colors.trail;
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.stroke();
      
      // Glow effect
      ctx.shadowColor = colors.main;
      ctx.shadowBlur = 10;
      ctx.stroke();
      ctx.shadowBlur = 0;
    }
    
    // Draw particle head
    if (neutrino.active) {
      ctx.beginPath();
      ctx.arc(neutrino.x, neutrino.y, 6, 0, Math.PI * 2);
      ctx.fillStyle = colors.main;
      ctx.fill();
      
      // Bright core
      ctx.beginPath();
      ctx.arc(neutrino.x, neutrino.y, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();
      
      // Glow
      ctx.shadowColor = colors.main;
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(neutrino.x, neutrino.y, 6, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
  });
}

function drawPolarityIndicator(tri) {
  const cx = tri.centroid.x;
  const cy = tri.centroid.y;
  const size = 8;
  
  ctx.save();
  ctx.translate(cx, cy);
  
  // Rotate based on phase
  const rotation = (tri.phase / 3) * Math.PI * 2;
  ctx.rotate(rotation);
  
  // Draw direction arrow based on polarity
  ctx.strokeStyle = tri.polarity === 1 ? 'rgba(255,255,255,0.7)' : 'rgba(255,255,255,0.4)';
  ctx.lineWidth = 2;
  
  ctx.beginPath();
  if (tri.polarity === 1) {
    // Clockwise arrow
    ctx.moveTo(-size, 0);
    ctx.lineTo(size, 0);
    ctx.lineTo(size - 4, -4);
    ctx.moveTo(size, 0);
    ctx.lineTo(size - 4, 4);
  } else {
    // Counter-clockwise arrow
    ctx.moveTo(size, 0);
    ctx.lineTo(-size, 0);
    ctx.lineTo(-size + 4, -4);
    ctx.moveTo(-size, 0);
    ctx.lineTo(-size + 4, 4);
  }
  ctx.stroke();
  
  ctx.restore();
}

// === SIMULATION ===
function tick() {
  if (paused) return;
  
  // Process each active triangle
  triangles.forEach(tri => {
    if (tri.state === DORMANT || tri._removed) return;
    
    // Check for isolation decay
    if (isolationDecay) {
      const activeNeighbors = tri.neighbors
        .map(nId => triangles[nId])
        .filter(n => n && !n._removed && n.state !== DORMANT);
      
      if (activeNeighbors.length === 0) {
        // Isolated - start decay countdown
        tri._isolationCount = (tri._isolationCount || 0) + 1;
        
        if (tri._isolationCount >= 3 && tri.state !== STATE_2) {
          // After 3 ticks, go to green
          tri.state = STATE_2;
          tri.phase = 1;
        } else if (tri._isolationCount >= 5) {
          // After 5 ticks total, go dormant
          tri.state = DORMANT;
          tri.phase = 0;
          tri._isolationCount = 0;
        }
        return; // Don't process normally
      } else {
        // Has neighbors - reset isolation count
        tri._isolationCount = 0;
      }
    }
    
    if (shouldSkip(tri)) {
      tri.skipping = true;
      tri.skipCount++;
      if (tri.skipCount > 2) {
        tri.skipping = false;
        tri.skipCount = 0;
      }
    } else {
      tri.skipping = false;
      tri.skipCount = 0;
      
      advancePhase(tri);
      
      if (tri.state === STATE_3) {
        checkContacts(tri);
      }
    }
  });
  
  updateMetrics();
  render();
}

function shouldSkip(tri) {
  const activeNeighbors = tri.neighbors
    .map(nId => triangles[nId])
    .filter(n => n && !n._removed && n.state !== DORMANT);
  
  if (activeNeighbors.length === 0) return false;
  
  const allSame = activeNeighbors.every(n => n.state === tri.state);
  return allSame && tri.state === STATE_1;
}

function advancePhase(tri) {
  tri.phase = (tri.phase + 1) % 3;
  
  if (tri.phase === 0) tri.state = STATE_1;
  else if (tri.phase === 1) tri.state = STATE_2;
  else tri.state = STATE_3;
}

function checkContacts(tri) {
  tri.neighbors.forEach(nId => {
    const neighbor = triangles[nId];
    if (neighbor && !neighbor._removed) {
      handleContact(tri, neighbor);
    }
  });
}

function handleContact(t1, t2) {
  if (t2._removed) return;
  
  if (t2.state === DORMANT) {
    // Bootstrap spread
    t2.state = STATE_2;
    t2.phase = 1;
    t1.state = STATE_2;
    t1.phase = 1;
    flipPolarity(t1);
    flipPolarity(t2);
    contactCount++;
    logEvent('BOOTSTRAP SPREAD', 'muon');
    return;
  }
  
  contactCount++;
  flipPolarity(t1);
  flipPolarity(t2);
  
  if (t1.state !== t2.state) {
    if (t1.state === STATE_3 && t2.state === STATE_1) {
      t1.state = STATE_2;
      t1.phase = 1;
      t2.state = STATE_2;
      t2.phase = 1;
    } else if (t1.state === STATE_3 && t2.state === STATE_2) {
      t1.state = STATE_2;
      t1.phase = 1;
      t2.state = STATE_3;
      t2.phase = 2;
    }
  }
}

function flipPolarity(tri) {
  tri.polarity *= -1;
}

// === NEUTRINO LAUNCHES ===
function launchElectron() {
  logEvent('e‚Åª NEUTRINO (0.45 eV) ‚Äî Speed channel only', 'electron');
  
  // Create visible neutrino particle
  const startY = CENTER_Y;
  const startX = CENTER_X - 300;
  const endX = CENTER_X + 300;
  
  const neutrino = {
    type: 'electron',
    x: startX,
    y: startY,
    targetX: endX,
    targetY: startY,
    trail: [{x: startX, y: startY, age: 0}],
    speed: 8,
    active: true
  };
  neutrinos.push(neutrino);
  
  // Flash triangles as neutrino passes
  const centerTris = triangles.filter(t => 
    !t._removed && Math.abs(t.centroid.y - CENTER_Y) < TRI_SIZE
  ).sort((a, b) => a.centroid.x - b.centroid.x);
  
  animateNeutrino(neutrino, () => {
    // Electron just passes through - no activation
  }, centerTris);
}

function launchMuon() {
  logEvent('Œº NEUTRINO ‚Äî Bootstrap sequence', 'muon');
  
  // Find a dormant triangle on the edge
  const dormant = triangles.filter(t => t.state === DORMANT && !t._removed);
  if (dormant.length === 0) {
    logEvent('No dormant triangles', 'muon');
    return;
  }
  
  // Prefer edge triangles
  const edges = dormant.filter(t => t.neighbors.length < 3);
  const target = edges.length > 0 
    ? edges[Math.floor(Math.random() * edges.length)]
    : dormant[Math.floor(Math.random() * dormant.length)];
  
  // Create neutrino traveling to target
  const angle = Math.random() * Math.PI * 2;
  const startX = target.centroid.x + Math.cos(angle) * 200;
  const startY = target.centroid.y + Math.sin(angle) * 200;
  
  const neutrino = {
    type: 'muon',
    x: startX,
    y: startY,
    targetX: target.centroid.x,
    targetY: target.centroid.y,
    trail: [{x: startX, y: startY, age: 0}],
    speed: 6,
    active: true,
    targetTri: target
  };
  neutrinos.push(neutrino);
  
  animateNeutrino(neutrino, () => {
    target.state = STATE_2;
    target.phase = 1;
    target._muonFlash = true;
    render();
    setTimeout(() => {
      target._muonFlash = false;
      render();
    }, 500);
    logEvent(`Bootstrap at triangle ${target.id}`, 'muon');
  });
}

function launchTau() {
  logEvent('œÑ NEUTRINO ‚Äî BOMB', 'tau');
  
  // Find center triangle
  let centerTri = triangles.filter(t => !t._removed)[0];
  let minDist = Infinity;
  
  triangles.forEach(tri => {
    if (tri._removed) return;
    const dx = tri.centroid.x - CENTER_X;
    const dy = tri.centroid.y - CENTER_Y;
    const dist = dx*dx + dy*dy;
    if (dist < minDist) {
      minDist = dist;
      centerTri = tri;
    }
  });
  
  // Create neutrino traveling to center from above
  const startX = centerTri.centroid.x + (Math.random() - 0.5) * 100;
  const startY = centerTri.centroid.y - 250;
  
  const neutrino = {
    type: 'tau',
    x: startX,
    y: startY,
    targetX: centerTri.centroid.x,
    targetY: centerTri.centroid.y,
    trail: [{x: startX, y: startY, age: 0}],
    speed: 12,
    active: true,
    targetTri: centerTri
  };
  neutrinos.push(neutrino);
  
  animateNeutrino(neutrino, () => {
    // Activate center with flash
    centerTri.state = STATE_3;
    centerTri.phase = 2;
    centerTri._tauFlash = true;
    
    // Shockwave
    triangles.forEach(tri => {
      if (tri._removed) return;
      const dx = tri.centroid.x - centerTri.centroid.x;
      const dy = tri.centroid.y - centerTri.centroid.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      
      setTimeout(() => {
        tri.state = STATE_3;
        tri.phase = 2;
        tri._tauFlash = true;
        render();
        
        setTimeout(() => {
          tri._tauFlash = false;
        }, 150);
      }, dist * 3);
    });
    
    setTimeout(() => {
      centerTri._tauFlash = false;
    }, 150);
  });
}

function animateNeutrino(neutrino, onComplete, flashTris) {
  const animate = () => {
    if (!neutrino.active) return;
    
    const dx = neutrino.targetX - neutrino.x;
    const dy = neutrino.targetY - neutrino.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    
    if (dist < neutrino.speed) {
      neutrino.x = neutrino.targetX;
      neutrino.y = neutrino.targetY;
      neutrino.active = false;
      onComplete();
      
      // Fade out trail
      setTimeout(() => {
        const idx = neutrinos.indexOf(neutrino);
        if (idx > -1) neutrinos.splice(idx, 1);
      }, 1000);
      return;
    }
    
    // Move toward target
    neutrino.x += (dx / dist) * neutrino.speed;
    neutrino.y += (dy / dist) * neutrino.speed;
    
    // Add to trail
    neutrino.trail.push({x: neutrino.x, y: neutrino.y, age: 0});
    
    // Age trail points
    neutrino.trail.forEach(p => p.age++);
    neutrino.trail = neutrino.trail.filter(p => p.age < 40);
    
    // Flash triangles electron passes through
    if (flashTris && neutrino.type === 'electron') {
      flashTris.forEach(tri => {
        const tdx = tri.centroid.x - neutrino.x;
        if (Math.abs(tdx) < 20 && !tri._flash) {
          tri._flash = true;
          setTimeout(() => { tri._flash = false; }, 150);
        }
      });
    }
    
    render();
    requestAnimationFrame(animate);
  };
  
  requestAnimationFrame(animate);
}

// === UI ===
function updateMetrics() {
  let total = 0, active = 0, reds = 0, greens = 0, blues = 0;
  
  triangles.forEach(tri => {
    if (tri._removed) return;
    total++;
    if (tri.state !== DORMANT) {
      active++;
      if (tri.state === STATE_1) reds++;
      else if (tri.state === STATE_2) greens++;
      else if (tri.state === STATE_3) blues++;
    }
  });
  
  document.getElementById('totalCount').textContent = total;
  document.getElementById('activeCount').textContent = active;
  document.getElementById('redCount').textContent = reds;
  document.getElementById('greenCount').textContent = greens;
  document.getElementById('blueCount').textContent = blues;
  document.getElementById('contactCount').textContent = contactCount;
  
  const statusEl = document.getElementById('statusValue');
  if (active === 0) {
    statusEl.textContent = 'DORMANT';
    statusEl.style.color = '#8a9bae';
  } else if (greens === active && active === total) {
    statusEl.textContent = 'EQUILIBRIUM';
    statusEl.style.color = '#66ff99';
  } else {
    statusEl.textContent = 'OSCILLATING';
    statusEl.style.color = '#ffb46a';
  }
}

function logEvent(msg, type = '') {
  const log = document.getElementById('eventLog');
  const div = document.createElement('div');
  div.className = 'event-msg';
  div.textContent = msg;
  log.appendChild(div);
  setTimeout(() => div.remove(), 3000);
}

function resetNetwork() {
  triangles.forEach(tri => {
    tri.state = DORMANT;
    tri.phase = 0;
    tri.polarity = Math.random() > 0.5 ? 1 : -1;
    tri.skipping = false;
    tri.skipCount = 0;
  });
  contactCount = 0;
  updateMetrics();
  render();
  logEvent('NETWORK RESET');
}

function startSimulation() {
  if (tickTimer) clearInterval(tickTimer);
  tickTimer = setInterval(tick, TICK_INTERVAL / speedMultiplier);
}

// === EVENT LISTENERS ===
document.getElementById('launchElectron').addEventListener('click', launchElectron);
document.getElementById('launchMuon').addEventListener('click', launchMuon);
document.getElementById('launchTau').addEventListener('click', launchTau);
document.getElementById('resetBtn').addEventListener('click', resetNetwork);

document.getElementById('allGreenBtn').addEventListener('click', () => {
  triangles.forEach(tri => {
    if (tri._removed) return;
    tri.state = STATE_2;
    tri.phase = 1;
    tri.polarity = Math.random() > 0.5 ? 1 : -1;
    tri.skipping = false;
    tri.skipCount = 0;
  });
  contactCount = 0;
  updateMetrics();
  render();
  logEvent('ALL GREEN ‚Äî Equilibrium state');
});

document.getElementById('pauseBtn').addEventListener('click', () => {
  paused = !paused;
  document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
});

document.getElementById('carveModeBtn').addEventListener('click', () => {
  carveMode = !carveMode;
  if (carveMode) buildMode = false; // Mutually exclusive
  document.getElementById('carveModeBtn').textContent = `Carve Mode: ${carveMode ? 'ON' : 'OFF'}`;
  document.getElementById('buildModeBtn').textContent = `Build Mode: ${buildMode ? 'ON' : 'OFF'}`;
  if (carveMode) {
    document.getElementById('carveModeBtn').style.borderColor = 'rgba(255, 100, 100, 0.8)';
    document.getElementById('carveModeBtn').style.color = '#f88';
  } else {
    document.getElementById('carveModeBtn').style.borderColor = '';
    document.getElementById('carveModeBtn').style.color = '';
  }
  document.getElementById('buildModeBtn').style.borderColor = '';
  document.getElementById('buildModeBtn').style.color = '';
});

document.getElementById('buildModeBtn').addEventListener('click', () => {
  buildMode = !buildMode;
  if (buildMode) carveMode = false; // Mutually exclusive
  document.getElementById('buildModeBtn').textContent = `Build Mode: ${buildMode ? 'ON' : 'OFF'}`;
  document.getElementById('carveModeBtn').textContent = `Carve Mode: ${carveMode ? 'ON' : 'OFF'}`;
  if (buildMode) {
    document.getElementById('buildModeBtn').style.borderColor = 'rgba(100, 255, 140, 0.8)';
    document.getElementById('buildModeBtn').style.color = '#8f8';
  } else {
    document.getElementById('buildModeBtn').style.borderColor = '';
    document.getElementById('buildModeBtn').style.color = '';
  }
  document.getElementById('carveModeBtn').style.borderColor = '';
  document.getElementById('carveModeBtn').style.color = '';
});

document.getElementById('isolationDecayBtn').addEventListener('click', () => {
  isolationDecay = !isolationDecay;
  document.getElementById('isolationDecayBtn').textContent = `Isolation Decay: ${isolationDecay ? 'ON' : 'OFF'}`;
  if (isolationDecay) {
    document.getElementById('isolationDecayBtn').style.borderColor = 'rgba(255, 200, 100, 0.8)';
    document.getElementById('isolationDecayBtn').style.color = '#fc8';
  } else {
    document.getElementById('isolationDecayBtn').style.borderColor = '';
    document.getElementById('isolationDecayBtn').style.color = '';
  }
});

document.getElementById('rebuildBtn').addEventListener('click', () => {
  numRings = parseInt(document.getElementById('ringsSlider').value);
  contactCount = 0;
  buildMesh();
});

document.getElementById('carveAllBtn').addEventListener('click', () => {
  triangles.forEach(tri => {
    tri._removed = true;
    tri.state = DORMANT;
  });
  updateMetrics();
  render();
  logEvent('Carved all triangles ‚Äî use Build Mode to create shape');
});

// Shape buttons
document.querySelectorAll('.shape-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    if (btn.id === 'shapeHex') meshShape = 'hex';
    else if (btn.id === 'shapeOct') meshShape = 'oct';
    else if (btn.id === 'shapeRect') meshShape = 'rect';
    contactCount = 0;
    buildMesh();
  });
});

document.getElementById('ringsSlider').addEventListener('input', (e) => {
  document.getElementById('ringsValue').textContent = e.target.value;
});

document.getElementById('speedSlider').addEventListener('input', (e) => {
  speedMultiplier = parseFloat(e.target.value);
  document.getElementById('speedValue').textContent = `${speedMultiplier.toFixed(1)}x`;
  startSimulation();
});

// Keyboard shortcuts
document.addEventListener('keydown', (e) => {
  if (e.code === 'KeyE') launchElectron();
  else if (e.code === 'KeyM') launchMuon();
  else if (e.code === 'KeyT') launchTau();
  else if (e.code === 'KeyR') resetNetwork();
  else if (e.code === 'Space') {
    e.preventDefault();
    paused = !paused;
    document.getElementById('pauseBtn').textContent = paused ? 'Resume' : 'Pause';
  }
});

// Click to cycle state, carve, or build
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // Find clicked triangle
  for (let i = 0; i < triangles.length; i++) {
    const tri = triangles[i];
    
    if (pointInTriangle(x, y, tri.vertices)) {
      if (carveMode) {
        if (tri._removed) continue;
        // Remove triangle from mesh
        tri._removed = true;
        // Update neighbors to remove reference to this triangle
        tri.neighbors.forEach(nId => {
          const neighbor = triangles[nId];
          if (neighbor) {
            neighbor.neighbors = neighbor.neighbors.filter(id => id !== tri.id);
          }
        });
        logEvent(`Carved triangle ${tri.id}`, '');
      } else if (buildMode) {
        // Build mode: restore if removed, or activate to green if dormant
        if (tri._removed) {
          tri._removed = false;
          tri.state = STATE_2; // Green
          tri.phase = 1;
          tri.polarity = Math.random() > 0.5 ? 1 : -1;
          rebuildNeighbors();
          logEvent(`Built triangle ${tri.id}`, '');
        } else if (tri.state === DORMANT) {
          tri.state = STATE_2; // Green
          tri.phase = 1;
          tri.polarity = Math.random() > 0.5 ? 1 : -1;
          logEvent(`Activated triangle ${tri.id}`, '');
        }
      } else {
        if (tri._removed) continue;
        // Cycle: dormant -> red -> green -> blue -> dormant
        tri.state = (tri.state + 1) % 4;
        tri.phase = tri.state === DORMANT ? 0 : tri.state - 1;
      }
      updateMetrics();
      render();
      break;
    }
  }
});

// Right-click to restore carved triangles
canvas.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  
  // Find clicked (removed) triangle to restore
  for (let i = 0; i < triangles.length; i++) {
    const tri = triangles[i];
    if (!tri._removed) continue;
    
    if (pointInTriangle(x, y, tri.vertices)) {
      tri._removed = false;
      tri.state = DORMANT;
      // Restore neighbor connections
      rebuildNeighbors();
      logEvent(`Restored triangle ${tri.id}`, '');
      updateMetrics();
      render();
      break;
    }
  }
});

function rebuildNeighbors() {
  // Rebuild neighbor lists excluding removed triangles
  const activeIds = new Set(triangles.filter(t => !t._removed).map(t => t.id));
  triangles.forEach(tri => {
    if (tri._removed) return;
    tri.neighbors = tri._originalNeighbors.filter(nId => activeIds.has(nId));
  });
}

function pointInTriangle(px, py, vertices) {
  const [v1, v2, v3] = vertices;
  
  const area = 0.5 * (-v2.y * v3.x + v1.y * (-v2.x + v3.x) + v1.x * (v2.y - v3.y) + v2.x * v3.y);
  const s = 1 / (2 * area) * (v1.y * v3.x - v1.x * v3.y + (v3.y - v1.y) * px + (v1.x - v3.x) * py);
  const t = 1 / (2 * area) * (v1.x * v2.y - v1.y * v2.x + (v1.y - v2.y) * px + (v2.x - v1.x) * py);
  
  return s > 0 && t > 0 && (1 - s - t) > 0;
}

// === INIT ===
buildMesh();
startSimulation();

// === RECORDER FUNCTIONS ===
function captureFrame() {
  // Count states for metrics
  let state1 = 0, state2 = 0, state3 = 0, active = 0, total = 0;
  triangles.forEach(t => {
    if (t._removed) return;
    total++;
    if (t.state > 0) active++;
    if (t.state === 1) state1++;
    if (t.state === 2) state2++;
    if (t.state === 3) state3++;
  });
  
  return {
    timestamp: Date.now(),
    tick: recorder.tickCount || 0,
    params: {
      speedMultiplier: speedMultiplier,
      isolationDecay: isolationDecay,
      meshShape: meshShape,
      numRings: numRings,
      tickInterval: TICK_INTERVAL
    },
    metrics: {
      total: total,
      active: active,
      state1: state1,
      state2: state2,
      state3: state3,
      contacts: contactCount
    },
    triangles: triangles.map(t => ({
      id: t.id,
      state: t.state,
      phase: t.phase,
      polarity: t.polarity,
      skipCount: t.skipCount || 0,
      isolationCount: t._isolationCount || 0,
      removed: t._removed || false
    })),
    contacts: contactCount
  };
}

function applyFrame(frame) {
  frame.triangles.forEach(f => {
    const tri = triangles.find(t => t.id === f.id);
    if (tri) {
      tri.state = f.state;
      tri.phase = f.phase;
      tri.polarity = f.polarity;
      tri._removed = f.removed;
    }
  });
  if (frame.contacts !== undefined) {
    contactCount = frame.contacts;
  }
  updateMetrics();
  render();
}

function startRecording() {
  recorder.frames = [];
  recorder.tickCount = 0;
  recorder.recording = true;
  document.getElementById('recordBtn').textContent = '‚èπ Stop';
  document.getElementById('recorderStatus').textContent = 'RECORDING';
  document.getElementById('recorderStatus').style.color = '#f66';
  logEvent('Recording started', '');
}

function stopRecording() {
  recorder.recording = false;
  document.getElementById('recordBtn').textContent = '‚è∫ Record';
  document.getElementById('recorderStatus').textContent = 'IDLE';
  document.getElementById('recorderStatus').style.color = '';
  document.getElementById('playBtn').disabled = recorder.frames.length === 0;
  document.getElementById('exportBtn').disabled = recorder.frames.length === 0;
  logEvent(`Recording stopped: ${recorder.frames.length} frames`, '');
}

function startPlayback() {
  if (recorder.frames.length === 0) return;
  recorder.playing = true;
  recorder.playIndex = 0;
  paused = true;
  document.getElementById('pauseBtn').textContent = 'Resume';
  document.getElementById('playBtn').disabled = true;
  document.getElementById('stopPlaybackBtn').disabled = false;
  document.getElementById('recorderStatus').textContent = 'PLAYING';
  document.getElementById('recorderStatus').style.color = '#6af';
  logEvent('Playback started', '');
  
  recorder.playbackTimer = setInterval(() => {
    if (recorder.playIndex >= recorder.frames.length) {
      stopPlayback();
      return;
    }
    applyFrame(recorder.frames[recorder.playIndex]);
    document.getElementById('frameCount').textContent = 
      `${recorder.playIndex + 1}/${recorder.frames.length}`;
    recorder.playIndex++;
  }, TICK_INTERVAL / speedMultiplier);
}

function stopPlayback() {
  recorder.playing = false;
  if (recorder.playbackTimer) {
    clearInterval(recorder.playbackTimer);
    recorder.playbackTimer = null;
  }
  document.getElementById('playBtn').disabled = false;
  document.getElementById('stopPlaybackBtn').disabled = true;
  document.getElementById('recorderStatus').textContent = 'IDLE';
  document.getElementById('recorderStatus').style.color = '';
  logEvent('Playback stopped', '');
}

function exportRecording() {
  if (recorder.frames.length === 0) return;
  const data = {
    version: 2,
    spec: 'ANGEL-2 Triangular C2 Network',
    exported: new Date().toISOString(),
    config: {
      meshShape: meshShape,
      numRings: numRings,
      tickInterval: TICK_INTERVAL,
      triSize: TRI_SIZE,
      speedMultiplier: speedMultiplier,
      isolationDecay: isolationDecay
    },
    constants: {
      DORMANT: 0,
      STATE_1: 1,
      STATE_2: 2,
      STATE_3: 3,
      skipThreshold: 2,
      isolationEquilibriumTicks: 3,
      isolationDormantTicks: 5
    },
    frameCount: recorder.frames.length,
    totalTicks: recorder.tickCount,
    frames: recorder.frames
  };
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = `angel2-recording-${Date.now()}.json`;
  a.click();
  URL.revokeObjectURL(a.href);
  logEvent(`Exported ${recorder.frames.length} frames`, '');
}

function importRecording(file) {
  const reader = new FileReader();
  reader.onload = (e) => {
    try {
      const data = JSON.parse(e.target.result);
      if (Array.isArray(data)) {
        recorder.frames = data;
      } else if (data.frames) {
        recorder.frames = data.frames;
        if (data.meshShape && data.numRings) {
          meshShape = data.meshShape;
          numRings = data.numRings;
          document.getElementById('ringsSlider').value = numRings;
          document.getElementById('ringsValue').textContent = numRings;
          document.querySelectorAll('.shape-btn').forEach(b => {
            b.classList.toggle('active', b.id === 'shape' + meshShape.charAt(0).toUpperCase() + meshShape.slice(1));
          });
          buildMesh();
        }
      }
      document.getElementById('frameCount').textContent = recorder.frames.length;
      document.getElementById('playBtn').disabled = false;
      document.getElementById('exportBtn').disabled = false;
      logEvent(`Imported ${recorder.frames.length} frames`, '');
    } catch (err) {
      logEvent('Import failed: invalid JSON', '');
      console.error('Import error:', err);
    }
  };
  reader.readAsText(file);
}

// === RECORDER EVENT LISTENERS ===
document.getElementById('recordBtn').addEventListener('click', () => {
  if (recorder.recording) {
    stopRecording();
  } else {
    startRecording();
  }
});

document.getElementById('playBtn').addEventListener('click', startPlayback);
document.getElementById('stopPlaybackBtn').addEventListener('click', stopPlayback);
document.getElementById('exportBtn').addEventListener('click', exportRecording);

document.getElementById('importBtn').addEventListener('click', () => {
  document.getElementById('importFile').click();
});

document.getElementById('importFile').addEventListener('change', (e) => {
  if (e.target.files.length > 0) {
    importRecording(e.target.files[0]);
    e.target.value = '';
  }
});

// === HOOK INTO TICK FOR RECORDING ===
const _originalTick = tick;
tick = function() {
  _originalTick();
  if (recorder.recording && !paused) {
    recorder.tickCount++;
    recorder.frames.push(captureFrame());
    document.getElementById('frameCount').textContent = recorder.frames.length;
    document.getElementById('playBtn').disabled = false;
    document.getElementById('exportBtn').disabled = false;
  }
};
</script>

</div>
</body>
</html>

