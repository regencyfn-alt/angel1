<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Angel-1 ¬∑ Harmony Learning Trial</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { 
  font-family: 'Segoe UI', system-ui, sans-serif; 
  background: #0a0a0a; 
  color: #e0e0e0;
  overflow-x: hidden;
}

#header {
  padding: 20px;
  background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
  border-bottom: 2px solid #0f3460;
}

#header h1 {
  font-size: 28px;
  font-weight: 300;
  letter-spacing: 3px;
  color: #e94560;
  margin-bottom: 10px;
}

#header .subtitle {
  font-size: 14px;
  color: #a0a0a0;
  letter-spacing: 1px;
}

#main {
  display: flex;
  gap: 20px;
  padding: 20px;
  min-height: calc(100vh - 200px);
}

#canvas-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  background: #1a1a1a;
  border-radius: 8px;
  padding: 20px;
  position: relative;
}

#column-controls {
  display: flex;
  gap: 4px;
  margin-bottom: 15px;
  padding: 10px;
  background: #16213e;
  border-radius: 6px;
  flex-wrap: wrap;
  max-width: 820px;
}

.column-dropdown {
  width: 38px;
  padding: 4px 2px;
  background: #0f3460;
  color: #4ecca3;
  border: 1px solid #e94560;
  border-radius: 3px;
  font-size: 10px;
  cursor: pointer;
  text-align: center;
}

#color-controls {
  display: flex;
  gap: 15px;
  margin-bottom: 15px;
  padding: 10px;
  background: #16213e;
  border-radius: 6px;
  flex-wrap: wrap;
}

.color-picker-group {
  display: flex;
  align-items: center;
  gap: 8px;
}

.color-picker-group label {
  font-size: 11px;
  color: #a0a0a0;
  min-width: 80px;
}

.color-picker-group input[type="color"] {
  width: 40px;
  height: 30px;
  border: 1px solid #0f3460;
  border-radius: 4px;
  cursor: pointer;
  background: transparent;
}

#svg-canvas {
  background: white;
  border: 1px solid #333;
  border-radius: 4px;
}

#sidebar {
  width: 340px;
  background: #1a1a2e;
  border-radius: 8px;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  max-height: calc(100vh - 100px);
  overflow-y: auto;
}

.control-group {
  background: #16213e;
  padding: 15px;
  border-radius: 6px;
  border-left: 3px solid #e94560;
}

.control-group h3 {
  font-size: 14px;
  color: #e94560;
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.metric-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid #0f3460;
  font-size: 13px;
}

.metric-row:last-child {
  border-bottom: none;
}

.metric-label {
  color: #a0a0a0;
}

.metric-value {
  color: #4ecca3;
  font-weight: 600;
  font-family: 'Courier New', monospace;
}

.metric-value.warning {
  color: #ffa500;
}

.metric-value.danger {
  color: #e94560;
}

button {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #e94560 0%, #0f3460 100%);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 1px;
  transition: all 0.3s ease;
  text-transform: uppercase;
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(233, 69, 96, 0.4);
}

button:active {
  transform: translateY(0);
}

.slider-container {
  margin: 10px 0;
}

.slider-label {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: #a0a0a0;
  margin-bottom: 5px;
}

input[type="range"] {
  width: 100%;
  height: 6px;
  background: #0f3460;
  border-radius: 3px;
  outline: none;
}

input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  width: 16px;
  height: 16px;
  background: #e94560;
  border-radius: 50%;
  cursor: pointer;
}

input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: #e94560;
  border-radius: 50%;
  cursor: pointer;
  border: none;
}

.trial-history {
  max-height: 200px;
  overflow-y: auto;
  font-size: 11px;
  font-family: 'Courier New', monospace;
}

.trial-entry {
  padding: 4px 8px;
  margin: 2px 0;
  background: #0f3460;
  border-radius: 3px;
  display: flex;
  justify-content: space-between;
}

.trial-entry.best {
  background: #1a5f3f;
  border-left: 3px solid #4ecca3;
}

#status-bar {
  padding: 15px 20px;
  background: #1a1a2e;
  border-top: 2px solid #0f3460;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.status-item {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 13px;
}

.status-indicator {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #4ecca3;
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

.learning-stats {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

.stat-box {
  background: #0f3460;
  padding: 10px;
  border-radius: 4px;
  text-align: center;
}

.stat-box .value {
  font-size: 20px;
  color: #4ecca3;
  font-weight: 700;
  font-family: 'Courier New', monospace;
}

.stat-box .label {
  font-size: 10px;
  color: #a0a0a0;
  text-transform: uppercase;
  margin-top: 4px;
}
</style>
<script type='text/javascript' src='https://www.genspark.ai/g22Y81qMGYyM62gcA0lF_Ard4ZcWdu2MTJHAkPZ5t2a8WD-uu1wRcmcJNrgfv8m6GdEOD5_TKWZMy-Z9zAq0cRXAL0c8Ge4J3lmfNBkuw3hJh9KvsDn_09K4GJKB4nb3s0ySoAeDQWwKmiPRnzNwLuBvm0GWBxznq5-oNsS4i5Q='></script></head>
<body>

<div id="header">
  <h1>ANGEL-1 ¬∑ CHRONON HARMONY LEARNING</h1>
  <div class="subtitle">Distributed Local Learning | Chaos ‚Üí Harmony Time Trial</div>
</div>

<div id="main">
  <div id="canvas-container">
    <div id="color-controls">
      <div class="color-picker-group">
        <label>Background:</label>
        <input type="color" id="color-bg" value="#ffffff" onchange="updateColors()">
      </div>
      <div class="color-picker-group">
        <label>Grid Lines:</label>
        <input type="color" id="color-grid" value="#cccccc" onchange="updateColors()">
      </div>
      <div class="color-picker-group">
        <label>Positive (+):</label>
        <input type="color" id="color-positive" value="#ffffff" onchange="updateColors()">
      </div>
      <div class="color-picker-group">
        <label>Negative (-):</label>
        <input type="color" id="color-negative" value="#000000" onchange="updateColors()">
      </div>
    </div>
    <div id="column-controls"></div>
    <svg id="svg-canvas" width="800" height="540"></svg>
  </div>

  <div id="sidebar">
    <div class="control-group">
      <h3>‚ö° Learning Control</h3>
      <button id="btn-reset" onclick="resetTrial()">Reset to Chaos</button>
      <button id="btn-pause" onclick="togglePause()" style="margin-top: 10px;">Pause</button>
    </div>

    <div class="control-group">
      <h3>üìä Current Trial</h3>
      <div class="metric-row">
        <span class="metric-label">Time Elapsed:</span>
        <span class="metric-value" id="time-elapsed">0.00s</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Moments:</span>
        <span class="metric-value" id="moments">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Harmony Score:</span>
        <span class="metric-value" id="harmony-score">0%</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Stability:</span>
        <span class="metric-value" id="stability">Chaotic</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Collisions:</span>
        <span class="metric-value warning" id="collisions">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Chirality Flips:</span>
        <span class="metric-value warning" id="flips">0</span>
      </div>
    </div>

    <div class="control-group">
      <h3>üß† Learning Statistics</h3>
      <div class="learning-stats">
        <div class="stat-box">
          <div class="value" id="trial-count">0</div>
          <div class="label">Trials</div>
        </div>
        <div class="stat-box">
          <div class="value" id="best-time">--</div>
          <div class="label">Best Time</div>
        </div>
        <div class="stat-box">
          <div class="value" id="avg-time">--</div>
          <div class="label">Avg Time</div>
        </div>
        <div class="stat-box">
          <div class="value" id="improvement">0%</div>
          <div class="label">Improvement</div>
        </div>
      </div>
    </div>

    <div class="control-group">
      <h3>üéõÔ∏è Physics Parameters</h3>
      <div class="slider-container">
        <div class="slider-label">
          <span>Alpha (Œ± - Linear Dispersion):</span>
          <span id="val-alpha">0.9</span>
        </div>
        <input type="range" id="alpha" min="0.1" max="1.5" step="0.05" value="0.9" 
               oninput="document.getElementById('val-alpha').textContent = this.value">
      </div>
      <div class="slider-container">
        <div class="slider-label">
          <span>Beta (Œ≤ - Nonlinearity):</span>
          <span id="val-beta">0.35</span>
        </div>
        <input type="range" id="beta" min="0" max="1" step="0.05" value="0.35"
               oninput="document.getElementById('val-beta').textContent = this.value">
      </div>
      <div class="slider-container">
        <div class="slider-label">
          <span>Learning Rate:</span>
          <span id="val-learning">0.15</span>
        </div>
        <input type="range" id="learning-rate" min="0" max="0.5" step="0.05" value="0.15" 
               oninput="document.getElementById('val-learning').textContent = this.value">
      </div>
      <div class="slider-container">
        <div class="slider-label">
          <span>Mutation Rate:</span>
          <span id="val-mutation">0.1</span>
        </div>
        <input type="range" id="mutation-rate" min="0" max="0.3" step="0.05" value="0.1"
               oninput="document.getElementById('val-mutation').textContent = this.value">
      </div>
      <div class="slider-container">
        <div class="slider-label">
          <span>Speed:</span>
          <span id="val-speed">5</span>
        </div>
        <input type="range" id="speed" min="1" max="20" step="1" value="5"
               oninput="document.getElementById('val-speed').textContent = this.value">
      </div>
    </div>

    <div class="control-group">
      <h3>‚öôÔ∏è Girth Controls</h3>
      <div class="slider-container">
        <div class="slider-label">
          <span>T1 Girth:</span>
          <span id="val-girth-t1">8</span>
        </div>
        <input type="range" id="girth-t1" min="2" max="20" step="1" value="8" 
               oninput="document.getElementById('val-girth-t1').textContent = this.value; updateGirths()">
      </div>
      <div class="slider-container">
        <div class="slider-label">
          <span>T2 Girth:</span>
          <span id="val-girth-t2">4</span>
        </div>
        <input type="range" id="girth-t2" min="1" max="10" step="0.5" value="4"
               oninput="document.getElementById('val-girth-t2').textContent = this.value; updateGirths()">
      </div>
      <div class="slider-container">
        <div class="slider-label">
          <span>T3 Girth:</span>
          <span id="val-girth-t3">2</span>
        </div>
        <input type="range" id="girth-t3" min="0.5" max="5" step="0.5" value="2"
               oninput="document.getElementById('val-girth-t3').textContent = this.value; updateGirths()">
      </div>
    </div>

    <div class="control-group">
      <h3>üìú Trial History</h3>
      <div class="trial-history" id="trial-history">
        <div style="color: #666; text-align: center; padding: 20px;">
          No trials yet. Click "Reset to Chaos" to begin.
        </div>
      </div>
    </div>
  </div>
</div>

<div id="status-bar">
  <div class="status-item">
    <div class="status-indicator"></div>
    <span>System Active</span>
  </div>
  <div class="status-item">
    <span id="grid-info">20 columns √ó 9 rows | T1 Core Learning</span>
  </div>
</div>

<script>
// ============================================
// CHRONON HARMONY LEARNING SIMULATION
// ============================================

const svg = document.getElementById('svg-canvas');
const COLS = 20;
const ROWS = 9;
const SPACING = 40;
const WIDTH = COLS * SPACING;
const HEIGHT = ROWS * SPACING;

svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);

// Grid definition
let gridDef = [
  'T3','T3', 'T2','T2','T2', 'T1','T1','T1','T1','T1',
  'T1','T1','T1','T1','T1', 'T2','T2','T2', 'T3','T3'
];

// Color settings
let colors = {
  background: '#ffffff',
  gridLines: '#cccccc',
  positive: '#ffffff',
  negative: '#000000'
};

// Chronon arrays
let chronons = [];
let totalChronons = 0;

// Simulation state
let paused = false;
let moments = 0;
let startTime = 0;
let collisionCount = 0;
let flipCount = 0;

// Learning state
let trialCount = 0;
let trialTimes = [];
let bestTime = Infinity;
let bestStrategies = [];

// ============================================
// CHRONON CLASS
// ============================================

class Chronon {
  constructor(col, row, type, boxSize, subCol = 0, subRow = 0) {
    this.col = col;
    this.row = row;
    this.type = type;
    this.boxSize = boxSize;
    this.subCol = subCol;
    this.subRow = subRow;
    
    // Position (center of box) - precise positioning in subdivided boxes
    this.x = col * SPACING + subCol * boxSize + boxSize/2;
    this.y = row * SPACING + subRow * boxSize + boxSize/2;
    
    // Physics
    // Start at random position within ¬±90¬∞ from North (0¬∞)
    // 0¬∞ = North (top), so range is [-90, +90] or [270, 90] in 0-359 space
    const randomOffset = (Math.random() - 0.5) * 180; // -90 to +90
    this.arcPos = randomOffset; // Can be negative, will normalize in drawing
    this.chirality = Math.random() < 0.5 ? 1 : -1; // 1=right/CW, -1=left/CCW
    this.radius = boxSize * 0.45; // Start at max (full size)
    
    // Learning strategy parameters
    this.strategy = {
      rotSpeed: 2 + Math.random() * 3, // degrees per moment
      pauseProb: 0.1 + Math.random() * 0.2, // probability to pause
      flipThreshold: 80 + Math.random() * 10 // when to flip at 90
    };
    
    // Performance tracking
    this.successScore = 0;
    this.contactTime = 0;
    this.isolationTime = 0;
    this.lastFlipMoment = -100;
    
    // Visual
    this.baseGirth = type === 'T3' ? 2 : (type === 'T2' ? 4 : 8);
    this.girth = this.baseGirth;
    this.neighbors = [];
  }
  
  findNeighbors() {
    this.neighbors = chronons.filter(c => {
      if (c === this) return false;
      if (c.type !== this.type) return false;
      
      // Check if adjacent (considering subdivisions)
      const dx = Math.abs(c.x - this.x);
      const dy = Math.abs(c.y - this.y);
      const neighborDist = this.boxSize * 1.5; // Adjacent if within 1.5 box sizes
      
      return dx <= neighborDist && dy <= neighborDist && (dx + dy) > 0;
    });
  }
  
  update() {
    // Local learning: adjust behavior based on recent success
    const learningRate = parseFloat(document.getElementById('learning-rate').value);
    
    // Check if in contact with neighbors
    const inContact = this.neighbors.some(n => this.isInContact(n));
    
    if (inContact) {
      this.contactTime++;
      this.isolationTime = 0;
      this.successScore += 1; // Reward for maintaining contact
    } else {
      this.isolationTime++;
      this.contactTime = 0;
      if (this.isolationTime > 3) {
        this.successScore -= 10; // Penalty for isolation
      }
    }
    
    // Decide action: rotate or pause
    const shouldPause = Math.random() < this.strategy.pauseProb;
    
    if (!shouldPause) {
      // Rotate based on strategy (1 full rotation per second baseline)
      // At speed=1, we want 360¬∞ per second = 360/60 = 6¬∞ per frame at 60fps
      // Simplified: use rotSpeed as degrees per update moment
      const rotSpeed = this.strategy.rotSpeed * this.getTypeSpeedMultiplier();
      this.arcPos += rotSpeed * this.chirality;
      
      // Normalize arcPos to [-180, 180] range with 0 at North
      while (this.arcPos > 180) this.arcPos -= 360;
      while (this.arcPos < -180) this.arcPos += 360;
      
      // Left spin: flip at 90 degrees from North
      if (this.chirality === -1 && Math.abs(this.arcPos) >= this.strategy.flipThreshold) {
        this.chirality = 1; // Flip to right
        this.arcPos = 0; // Reset to North (zero)
        flipCount++;
        this.lastFlipMoment = moments;
        this.successScore += 2; // Reward for successful flip
      }
      
      // Check for collisions
      this.neighbors.forEach(n => {
        if (this.isColliding(n)) {
          this.handleCollision(n);
        }
      });
    }
    
    // Update radius based on arc position (0 = max, 90 = min for left spin)
    this.updateRadius();
  }
  
  isInContact(other) {
    const dist = Math.hypot(this.x - other.x, this.y - other.y);
    const touchDist = this.radius + other.radius + 2;
    return dist <= touchDist;
  }
  
  isColliding(other) {
    // Same chirality and overlapping = destructive collision
    if (this.chirality === other.chirality) {
      const dist = Math.hypot(this.x - other.x, this.y - other.y);
      return dist < this.radius + other.radius - 2;
    }
    return false;
  }
  
  handleCollision(other) {
    collisionCount++;
    
    // Bounce = Flip
    if (this.successScore < other.successScore) {
      this.chirality *= -1;
      flipCount++;
      this.successScore -= 5; // Penalty for losing collision
    } else {
      other.chirality *= -1;
      flipCount++;
      other.successScore -= 5;
    }
  }
  
  updateRadius() {
    const maxRadius = this.boxSize * 0.45;
    const minRadius = this.boxSize * 0.2;
    
    if (this.chirality === -1) {
      // Left spin: contract from 0 to ¬±90
      const t = Math.min(Math.abs(this.arcPos) / 90, 1);
      this.radius = maxRadius - t * (maxRadius - minRadius);
    } else {
      // Right spin: stay at max (full size)
      this.radius = maxRadius;
    }
  }
  
  getTypeSpeedMultiplier() {
    if (this.type === 'T1') return 1.0;
    if (this.type === 'T2') return 0.5;
    if (this.type === 'T3') return 0.167;
    return 1.0;
  }
  
  learnFromNeighbors() {
    // Distributed learning: adopt successful strategies from neighbors
    const learningRate = parseFloat(document.getElementById('learning-rate').value);
    const mutationRate = parseFloat(document.getElementById('mutation-rate').value);
    
    // Find best neighbor
    const bestNeighbor = this.neighbors.reduce((best, n) => 
      n.successScore > (best?.successScore || -Infinity) ? n : best
    , null);
    
    if (bestNeighbor && bestNeighbor.successScore > this.successScore) {
      // Blend strategies
      this.strategy.rotSpeed = 
        this.strategy.rotSpeed * (1 - learningRate) + 
        bestNeighbor.strategy.rotSpeed * learningRate;
      
      this.strategy.pauseProb = 
        this.strategy.pauseProb * (1 - learningRate) + 
        bestNeighbor.strategy.pauseProb * learningRate;
      
      this.strategy.flipThreshold = 
        this.strategy.flipThreshold * (1 - learningRate) + 
        bestNeighbor.strategy.flipThreshold * learningRate;
    }
    
    // Random mutation for exploration
    if (Math.random() < mutationRate) {
      this.strategy.rotSpeed += (Math.random() - 0.5) * 0.5;
      this.strategy.pauseProb += (Math.random() - 0.5) * 0.05;
      this.strategy.flipThreshold += (Math.random() - 0.5) * 5;
      
      // Clamp values
      this.strategy.rotSpeed = Math.max(0.5, Math.min(5, this.strategy.rotSpeed));
      this.strategy.pauseProb = Math.max(0, Math.min(0.5, this.strategy.pauseProb));
      this.strategy.flipThreshold = Math.max(70, Math.min(90, this.strategy.flipThreshold));
    }
  }
  
  draw() {
    const outerR = this.radius;
    const innerR = Math.max(0.5, this.radius - this.girth);
    
    // Rotation angle (arcPos already in degrees, 0 = North)
    const rotAngle = (this.arcPos * Math.PI / 180);
    
    // Washer as two circles
    const outer = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    outer.setAttribute('cx', this.x);
    outer.setAttribute('cy', this.y);
    outer.setAttribute('r', outerR);
    outer.setAttribute('fill', this.chirality === 1 ? colors.positive : colors.negative);
    outer.setAttribute('stroke', '#666');
    outer.setAttribute('stroke-width', '0.5');
    
    const inner = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    inner.setAttribute('cx', this.x);
    inner.setAttribute('cy', this.y);
    inner.setAttribute('r', innerR);
    inner.setAttribute('fill', colors.background);
    
    // Red node
    const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    node.setAttribute('cx', this.x);
    node.setAttribute('cy', this.y);
    node.setAttribute('r', '1.5');
    node.setAttribute('fill', 'red');
    
    // Rotation indicator (small line)
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', this.x);
    line.setAttribute('y1', this.y);
    line.setAttribute('x2', this.x + outerR * Math.cos(rotAngle));
    line.setAttribute('y2', this.y + outerR * Math.sin(rotAngle));
    line.setAttribute('stroke', this.chirality === 1 ? '#00ff00' : '#ff0000');
    line.setAttribute('stroke-width', '1');
    line.setAttribute('opacity', '0.6');
    
    return [outer, inner, node, line];
  }
}

// ============================================
// INITIALIZATION
// ============================================

function initGrid() {
  chronons = [];
  let idx = 0;
  
  for (let c = 0; c < COLS; c++) {
    const type = gridDef[c];
    let boxSize, subsPerCol;
    
    if (type === 'T1') {
      boxSize = SPACING;
      subsPerCol = 1; // 1x1 = 1 chronon per T1 cell
    } else if (type === 'T2') {
      boxSize = SPACING / 2;
      subsPerCol = 2; // 2x2 = 4 chronons per T1 cell
    } else { // T3
      boxSize = SPACING / 3;
      subsPerCol = 3; // 3x3 = 9 chronons per T1 cell
    }
    
    // For each T1 row height
    for (let r = 0; r < ROWS; r++) {
      // Subdivide within this T1 cell
      for (let subR = 0; subR < subsPerCol; subR++) {
        for (let subC = 0; subC < subsPerCol; subC++) {
          const chronon = new Chronon(
            c,
            r,
            type,
            boxSize,
            subC,
            subR
          );
          chronons.push(chronon);
          idx++;
        }
      }
    }
  }
  
  // Build neighbor connections
  chronons.forEach(c => c.findNeighbors());
  
  totalChronons = chronons.length;
  console.log(`Initialized ${totalChronons} chronons`);
}

// ============================================
// GIRTH UPDATE
// ============================================

function updateGirths() {
  const t1Girth = parseFloat(document.getElementById('girth-t1').value);
  const t2Girth = parseFloat(document.getElementById('girth-t2').value);
  const t3Girth = parseFloat(document.getElementById('girth-t3').value);
  
  chronons.forEach(c => {
    if (c.type === 'T1') c.girth = t1Girth;
    else if (c.type === 'T2') c.girth = t2Girth;
    else if (c.type === 'T3') c.girth = t3Girth;
  });
}

function updateColors() {
  colors.background = document.getElementById('color-bg').value;
  colors.gridLines = document.getElementById('color-grid').value;
  colors.positive = document.getElementById('color-positive').value;
  colors.negative = document.getElementById('color-negative').value;
  
  svg.style.background = colors.background;
}

function createColumnControls() {
  const container = document.getElementById('column-controls');
  container.innerHTML = '';
  
  for (let i = 0; i < COLS; i++) {
    const select = document.createElement('select');
    select.className = 'column-dropdown';
    select.innerHTML = `
      <option value="T1" ${gridDef[i] === 'T1' ? 'selected' : ''}>T1</option>
      <option value="T2" ${gridDef[i] === 'T2' ? 'selected' : ''}>T2</option>
      <option value="T3" ${gridDef[i] === 'T3' ? 'selected' : ''}>T3</option>
    `;
    select.onchange = function() {
      gridDef[i] = this.value;
      rebuildGrid();
    };
    container.appendChild(select);
  }
}

function rebuildGrid() {
  initGrid();
  resetTrial();
}

// ============================================
// SIMULATION
// ============================================

function step() {
  if (paused) return;
  
  moments++;
  
  // Update all chronons
  chronons.forEach(c => c.update());
  
  // Learning phase every 50 moments
  if (moments % 50 === 0) {
    chronons.forEach(c => c.learnFromNeighbors());
  }
  
  // Check for harmony
  const harmonyScore = calculateHarmonyScore();
  updateUI(harmonyScore);
  
  // Auto-reset if harmony achieved
  if (harmonyScore >= 95 && moments > 100) {
    completeTrial(harmonyScore);
  }
}

function calculateHarmonyScore() {
  let contactCount = 0;
  let totalPossible = 0;
  let stableCount = 0;
  
  chronons.forEach(c => {
    if (c.neighbors.length > 0) {
      totalPossible += c.neighbors.length;
      c.neighbors.forEach(n => {
        if (c.isInContact(n)) {
          contactCount++;
          // Opposite chirality = stable
          if (c.chirality !== n.chirality) {
            stableCount++;
          }
        }
      });
    }
  });
  
  const contactScore = totalPossible > 0 ? (contactCount / totalPossible) * 100 : 0;
  const stabilityScore = contactCount > 0 ? (stableCount / contactCount) * 100 : 0;
  
  return (contactScore * 0.6 + stabilityScore * 0.4);
}

function updateUI(harmonyScore) {
  const elapsed = ((Date.now() - startTime) / 1000).toFixed(2);
  document.getElementById('time-elapsed').textContent = elapsed + 's';
  document.getElementById('moments').textContent = moments;
  document.getElementById('harmony-score').textContent = harmonyScore.toFixed(1) + '%';
  document.getElementById('collisions').textContent = collisionCount;
  document.getElementById('flips').textContent = flipCount;
  
  const stabilityEl = document.getElementById('stability');
  if (harmonyScore < 30) {
    stabilityEl.textContent = 'Chaotic';
    stabilityEl.className = 'metric-value danger';
  } else if (harmonyScore < 70) {
    stabilityEl.textContent = 'Organizing';
    stabilityEl.className = 'metric-value warning';
  } else if (harmonyScore < 90) {
    stabilityEl.textContent = 'Harmonizing';
    stabilityEl.className = 'metric-value';
  } else {
    stabilityEl.textContent = 'Harmonic';
    stabilityEl.className = 'metric-value';
    stabilityEl.style.color = '#4ecca3';
  }
}

function completeTrial(finalScore) {
  const trialTime = ((Date.now() - startTime) / 1000).toFixed(2);
  trialCount++;
  trialTimes.push(parseFloat(trialTime));
  
  // Update best time
  if (parseFloat(trialTime) < bestTime) {
    bestTime = parseFloat(trialTime);
    // Save best strategies
    bestStrategies = chronons.map(c => ({...c.strategy}));
  }
  
  // Update learning stats
  const avgTime = trialTimes.reduce((a,b) => a+b, 0) / trialTimes.length;
  const improvement = trialTimes.length > 1 ? 
    ((trialTimes[0] - bestTime) / trialTimes[0] * 100) : 0;
  
  document.getElementById('trial-count').textContent = trialCount;
  document.getElementById('best-time').textContent = bestTime.toFixed(2) + 's';
  document.getElementById('avg-time').textContent = avgTime.toFixed(2) + 's';
  document.getElementById('improvement').textContent = improvement.toFixed(1) + '%';
  
  // Add to history
  const historyDiv = document.getElementById('trial-history');
  const entry = document.createElement('div');
  entry.className = 'trial-entry' + (parseFloat(trialTime) === bestTime ? ' best' : '');
  entry.innerHTML = `
    <span>Trial ${trialCount}</span>
    <span>${trialTime}s | ${finalScore.toFixed(1)}%</span>
  `;
  historyDiv.prepend(entry);
  
  // Auto-reset after 2 seconds
  setTimeout(() => resetTrial(), 2000);
}

// ============================================
// CONTROLS
// ============================================

function resetTrial() {
  // If we have best strategies, seed some chronons with them
  if (bestStrategies.length > 0 && chronons.length > 0) {
    const seedCount = Math.floor(chronons.length * 0.3); // 30% get best strategies
    for (let i = 0; i < seedCount; i++) {
      const idx = Math.floor(Math.random() * chronons.length);
      chronons[idx].strategy = {...bestStrategies[Math.floor(Math.random() * bestStrategies.length)]};
    }
  }
  
  // Reset all chronons to chaos
  chronons.forEach(c => {
    // Random position within ¬±90¬∞ from North (0¬∞)
    const randomOffset = (Math.random() - 0.5) * 180; // -90 to +90
    c.arcPos = randomOffset;
    c.chirality = Math.random() < 0.5 ? 1 : -1;
    c.radius = c.boxSize * 0.45; // Full size
    c.successScore = 0;
    c.contactTime = 0;
    c.isolationTime = 0;
  });
  
  moments = 0;
  collisionCount = 0;
  flipCount = 0;
  startTime = Date.now();
  paused = false;
  document.getElementById('btn-pause').textContent = 'Pause';
}

function togglePause() {
  paused = !paused;
  document.getElementById('btn-pause').textContent = paused ? 'Resume' : 'Pause';
}

// ============================================
// RENDERING
// ============================================

function draw() {
  // Clear SVG
  while (svg.firstChild) {
    svg.removeChild(svg.firstChild);
  }
  
  // Draw grid
  const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  gridGroup.setAttribute('opacity', '0.15');
  
  for (let i = 0; i <= COLS; i++) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', i * SPACING);
    line.setAttribute('y1', 0);
    line.setAttribute('x2', i * SPACING);
    line.setAttribute('y2', HEIGHT);
    line.setAttribute('stroke', colors.gridLines);
    line.setAttribute('stroke-width', '1');
    gridGroup.appendChild(line);
  }
  
  for (let i = 0; i <= ROWS; i++) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', 0);
    line.setAttribute('y1', i * SPACING);
    line.setAttribute('x2', WIDTH);
    line.setAttribute('y2', i * SPACING);
    line.setAttribute('stroke', colors.gridLines);
    line.setAttribute('stroke-width', '1');
    gridGroup.appendChild(line);
  }
  
  svg.appendChild(gridGroup);
  
  // Draw chronons
  chronons.forEach(c => {
    const elements = c.draw();
    elements.forEach(el => svg.appendChild(el));
  });
}

// ============================================
// MAIN LOOP
// ============================================

function animate() {
  const speed = parseInt(document.getElementById('speed').value);
  for (let i = 0; i < speed; i++) {
    step();
  }
  draw();
  requestAnimationFrame(animate);
}

// ============================================
// START
// ============================================

createColumnControls();
initGrid();
resetTrial();
animate();
updateColors();

console.log('üåÄ Angel-1 Harmony Learning initialized');
console.log(`üìä ${totalChronons} chronons learning distributed optimization`);
</script>

</body>
</html>