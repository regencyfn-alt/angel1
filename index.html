import React, { useState, useEffect, useRef } from 'react';
import { Play, Pause, RotateCcw } from 'lucide-react';

const ToroidPlayground = () => {
  const canvasRef = useRef(null);
  const [isPaused, setIsPaused] = useState(true);
  const [gridSize, setGridSize] = useState({ cols: 4, rows: 2 });
  const [cellSize, setCellSize] = useState(80);
  const [toroids, setToroids] = useState([]);
  const [timeScale, setTimeScale] = useState(1.0); // Speed multiplier
  const [metrics, setMetrics] = useState({
    contacts: 0,
    frozen: 0,
    active: 0
  });
  
  const animationRef = useRef(null);
  const lastTimeRef = useRef(Date.now());

  // Toroid class
  class Toroid {
    constructor(col, row, cellSize) {
      this.col = col;
      this.row = row;
      this.x = col * cellSize + cellSize / 2;
      this.y = row * cellSize + cellSize / 2;
      this.cellSize = cellSize;
      
      // Core properties - TRUE 50/50 random
      this.chirality = Math.random() > 0.5 ? 1 : -1; // 1 = right/CW, -1 = left/CCW
      this.rotation = Math.random() * 720; // Random starting rotation (0-720 for 4Ï€)
      this.radius = cellSize * 0.35; // Base radius
      this.expansionFactor = 1.0; // 1.0 = neutral, <1 = contracted, >1 = expanded
      this.maxExpansion = 1.25; // Can expand 25%
      this.minExpansion = 0.85; // Can contract 15%
      
      // Speed (rotations per second)
      this.baseSpeed = 360; // 360 degrees per second = 1 full rotation/sec
      this.speed = this.baseSpeed;
      
      // Survival timer - must make contact or die
      this.timeAlive = 0;
      this.maxTime = 3.0; // 3 seconds to make first contact
      this.timeSinceLastKiss = 0; // Track time since last neighbor interaction
      this.frozen = false;
      this.hasFlipped = false;
      this.hasEverKissed = false; // Track if ever made contact
      
      // Strategy state
      this.strategyPhase = 0; // 0 = initial, 1 = executing flip
      this.strategyTarget = this.chirality === 1 ? 180 : 90; // Right=180deg, Left=90deg (double for 4Ï€)
      
      // Contact feedback
      this.justKissed = false;
      this.kissType = null; // 'bump' or 'amplify'
      this.kissCooldown = 0;
      
      // Intelligence/reward tracking
      this.successfulCycles = 0;
      this.totalKisses = 0;
      this.intelligence = 0.5; // 0-1, starts neutral
    }
    
    update(deltaTime, neighbors) {
      if (this.frozen) return;
      
      this.timeAlive += deltaTime;
      this.timeSinceLastKiss += deltaTime;
      
      // Decay kiss feedback
      if (this.kissCooldown > 0) {
        this.kissCooldown -= deltaTime;
        if (this.kissCooldown <= 0) {
          this.justKissed = false;
          this.kissType = null;
        }
      }
      
      // Update rotation based on chirality and speed (4Ï€ cycle = 720Â°)
      const rotationDelta = this.speed * deltaTime * this.chirality;
      this.rotation = (this.rotation + rotationDelta) % 720;
      if (this.rotation < 0) this.rotation += 720;
      
      // Update expansion based on chirality
      if (this.chirality === 1) {
        // Right rotation: expand and speed up
        this.expansionFactor = Math.min(this.maxExpansion, this.expansionFactor + deltaTime * 0.5);
        this.speed = this.baseSpeed * (1 + (this.expansionFactor - 1) * 1.5);
      } else {
        // Left rotation: contract and slow down
        this.expansionFactor = Math.max(this.minExpansion, this.expansionFactor - deltaTime * 0.3);
        this.speed = this.baseSpeed * this.expansionFactor;
      }
      
      // INTELLIGENT NEIGHBOR SCANNING
      const activeNeighbors = neighbors.filter(n => !n.frozen);
      const neighborStates = this.scanNeighbors(activeNeighbors);
      
      // Check for edge contact
      const currentRadius = this.radius * this.expansionFactor;
      const halfCell = this.cellSize / 2;
      const distToEdgeRight = halfCell - (this.x - (this.col * this.cellSize + halfCell));
      const distToEdgeLeft = halfCell + (this.x - (this.col * this.cellSize + halfCell));
      const distToEdgeTop = halfCell + (this.y - (this.row * this.cellSize + halfCell));
      const distToEdgeBottom = halfCell - (this.y - (this.row * this.cellSize + halfCell));
      
      const touchingEdge = 
        currentRadius >= distToEdgeRight * 0.9 ||
        currentRadius >= distToEdgeLeft * 0.9 ||
        currentRadius >= distToEdgeTop * 0.9 ||
        currentRadius >= distToEdgeBottom * 0.9;
      
      // Check for neighbor contacts when touching edge
      if (touchingEdge && activeNeighbors.length > 0 && this.kissCooldown <= 0) {
        this.checkKissContacts(activeNeighbors);
      }
      
      // INTELLIGENT STRATEGY: Use neighbor info to decide when to flip
      if (!this.hasFlipped && activeNeighbors.length > 0) {
        // Calculate optimal flip point based on neighbor positions and chirality
        const optimalFlipPoint = this.calculateOptimalFlip(neighborStates);
        const targetDiff = Math.abs(((this.rotation - optimalFlipPoint + 360) % 720) - 360);
        
        if (targetDiff < 15) {
          this.flipChirality();
          this.hasFlipped = true;
        }
      } else {
        // Check if we've completed the 4Ï€ cycle (back to start Â±45Â°)
        const startDiff = Math.min(this.rotation, 720 - this.rotation);
        if (startDiff < 45 && this.hasFlipped) {
          // Success! Reset timer and flip flag
          if (this.hasEverKissed) {
            this.timeSinceLastKiss = 0; // Reset connection timer
            this.successfulCycles++;
            this.intelligence = Math.min(1.0, this.intelligence + 0.1);
          }
          this.hasFlipped = false;
        }
      }
      
      // CRITICAL: Connection-based survival
      // If you have no active neighbors, you die quickly
      if (activeNeighbors.length === 0) {
        if (this.timeAlive > 1.0) { // Isolated toroids die after 1 second
          this.frozen = true;
          return;
        }
      }
      
      // If you've never kissed and time is up, you die
      if (!this.hasEverKissed && this.timeAlive >= this.maxTime) {
        this.frozen = true;
        return;
      }
      
      // If you haven't kissed in too long (lost connection), you die
      if (this.hasEverKissed && this.timeSinceLastKiss > this.maxTime * 1.5) {
        this.frozen = true;
        return;
      }
    }
    
    scanNeighbors(neighbors) {
      // Scan neighbors to understand the field
      const states = {
        sameChirality: 0,
        oppositeChirality: 0,
        expanding: 0,
        contracting: 0,
        nearEdge: 0,
        avgRotation: 0
      };
      
      neighbors.forEach(n => {
        if (n.frozen) return;
        
        if (n.chirality === this.chirality) states.sameChirality++;
        else states.oppositeChirality++;
        
        if (n.expansionFactor > 1.1) states.expanding++;
        if (n.expansionFactor < 0.95) states.contracting++;
        
        states.avgRotation += n.rotation;
      });
      
      if (neighbors.length > 0) {
        states.avgRotation /= neighbors.length;
      }
      
      return states;
    }
    
    calculateOptimalFlip(neighborStates) {
      // INTELLIGENT DECISION MAKING
      // If surrounded by opposite chirality neighbors who are expanding,
      // flip early to catch their amplification
      if (neighborStates.oppositeChirality > neighborStates.sameChirality && 
          neighborStates.expanding > 1) {
        // Aggressive strategy: flip earlier for amplification
        return this.chirality === 1 ? 120 : 60;
      }
      
      // If surrounded by same chirality neighbors who are expanding,
      // flip late to avoid bumps
      if (neighborStates.sameChirality > neighborStates.oppositeChirality && 
          neighborStates.expanding > 1) {
        // Conservative strategy: flip later to avoid collision
        return this.chirality === 1 ? 240 : 120;
      }
      
      // Default safe strategy
      return this.chirality === 1 ? 180 : 90;
    }
    
    checkKissContacts(neighbors) {
      neighbors.forEach(neighbor => {
        if (neighbor.frozen || neighbor.kissCooldown > 0) return;
        
        const dx = this.x - neighbor.x;
        const dy = this.y - neighbor.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const combinedRadius = (this.radius * this.expansionFactor) + (neighbor.radius * neighbor.expansionFactor);
        
        // More generous contact threshold
        if (distance < combinedRadius * 1.1) { // 10% overlap tolerance
          
          // Check if same or opposite chirality
          const sameChirality = this.chirality === neighbor.chirality;
          
          if (sameChirality) {
            // Same chirality = opposite edge directions = BUMP
            this.handleBump();
            neighbor.handleBump();
            this.kissType = 'bump';
            neighbor.kissType = 'bump';
          } else {
            // Opposite chirality = same edge directions = AMPLIFY
            this.handleAmplify();
            neighbor.handleAmplify();
            this.kissType = 'amplify';
            neighbor.kissType = 'amplify';
          }
          
          this.justKissed = true;
          neighbor.justKissed = true;
          this.hasEverKissed = true; // Mark as connected
          neighbor.hasEverKissed = true;
          this.timeSinceLastKiss = 0; // Reset connection timer
          neighbor.timeSinceLastKiss = 0;
          this.kissCooldown = 0.3; // 300ms cooldown
          neighbor.kissCooldown = 0.3;
        }
      });
    }
    
    getEdgeVelocity(angle) {
      // Returns direction of edge movement at given angle
      // For CW (chirality=1), edge moves in direction of rotation
      // For CCW (chirality=-1), edge moves opposite
      return this.chirality;
    }
    
    handleBump() {
      // Shrink and reverse direction
      this.expansionFactor = Math.max(this.minExpansion, this.expansionFactor - 0.05);
      this.flipChirality();
      this.totalKisses++;
      this.intelligence = Math.max(0.0, this.intelligence - 0.05); // Penalty for bump
    }
    
    handleAmplify() {
      // Speed boost and continue
      this.rotation += 30 * this.chirality; // Extra kick
      this.speed *= 1.2;
      this.totalKisses++;
      this.intelligence = Math.min(1.0, this.intelligence + 0.1); // Reward for amplification!
    }
    
    flipChirality() {
      this.chirality *= -1;
      this.strategyTarget = this.chirality === 1 ? 90 : 45;
    }
    
    draw(ctx) {
      const currentRadius = this.radius * this.expansionFactor;
      const thickness = 8;
      
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate((this.rotation * Math.PI) / 360); // Divide by 360 since rotation is 0-720
      
      // Flash effect for kiss contact
      if (this.justKissed) {
        ctx.beginPath();
        ctx.arc(0, 0, currentRadius + 5, 0, Math.PI * 2);
        ctx.strokeStyle = this.kissType === 'bump' ? '#ff6b6b' : '#51cf66';
        ctx.lineWidth = 3;
        ctx.stroke();
      }
      
      // Intelligence glow (brighter = smarter)
      if (this.intelligence > 0.6) {
        ctx.beginPath();
        ctx.arc(0, 0, currentRadius + 3, 0, Math.PI * 2);
        ctx.strokeStyle = `rgba(255, 215, 0, ${this.intelligence * 0.5})`;
        ctx.lineWidth = 2;
        ctx.stroke();
      }
      
      // Draw outer ring
      ctx.beginPath();
      ctx.arc(0, 0, currentRadius, 0, Math.PI * 2);
      
      // Color based on state
      let ringColor;
      if (this.frozen) {
        ringColor = '#999';
      } else if (!this.hasEverKissed && this.timeAlive > 2.0) {
        ringColor = '#ff4444'; // Dying - never connected
      } else {
        ringColor = this.chirality === 1 ? '#e94560' : '#4a90e2';
      }
      
      ctx.strokeStyle = ringColor;
      ctx.lineWidth = thickness;
      ctx.stroke();
      
      // Draw charge segments (simplified)
      ctx.beginPath();
      ctx.arc(0, 0, currentRadius, 0, Math.PI);
      ctx.strokeStyle = this.frozen ? '#ccc' : '#333';
      ctx.lineWidth = thickness;
      ctx.stroke();
      
      // Direction indicator
      ctx.beginPath();
      ctx.moveTo(currentRadius - 5, 0);
      ctx.lineTo(currentRadius + 5, 0);
      ctx.strokeStyle = this.chirality === 1 ? '#e94560' : '#4a90e2';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.restore();
      
      // Draw timer bar
      if (!this.frozen) {
        const timerWidth = this.cellSize * 0.6;
        const timerHeight = 4;
        const timerX = this.col * this.cellSize + (this.cellSize - timerWidth) / 2;
        const timerY = (this.row + 1) * this.cellSize - 10;
        
        ctx.fillStyle = '#ddd';
        ctx.fillRect(timerX, timerY, timerWidth, timerHeight);
        
        const timeRatio = this.timeAlive / (this.maxTime * 1.5);
        ctx.fillStyle = timeRatio > 0.66 ? '#e94560' : '#4a90e2';
        ctx.fillRect(timerX, timerY, timerWidth * timeRatio, timerHeight);
      }
      
      // Show successful cycles as small dots
      if (this.successfulCycles > 0) {
        const dotX = this.col * this.cellSize + 5;
        const dotY = this.row * this.cellSize + 5;
        ctx.fillStyle = '#ffd700';
        ctx.beginPath();
        ctx.arc(dotX, dotY, Math.min(this.successfulCycles * 2, 8), 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }

  // Initialize grid
  const initializeGrid = () => {
    const newToroids = [];
    for (let row = 0; row < gridSize.rows; row++) {
      for (let col = 0; col < gridSize.cols; col++) {
        newToroids.push(new Toroid(col, row, cellSize));
      }
    }
    setToroids(newToroids);
    lastTimeRef.current = Date.now();
  };

  // Animation loop
  const animate = () => {
    const now = Date.now();
    const deltaTime = ((now - lastTimeRef.current) / 1000) * timeScale; // Apply time scale
    lastTimeRef.current = now;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    const width = gridSize.cols * cellSize;
    const height = gridSize.rows * cellSize;
    
    canvas.width = width;
    canvas.height = height;

    // Clear canvas
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, width, height);

    // Draw grid
    ctx.strokeStyle = '#ddd';
    ctx.lineWidth = 1;
    for (let i = 0; i <= gridSize.cols; i++) {
      ctx.beginPath();
      ctx.moveTo(i * cellSize, 0);
      ctx.lineTo(i * cellSize, height);
      ctx.stroke();
    }
    for (let i = 0; i <= gridSize.rows; i++) {
      ctx.beginPath();
      ctx.moveTo(0, i * cellSize);
      ctx.lineTo(width, i * cellSize);
      ctx.stroke();
    }

    // Update and draw toroids
    const updatedToroids = toroids.map(toroid => {
      const neighbors = toroids.filter(t => {
        if (t === toroid) return false;
        const colDiff = Math.abs(t.col - toroid.col);
        const rowDiff = Math.abs(t.row - toroid.row);
        return colDiff <= 1 && rowDiff <= 1;
      });
      
      toroid.update(deltaTime, neighbors);
      toroid.draw(ctx);
      return toroid;
    });

    setToroids(updatedToroids);

    // Update metrics
    const frozen = updatedToroids.filter(t => t.frozen).length;
    const active = updatedToroids.length - frozen;
    const contacts = updatedToroids.filter(t => t.justKissed).length / 2;
    const avgIntelligence = active > 0 
      ? updatedToroids.filter(t => !t.frozen).reduce((sum, t) => sum + t.intelligence, 0) / active 
      : 0;
    const totalCycles = updatedToroids.reduce((sum, t) => sum + t.successfulCycles, 0);
    
    setMetrics({ 
      contacts: Math.floor(contacts), 
      frozen, 
      active,
      intelligence: avgIntelligence,
      cycles: totalCycles
    });

    if (!isPaused) {
      animationRef.current = requestAnimationFrame(animate);
    }
  };

  useEffect(() => {
    initializeGrid();
  }, [gridSize, cellSize]);

  useEffect(() => {
    if (!isPaused) {
      lastTimeRef.current = Date.now();
      animationRef.current = requestAnimationFrame(animate);
    }
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, [isPaused, toroids]);

  return (
    <div className="w-full h-full flex flex-col items-center gap-4 p-6 bg-gray-50">
      <div className="w-full max-w-4xl">
        <h1 className="text-3xl font-bold text-gray-800 mb-2">Toroid Mechanics Playground</h1>
        <p className="text-sm text-gray-600 mb-4">
          Red = Right/CW (expand/speedup) Â· Blue = Left/CCW (contract/slowdown)
        </p>

        <div className="flex gap-4 mb-4">
          <button
            onClick={() => setIsPaused(!isPaused)}
            className="flex items-center gap-2 px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            {isPaused ? <Play size={20} /> : <Pause size={20} />}
            {isPaused ? 'Release' : 'Pause'}
          </button>
          
          <button
            onClick={initializeGrid}
            className="flex items-center gap-2 px-4 py-2 bg-gray-500 text-white rounded hover:bg-gray-600"
          >
            <RotateCcw size={20} />
            Reset
          </button>
        </div>

        <div className="grid grid-cols-2 gap-4 mb-4">
          <div className="bg-white p-4 rounded shadow">
            <div className="text-sm text-gray-600">Active</div>
            <div className="text-2xl font-bold text-blue-600">{metrics.active}</div>
          </div>
          <div className="bg-white p-4 rounded shadow">
            <div className="text-sm text-gray-600">Frozen</div>
            <div className="text-2xl font-bold text-red-600">{metrics.frozen}</div>
          </div>
          <div className="bg-white p-4 rounded shadow">
            <div className="text-sm text-gray-600">Kiss Events</div>
            <div className="text-2xl font-bold text-green-600">{metrics.contacts}</div>
          </div>
          <div className="bg-white p-4 rounded shadow">
            <div className="text-sm text-gray-600">Intelligence</div>
            <div className="text-2xl font-bold text-yellow-600">{(metrics.intelligence * 100).toFixed(0)}%</div>
          </div>
          <div className="bg-white p-4 rounded shadow col-span-2">
            <div className="text-sm text-gray-600">Successful 4Ï€ Cycles</div>
            <div className="text-2xl font-bold text-purple-600">{metrics.cycles || 0}</div>
          </div>
        </div>

        <div className="bg-white p-4 rounded shadow mb-4">
          <div className="mb-2">
            <label className="text-sm font-semibold text-gray-700">Columns: {gridSize.cols}</label>
            <input
              type="range"
              min="2"
              max="8"
              value={gridSize.cols}
              onChange={(e) => setGridSize({ ...gridSize, cols: parseInt(e.target.value) })}
              className="w-full"
            />
          </div>
          <div className="mb-2">
            <label className="text-sm font-semibold text-gray-700">Rows: {gridSize.rows}</label>
            <input
              type="range"
              min="2"
              max="6"
              value={gridSize.rows}
              onChange={(e) => setGridSize({ ...gridSize, rows: parseInt(e.target.value) })}
              className="w-full"
            />
          </div>
          <div>
            <label className="text-sm font-semibold text-gray-700">
              Speed: {timeScale.toFixed(1)}x
            </label>
            <input
              type="range"
              min="0.1"
              max="3"
              step="0.1"
              value={timeScale}
              onChange={(e) => setTimeScale(parseFloat(e.target.value))}
              className="w-full"
            />
            <div className="text-xs text-gray-500 mt-1">
              0.1x (slow motion) â†’ 3x (fast forward)
            </div>
          </div>
        </div>

        <div className="bg-white p-4 rounded shadow">
          <canvas
            ref={canvasRef}
            className="border-2 border-gray-300 rounded"
          />
        </div>

        <div className="mt-4 bg-blue-50 p-4 rounded text-sm">
          <h3 className="font-bold mb-2">4Ï€ Spinor Mechanics:</h3>
          <ul className="space-y-1 text-gray-700">
            <li>â€¢ <strong>ðŸ”´ CRITICAL: Connection = Survival</strong> - Isolated toroids die in 1 second</li>
            <li>â€¢ <strong>Full cycle = 720Â°</strong> (two complete rotations to return to quantum state)</li>
            <li>â€¢ <strong>Right (Red):</strong> Expands, speeds up, intelligent flip at 120-240Â°</li>
            <li>â€¢ <strong>Left (Blue):</strong> Contracts, slows down, intelligent flip at 60-120Â°</li>
            <li>â€¢ <strong>Same chirality kiss:</strong> Bump â†’ shrink & reverse (red flash, -5% IQ)</li>
            <li>â€¢ <strong>Opposite chirality kiss:</strong> Amplify â†’ boost (green flash, +10% IQ)</li>
            <li>â€¢ <strong>Intelligence:</strong> Toroids scan neighbors and adapt strategy</li>
            <li>â€¢ <strong>Gold glow:</strong> High intelligence (>60%)</li>
            <li>â€¢ <strong>Gold dots:</strong> Successful 4Ï€ cycles completed</li>
            <li>â€¢ <strong>Bright red:</strong> Dying (never made contact)</li>
          </ul>
        </div>
      </div>
    </div>
  );
};

export default ToroidPlayground;