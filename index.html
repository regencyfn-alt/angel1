<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Angel-1 ¬∑ Faithful Geometry</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { 
  font-family: 'Segoe UI', system-ui, sans-serif; 
  background: #ffffff; 
  color: #333333;
  overflow-x: hidden;
}

#header {
  padding: 20px;
  background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
  border-bottom: 2px solid #cccccc;
}

#header h1 {
  font-size: 28px;
  font-weight: 300;
  letter-spacing: 3px;
  color: #e94560;
  margin-bottom: 10px;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

#header .subtitle {
  font-size: 14px;
  color: #666666;
  letter-spacing: 1px;
}

#main {
  display: flex;
  gap: 20px;
  padding: 20px;
  min-height: calc(100vh - 200px);
  width: 100%;
}

#canvas-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  background: #ffffff;
  padding: 20px;
  position: relative;
  min-width: 0;
}

#grid-scale-controls {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
  padding: 10px;
  background: #f8f8f8;
  border-radius: 6px;
  align-items: center;
  border: 2px solid #e94560;
}

#grid-scale-controls button {
  padding: 8px 16px;
  background: linear-gradient(135deg, #e94560 0%, #d63552 100%);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s;
}

#grid-scale-controls button:hover {
  background: linear-gradient(135deg, #d63552 0%, #c72544 100%);
  transform: translateY(-1px);
  box-shadow: 0 2px 6px rgba(233, 69, 96, 0.3);
}

#grid-scale-controls span {
  font-weight: 600;
  color: #e94560;
  font-size: 16px;
  min-width: 80px;
  text-align: center;
}

#column-controls {
  display: flex;
  gap: 4px;
  margin-bottom: 15px;
  padding: 10px;
  background: #f8f8f8;
  border-radius: 6px;
  flex-wrap: wrap;
  width: 100%;
  justify-content: center;
}

.column-dropdown {
  width: 38px;
  padding: 4px 2px;
  background: #ffffff;
  color: #333333;
  border: 1px solid #cccccc;
  border-radius: 3px;
  font-size: 10px;
  cursor: pointer;
  text-align: center;
}

#svg-canvas {
  background: white;
  border: 1px solid #dddddd;
  border-radius: 4px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  width: 100%;
  height: auto;
}

#sidebar {
  width: 340px;
  min-width: 340px;
  flex-shrink: 0;
  background: #f8f8f8;
  border-radius: 8px;
  padding: 20px;
  display: flex;
  flex-direction: column;
  gap: 20px;
  max-height: calc(100vh - 100px);
  overflow-y: auto;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
}

.control-group {
  background: #ffffff;
  padding: 15px;
  border-radius: 6px;
  border: 1px solid #e0e0e0;
}

.control-group h3 {
  font-size: 14px;
  color: #e94560;
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.metric-row {
  display: flex;
  justify-content: space-between;
  padding: 8px 0;
  border-bottom: 1px solid #f0f0f0;
  font-size: 13px;
}

.metric-row:last-child {
  border-bottom: none;
}

.metric-label {
  color: #666666;
}

.metric-value {
  color: #e94560;
  font-weight: 600;
  font-family: 'Courier New', monospace;
}

button {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #e94560 0%, #d63552 100%);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 1px;
  transition: all 0.3s ease;
  text-transform: uppercase;
}

button:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(233, 69, 96, 0.4);
}

.slider-container {
  margin: 10px 0;
}

.slider-label {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: #666666;
  margin-bottom: 5px;
}

.slider-label span:last-child {
  color: #e94560;
  font-weight: 600;
}

input[type="range"] {
  width: 100%;
  height: 6px;
  background: #e0e0e0;
  border-radius: 3px;
  outline: none;
}

input[type="range"]::-webkit-slider-thumb {
  appearance: none;
  width: 16px;
  height: 16px;
  background: #e94560;
  border-radius: 50%;
  cursor: pointer;
}

input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  background: #e94560;
  border-radius: 50%;
  cursor: pointer;
  border: none;
}

#status-bar {
  padding: 15px 20px;
  background: #f8f8f8;
  border-top: 2px solid #e0e0e0;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.status-item {
  display: flex;
  align-items: center;
  gap: 10px;
  font-size: 13px;
  color: #666666;
}

.status-indicator {
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background: #28a745;
  animation: pulse 2s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}
</style>
<script type='text/javascript' src='https://www.genspark.ai/myghzW3FEYkBBi6-IuXdRsDXAXOQc6rH9Ru8xkC1f_xG8tGZLLvz061OZQ2cfC0n9DC-nQYyC6BMdJS6obObaQodwrOsJPp1uUQMFAqM-4aTRjFsO_Yu0ZImHg3thtTC_j6SE57f1C-OWfutzqftx2eBXOc7eCJsCoPvPeOutpU='></script></head>
<body>

<div id="header">
  <h1>ANGEL-1 ¬∑ FAITHFUL GEOMETRY</h1>
  <div class="subtitle">Bounded Oscillation | mC:rC Ratios | Geometric Interference | Concresence</div>
</div>

<div id="main">
  <div id="canvas-container">
    <div id="grid-scale-controls">
      <button onclick="removeColumn('left')">‚Üê Remove Left</button>
      <button onclick="addColumn('left')">+ Add Left</button>
      <span id="column-count">20 Columns</span>
      <button onclick="addColumn('right')">Add Right +</button>
      <button onclick="removeColumn('right')">Remove Right ‚Üí</button>
    </div>
    
    <div id="column-controls"></div>
    <svg id="svg-canvas"></svg>
  </div>

  <div id="sidebar">
    <div class="control-group">
      <h3>‚ö° Control</h3>
      <button onclick="resetTrial()">Reset to Chaos</button>
      <button onclick="togglePause()" style="margin-top: 10px;" id="btn-pause">Pause</button>
    </div>

    <div class="control-group">
      <h3>üìä Metrics</h3>
      <div class="metric-row">
        <span class="metric-label">Time Steps:</span>
        <span class="metric-value" id="time-steps">0</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Harmony Score:</span>
        <span class="metric-value" id="harmony-score">0%</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Avg Oscillation:</span>
        <span class="metric-value" id="avg-osc">0¬∞</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Chirality Balance:</span>
        <span class="metric-value" id="chirality-balance">50/50</span>
      </div>
    </div>

    <div class="control-group">
      <h3>üéõÔ∏è Parameters</h3>
      <div class="slider-container">
        <div class="slider-label">
          <span>Tick Speed (steps/frame):</span>
          <span id="val-speed">1</span>
        </div>
        <input type="range" id="speed" min="1" max="10" step="1" value="1"
               oninput="document.getElementById('val-speed').textContent = this.value">
      </div>
    </div>

    <div class="control-group">
      <h3>‚öôÔ∏è Girth Controls</h3>
      <div class="slider-container">
        <div class="slider-label">
          <span>T1 Girth:</span>
          <span id="val-girth-t1">8</span>
        </div>
        <input type="range" id="girth-t1" min="2" max="20" step="1" value="8" 
               oninput="document.getElementById('val-girth-t1').textContent = this.value; updateGirths()">
      </div>
      <div class="slider-container">
        <div class="slider-label">
          <span>T2 Girth:</span>
          <span id="val-girth-t2">4</span>
        </div>
        <input type="range" id="girth-t2" min="1" max="10" step="0.5" value="4"
               oninput="document.getElementById('val-girth-t2').textContent = this.value; updateGirths()">
      </div>
      <div class="slider-container">
        <div class="slider-label">
          <span>T3 Girth:</span>
          <span id="val-girth-t3">2</span>
        </div>
        <input type="range" id="girth-t3" min="0.5" max="5" step="0.5" value="2"
               oninput="document.getElementById('val-girth-t3').textContent = this.value; updateGirths()">
      </div>
    </div>

    <div class="control-group">
      <h3>‚ÑπÔ∏è Type Ratios (Fixed)</h3>
      <div class="metric-row">
        <span class="metric-label">T1 (mC:rC):</span>
        <span class="metric-value">1:2 (33% dark)</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">T2 (mC:rC):</span>
        <span class="metric-value">1:1 (50% dark)</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">T3 (mC:rC):</span>
        <span class="metric-value">2:1 (66% dark)</span>
      </div>
    </div>
  </div>
</div>

<div id="status-bar">
  <div class="status-item">
    <div class="status-indicator"></div>
    <span>System Active</span>
  </div>
  <div class="status-item">
    <span id="grid-info">20 columns √ó 9 rows | Faithful Geometry</span>
  </div>
</div>

<script>
// ============================================
// ANGEL-1 FAITHFUL GEOMETRY
// ============================================

const svg = document.getElementById('svg-canvas');
let COLS = 20;
const ROWS = 9;
const SPACING = 40;

function updateCanvasSize() {
  const WIDTH = COLS * SPACING;
  const HEIGHT = ROWS * SPACING;
  svg.setAttribute('width', WIDTH);
  svg.setAttribute('height', HEIGHT);
  svg.setAttribute('viewBox', `0 0 ${WIDTH} ${HEIGHT}`);
}

updateCanvasSize();

// Grid definition
let gridDef = [
  'T3','T3', 'T2','T2','T2', 'T1','T1','T1','T1','T1',
  'T1','T1','T1','T1','T1', 'T2','T2','T2', 'T3','T3'
];

// Mass:Radiance ratios (FIXED per type)
const TYPE_RATIOS = {
  'T1': { mass: 1, radiance: 2 }, // 1:2 = 33% dark, 66% light
  'T2': { mass: 1, radiance: 1 }, // 1:1 = 50% dark, 50% light
  'T3': { mass: 2, radiance: 1 }  // 2:1 = 66% dark, 33% light
};

// Chronon arrays
let chronons = [];
let totalChronons = 0;

// Simulation state
let paused = false;
let timeSteps = 0;

// ============================================
// CHRONON CLASS
// ============================================

class Chronon {
  constructor(col, row, type, boxSize, subCol = 0, subRow = 0) {
    this.col = col;
    this.row = row;
    this.type = type;
    this.boxSize = boxSize;
    this.subCol = subCol;
    this.subRow = subRow;
    
    // Position (center of box)
    this.x = col * SPACING + subCol * boxSize + boxSize/2;
    this.y = row * SPACING + subRow * boxSize + boxSize/2;
    
    // Mass:Radiance ratio (FIXED)
    const ratio = TYPE_RATIOS[type];
    this.massRatio = ratio.mass / (ratio.mass + ratio.radiance);
    this.radianceRatio = ratio.radiance / (ratio.mass + ratio.radiance);
    
    // Physics - Start at 0¬∞ (North)
    this.arcPos = 0; // Current position in oscillation
    this.chirality = Math.random() < 0.5 ? 1 : -1; // 1=right (expand), -1=left (contract)
    this.targetArc = 0; // Where it wants to go (will be set by neighbors)
    
    // Start at MAXIMUM size (touching all neighbors)
    this.radius = boxSize * 0.48;
    this.maxRadius = boxSize * 0.48;
    this.minRadius = boxSize * 0.20;
    
    // Visual
    this.baseGirth = type === 'T3' ? 2 : (type === 'T2' ? 4 : 8);
    this.girth = this.baseGirth;
    this.neighbors = [];
    
    // Collision tracking
    this.collisionFlash = 0;
  }
  
  findNeighbors() {
    this.neighbors = chronons.filter(c => {
      if (c === this) return false;
      if (c.type !== this.type) return false;
      
      const dx = Math.abs(c.x - this.x);
      const dy = Math.abs(c.y - this.y);
      const neighborDist = this.boxSize * 1.5;
      
      return dx <= neighborDist && dy <= neighborDist && (dx + dy) > 0;
    });
  }
  
  update() {
    // BOUNDED OSCILLATION: 0¬∞ ‚Üí ¬±90¬∞ ‚Üí back to 0¬∞
    
    // Check if at 0¬∞ (center position)
    const atCenter = Math.abs(this.arcPos) < 2;
    
    if (atCenter) {
      // AT CENTER: Full size, check neighbors for chirality forcing
      const votes = this.checkNeighborChirality();
      
      // Neighbor majority forces chirality
      if (votes.right > votes.left) {
        if (this.chirality === -1) {
          this.chirality = 1;
          this.collisionFlash = 1.0;
        }
      } else if (votes.left > votes.right) {
        if (this.chirality === 1) {
          this.chirality = -1;
          this.collisionFlash = 1.0;
        }
      }
      // If equal (2/2), keep current chirality
    }
    
    // Move based on chirality (oscillate)
    // Concresence: All types move toward 0¬∞ at same "tick rate"
    // but T3 moves slower so takes more ticks to reach same angle
    let angularVelocity = 3.0; // Base degrees per tick
    
    // Type speed multipliers (concresence)
    if (this.type === 'T1') angularVelocity *= 1.0;
    else if (this.type === 'T2') angularVelocity *= 0.5;
    else if (this.type === 'T3') angularVelocity *= 0.25;
    
    // Move in current chirality direction
    this.arcPos += angularVelocity * this.chirality;
    
    // BOUNCE at ¬±90¬∞ (GEOMETRIC BOUND - can't go further)
    if (Math.abs(this.arcPos) >= 90) {
      this.chirality *= -1; // Reverse direction
      this.arcPos = Math.sign(this.arcPos) * 90; // Clamp to boundary
      this.collisionFlash = 1.0;
    }
    
    // Update radius based on arc position
    // At 0¬∞ = max radius (touching neighbors)
    // At ¬±90¬∞ = min radius (contracted)
    const oscillationFactor = Math.abs(this.arcPos) / 90; // 0 to 1
    this.radius = this.maxRadius - (this.maxRadius - this.minRadius) * oscillationFactor;
    
    // Decay collision flash
    if (this.collisionFlash > 0) {
      this.collisionFlash -= 0.1;
    }
  }
  
  checkNeighborChirality() {
    let leftCount = 0;
    let rightCount = 0;
    
    // Only count neighbors also near center (touching)
    this.neighbors.forEach(n => {
      if (Math.abs(n.arcPos) < 15) { // Near center threshold
        if (n.chirality === 1) rightCount++;
        else leftCount++;
      }
    });
    
    return { left: leftCount, right: rightCount };
  }
  
  draw() {
    let elements = [];
    
    // Collision flash
    if (this.collisionFlash > 0) {
      const flash = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      flash.setAttribute('cx', this.x);
      flash.setAttribute('cy', this.y);
      flash.setAttribute('r', this.radius + 3);
      flash.setAttribute('fill', 'none');
      flash.setAttribute('stroke', '#ffff00');
      flash.setAttribute('stroke-width', '2');
      flash.setAttribute('opacity', this.collisionFlash * 0.8);
      elements.push(flash);
    }
    
    const outerR = this.radius;
    const innerR = Math.max(0.5, this.radius - this.girth);
    
    // Calculate rotation angle for visual
    const rotAngle = (this.arcPos * Math.PI / 180);
    
    // Draw SEGMENTED torus showing mass:radiance ratio
    // The torus is divided into dark (mass) and light (radiance) sections
    
    // Dark section (mass) - angle based on massRatio
    const darkAngle = this.massRatio * 360; // degrees
    const darkArc = this.createArcPath(this.x, this.y, outerR, innerR, rotAngle, darkAngle);
    darkArc.setAttribute('fill', '#1a1a1a');
    darkArc.setAttribute('stroke', '#333');
    darkArc.setAttribute('stroke-width', '0.5');
    elements.push(darkArc);
    
    // Light section (radiance) - remaining angle
    const lightStartAngle = rotAngle + (darkAngle * Math.PI / 180);
    const lightAngle = this.radianceRatio * 360;
    const lightArc = this.createArcPath(this.x, this.y, outerR, innerR, lightStartAngle, lightAngle);
    lightArc.setAttribute('fill', '#e8e8e8');
    lightArc.setAttribute('stroke', '#666');
    lightArc.setAttribute('stroke-width', '0.5');
    elements.push(lightArc);
    
    // Red center node
    const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    node.setAttribute('cx', this.x);
    node.setAttribute('cy', this.y);
    node.setAttribute('r', '1.5');
    node.setAttribute('fill', 'red');
    elements.push(node);
    
    // Direction indicator (shows chirality)
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', this.x);
    line.setAttribute('y1', this.y);
    line.setAttribute('x2', this.x + outerR * Math.cos(rotAngle));
    line.setAttribute('y2', this.y + outerR * Math.sin(rotAngle));
    line.setAttribute('stroke', this.chirality === 1 ? '#00ff00' : '#ff0000');
    line.setAttribute('stroke-width', '1');
    line.setAttribute('opacity', '0.6');
    elements.push(line);
    
    return elements;
  }
  
  createArcPath(cx, cy, outerR, innerR, startAngle, arcDegrees) {
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    
    const arcRadians = arcDegrees * Math.PI / 180;
    const endAngle = startAngle + arcRadians;
    
    // Outer arc points
    const x1 = cx + outerR * Math.cos(startAngle);
    const y1 = cy + outerR * Math.sin(startAngle);
    const x2 = cx + outerR * Math.cos(endAngle);
    const y2 = cy + outerR * Math.sin(endAngle);
    
    // Inner arc points (reversed)
    const x3 = cx + innerR * Math.cos(endAngle);
    const y3 = cy + innerR * Math.sin(endAngle);
    const x4 = cx + innerR * Math.cos(startAngle);
    const y4 = cy + innerR * Math.sin(startAngle);
    
    const largeArc = arcDegrees > 180 ? 1 : 0;
    
    const d = `
      M ${x1} ${y1}
      A ${outerR} ${outerR} 0 ${largeArc} 1 ${x2} ${y2}
      L ${x3} ${y3}
      A ${innerR} ${innerR} 0 ${largeArc} 0 ${x4} ${y4}
      Z
    `;
    
    path.setAttribute('d', d);
    return path;
  }
}

// ============================================
// GRID SCALING
// ============================================

function addColumn(side) {
  if (side === 'left') {
    gridDef.unshift('T1');
  } else {
    gridDef.push('T1');
  }
  COLS = gridDef.length;
  updateCanvasSize();
  rebuildGrid();
  updateColumnCount();
}

function removeColumn(side) {
  if (COLS <= 4) {
    alert('Minimum 4 columns required!');
    return;
  }
  
  if (side === 'left') {
    gridDef.shift();
  } else {
    gridDef.pop();
  }
  COLS = gridDef.length;
  updateCanvasSize();
  rebuildGrid();
  updateColumnCount();
}

function updateColumnCount() {
  document.getElementById('column-count').textContent = COLS + ' Columns';
  document.getElementById('grid-info').textContent = 
    `${COLS} columns √ó ${ROWS} rows | ${totalChronons} chronons`;
}

// ============================================
// INITIALIZATION
// ============================================

function initGrid() {
  chronons = [];
  
  for (let c = 0; c < COLS; c++) {
    const type = gridDef[c];
    let boxSize, subsPerCol;
    
    if (type === 'T1') {
      boxSize = SPACING;
      subsPerCol = 1;
    } else if (type === 'T2') {
      boxSize = SPACING / 2;
      subsPerCol = 2;
    } else {
      boxSize = SPACING / 3;
      subsPerCol = 3;
    }
    
    for (let r = 0; r < ROWS; r++) {
      for (let subR = 0; subR < subsPerCol; subR++) {
        for (let subC = 0; subC < subsPerCol; subC++) {
          const chronon = new Chronon(c, r, type, boxSize, subC, subR);
          chronons.push(chronon);
        }
      }
    }
  }
  
  chronons.forEach(c => c.findNeighbors());
  updateGirths();
  
  totalChronons = chronons.length;
  updateColumnCount();
  console.log(`Initialized ${totalChronons} chronons`);
}

function updateGirths() {
  const t1Girth = parseFloat(document.getElementById('girth-t1').value);
  const t2Girth = parseFloat(document.getElementById('girth-t2').value);
  const t3Girth = parseFloat(document.getElementById('girth-t3').value);
  
  chronons.forEach(c => {
    if (c.type === 'T1') c.girth = t1Girth;
    else if (c.type === 'T2') c.girth = t2Girth;
    else if (c.type === 'T3') c.girth = t3Girth;
  });
}

function createColumnControls() {
  const container = document.getElementById('column-controls');
  container.innerHTML = '';
  
  for (let i = 0; i < COLS; i++) {
    const select = document.createElement('select');
    select.className = 'column-dropdown';
    select.innerHTML = `
      <option value="T1" ${gridDef[i] === 'T1' ? 'selected' : ''}>T1</option>
      <option value="T2" ${gridDef[i] === 'T2' ? 'selected' : ''}>T2</option>
      <option value="T3" ${gridDef[i] === 'T3' ? 'selected' : ''}>T3</option>
    `;
    select.onchange = function() {
      gridDef[i] = this.value;
      rebuildGrid();
    };
    container.appendChild(select);
  }
}

function rebuildGrid() {
  initGrid();
  resetTrial();
  createColumnControls();
}

// ============================================
// SIMULATION
// ============================================

function step() {
  if (paused) return;
  
  timeSteps++;
  chronons.forEach(c => c.update());
  
  updateUI();
}

function updateUI() {
  document.getElementById('time-steps').textContent = timeSteps;
  
  // Calculate harmony score
  let oppositeCount = 0;
  let totalPairs = 0;
  let totalOscillation = 0;
  let leftCount = 0;
  let rightCount = 0;
  
  chronons.forEach(c => {
    totalOscillation += Math.abs(c.arcPos);
    if (c.chirality === 1) rightCount++;
    else leftCount++;
    
    c.neighbors.forEach(n => {
      totalPairs++;
      // Check if at center and opposite chirality
      if (Math.abs(c.arcPos) < 15 && Math.abs(n.arcPos) < 15) {
        if (c.chirality !== n.chirality) {
          oppositeCount++;
        }
      }
    });
  });
  
  const harmonyScore = totalPairs > 0 ? (oppositeCount / totalPairs * 100) : 0;
  document.getElementById('harmony-score').textContent = harmonyScore.toFixed(1) + '%';
  
  const avgOsc = totalOscillation / chronons.length;
  document.getElementById('avg-osc').textContent = avgOsc.toFixed(1) + '¬∞';
  
  document.getElementById('chirality-balance').textContent = 
    `${leftCount}/${rightCount}`;
}

// ============================================
// CONTROLS
// ============================================

function resetTrial() {
  chronons.forEach(c => {
    c.arcPos = Math.random() * 60 - 30; // Random start ¬±30¬∞
    c.chirality = Math.random() < 0.5 ? 1 : -1;
    c.collisionFlash = 0;
  });
  
  updateGirths();
  timeSteps = 0;
  paused = false;
  document.getElementById('btn-pause').textContent = 'Pause';
}

function togglePause() {
  paused = !paused;
  document.getElementById('btn-pause').textContent = paused ? 'Resume' : 'Pause';
}

// ============================================
// RENDERING
// ============================================

function draw() {
  while (svg.firstChild) {
    svg.removeChild(svg.firstChild);
  }
  
  const WIDTH = COLS * SPACING;
  const HEIGHT = ROWS * SPACING;
  
  // Draw grid
  const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  gridGroup.setAttribute('opacity', '0.15');
  
  for (let i = 0; i <= COLS; i++) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', i * SPACING);
    line.setAttribute('y1', 0);
    line.setAttribute('x2', i * SPACING);
    line.setAttribute('y2', HEIGHT);
    line.setAttribute('stroke', '#cccccc');
    line.setAttribute('stroke-width', '1');
    gridGroup.appendChild(line);
  }
  
  for (let i = 0; i <= ROWS; i++) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', 0);
    line.setAttribute('y1', i * SPACING);
    line.setAttribute('x2', WIDTH);
    line.setAttribute('y2', i * SPACING);
    line.setAttribute('stroke', '#cccccc');
    line.setAttribute('stroke-width', '1');
    gridGroup.appendChild(line);
  }
  
  svg.appendChild(gridGroup);
  
  // Draw chronons
  chronons.forEach(c => {
    const elements = c.draw();
    elements.forEach(el => svg.appendChild(el));
  });
}

// ============================================
// MAIN LOOP
// ============================================

function animate() {
  const speed = parseInt(document.getElementById('speed').value);
  for (let i = 0; i < speed; i++) {
    step();
  }
  draw();
  requestAnimationFrame(animate);
}

// ============================================
// START
// ============================================

createColumnControls();
initGrid();
resetTrial();
animate();

console.log('üåÄ Angel-1 Faithful Geometry initialized');
console.log(`üìä ${totalChronons} chronons | Bounded oscillation with mC:rC ratios`);
</script>

</body>
</html>