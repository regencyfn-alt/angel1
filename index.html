-<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ANGEL-1 ¬∑ Michron Physics</title>
<link rel="stylesheet" href="shared.css">
<style>
.simulator-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  padding: 20px;
  max-width: 1400px;
  margin: 0 auto;
}

.canvas-wrapper {
  width: 100%;
  display: flex;
  justify-content: center;
  overflow: hidden;
}

#canvas {
  border: 2px solid #22303d;
  border-radius: 8px;
  max-width: 100%;
  height: auto;
}

.controls-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
  gap: 16px;
  width: 100%;
}

.grid-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  margin-bottom: 16px;
}

.grid-controls button {
  padding: 8px 16px;
  background: linear-gradient(135deg, #1e3a5f 0%, #1a1f2e 100%);
  border: 1px solid #22303d;
  border-radius: 4px;
  color: #e8ecef;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
}

.grid-controls button:hover {
  border-color: #60a5fa;
  transform: translateY(-1px);
}

.grid-controls span {
  color: #60a5fa;
  font-weight: 600;
  min-width: 80px;
  text-align: center;
}

.playback {
  display: flex;
  gap: 8px;
}

.playback button {
  flex: 1;
  padding: 10px;
  border: 1px solid #22303d;
  border-radius: 6px;
  color: #e8ecef;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.playback button.primary {
  background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
  border-color: #60a5fa;
}

.playback button.secondary {
  background: linear-gradient(135deg, #1e3a5f 0%, #1a1f2e 100%);
}

.slider-group {
  margin-bottom: 12px;
}

.slider-group:last-child {
  margin-bottom: 0;
}

.slider-group label {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: #d1d5db;
  margin-bottom: 4px;
}

.slider-group .value {
  color: #60a5fa;
  font-family: 'Courier New', monospace;
  font-weight: 600;
}

input[type="range"] {
  width: 100%;
  height: 4px;
  border-radius: 2px;
  background: #0b0f14;
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
  cursor: pointer;
}

.metrics-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
}

.metric {
  background: #0b0f14;
  border-radius: 4px;
  padding: 8px;
  text-align: center;
}

.metric .label {
  font-size: 10px;
  color: #9ca3af;
  margin-bottom: 2px;
}

.metric .value {
  font-size: 14px;
  font-weight: 700;
  color: #10b981;
  font-family: 'Courier New', monospace;
}

@media (max-width: 600px) {
  .controls-grid {
    grid-template-columns: 1fr;
  }
  
  .metrics-grid {
    grid-template-columns: repeat(2, 1fr);
  }
  
  .grid-controls span {
    min-width: 60px;
    font-size: 11px;
  }
}
</style>
</head>
<body>

<nav class="nav">
  <div class="nav-brand">MICHRON PHYSICS</div>
  <div class="nav-links">
    <a href="index.html" class="active">Classic</a>
    <a href="torsion-field.html">Torsion Field</a>
     <a href="breath-field.html">Breath Field</a>
    <a href="chronos.html">Chronos</a>
    <a href="square_plaquettes.html">Square Flip</a>
    <a href="tri-flip.html">Tri-Flip</a>
  </div>
</nav>

<div class="simulator-container">
  
  <!-- Grid Size Controls -->
  <div class="grid-controls">
    <button onclick="removeColumn()">‚àí Col</button>
    <span id="colCount">16</span>
    <button onclick="addColumn()">+ Col</button>
    <button onclick="removeRow()">‚àí Row</button>
    <span id="rowCount">12</span>
    <button onclick="addRow()">+ Row</button>
  </div>

  <!-- Canvas -->
  <div class="canvas-wrapper">
    <canvas id="canvas"></canvas>
  </div>

  <!-- Controls Below -->
  <div class="controls-grid">
    
    <!-- Control Panel -->
    <div class="panel">
      <h3>‚ö° Control</h3>
      <div class="playback">
        <button id="pauseBtn" class="primary" onclick="togglePause()">Pause</button>
        <button class="secondary" onclick="reset()">Reset</button>
      </div>
    </div>

    <!-- Metrics Panel -->
    <div class="panel">
      <h3>üìä Metrics</h3>
      <div class="metrics-grid">
        <div class="metric">
          <div class="label">Steps</div>
          <div class="value" id="metricTime">0</div>
        </div>
        <div class="metric">
          <div class="label">Torsion</div>
          <div class="value" id="metricTorsion">0.00</div>
        </div>
        <div class="metric">
          <div class="label">Transitions</div>
          <div class="value" id="metricTransitions">0</div>
        </div>
        <div class="metric">
          <div class="label" style="color:#3bd5ff;">T1</div>
          <div class="value" id="metricT1" style="color:#3bd5ff;">0</div>
        </div>
        <div class="metric">
          <div class="label" style="color:#ffd86a;">T2</div>
          <div class="value" id="metricT2" style="color:#ffd86a;">0</div>
        </div>
        <div class="metric">
          <div class="label" style="color:#ff4b6a;">T3</div>
          <div class="value" id="metricT3" style="color:#ff4b6a;">0</div>
        </div>
      </div>
    </div>

    <!-- Speed Panel -->
    <div class="panel">
      <h3>‚è±Ô∏è Speed</h3>
      <div class="slider-group">
        <label>
          <span>Simulation Speed</span>
          <span class="value" id="speedVal">1.0x</span>
        </label>
        <input type="range" id="speed" min="0.25" max="4" step="0.25" value="1" oninput="updateSpeed()">
      </div>
    </div>

    <!-- Wave Dynamics Panel -->
    <div class="panel">
      <h3>üåä Wave Dynamics</h3>
      <div class="slider-group">
        <label>
          <span>Wave Frequency</span>
          <span class="value" id="waveFreqVal">0.90</span>
        </label>
        <input type="range" id="waveFreq" min="0.3" max="2.0" step="0.1" value="0.9" oninput="updateWaveFreq()">
      </div>
      <div class="slider-group">
        <label>
          <span>Swirl Factor</span>
          <span class="value" id="swirlVal">0.30</span>
        </label>
        <input type="range" id="swirl" min="0" max="1" step="0.05" value="0.3" oninput="updateSwirl()">
      </div>
      <div class="slider-group">
        <label>
          <span>Jitter</span>
          <span class="value" id="jitterVal">0.20</span>
        </label>
        <input type="range" id="jitter" min="0" max="0.5" step="0.05" value="0.2" oninput="updateJitter()">
      </div>
    </div>

    <!-- Torsion Thresholds Panel -->
    <div class="panel">
      <h3>üåÄ Torsion Thresholds</h3>
      <div class="slider-group">
        <label>
          <span>T1‚ÜîT2</span>
          <span class="value" id="t12Val">0.50</span>
        </label>
        <input type="range" id="t12" min="0.2" max="0.6" step="0.05" value="0.5" oninput="updateT12()">
      </div>
      <div class="slider-group">
        <label>
          <span>T2‚ÜîT3</span>
          <span class="value" id="t23Val">0.70</span>
        </label>
        <input type="range" id="t23" min="0.5" max="0.9" step="0.05" value="0.7" oninput="updateT23()">
      </div>
    </div>

    <!-- Girth Panel -->
    <div class="panel">
      <h3>üîß Girth</h3>
      <div class="slider-group">
        <label>
          <span>Master Girth</span>
          <span class="value" id="girthVal">1.0x</span>
        </label>
        <input type="range" id="girth" min="0.5" max="2" step="0.1" value="1" oninput="updateGirth()">
      </div>
    </div>

  </div>
</div>

<script>
// === CONFIGURATION ===
let COLS = 16;
let ROWS = 12;
let CELL_SIZE = 40;

// Auto-scale based on viewport
function calculateCellSize() {
  const maxWidth = Math.min(window.innerWidth - 40, 1200);
  const maxHeight = window.innerHeight * 0.55;
  const sizeByWidth = Math.floor(maxWidth / COLS);
  const sizeByHeight = Math.floor(maxHeight / ROWS);
  CELL_SIZE = Math.min(sizeByWidth, sizeByHeight, 50);
  CELL_SIZE = Math.max(CELL_SIZE, 24); // minimum
}

// T-Class specifications
const T_SPECS = {
  T1: { girth: 0.25, mass: 0.33, torsion: 0.2, color: '#3bd5ff' },
  T2: { girth: 0.45, mass: 0.50, torsion: 0.55, color: '#ffd86a' },
  T3: { girth: 0.65, mass: 0.90, torsion: 0.85, color: '#ff4b6a' }
};

// === STATE ===
let isPaused = false;
let steps = 0;
let totalTransitions = 0;
let cells = [];

// Parameters
let simSpeed = 1.0;
let waveFreq = 0.9;
let swirlFactor = 0.3;
let jitter = 0.2;
let t12Threshold = 0.5;
let t23Threshold = 0.7;
let girthMult = 1.0;

const BG_COLOR = '#0b0f14';
const GRID_COLOR = '#182034';
const MASS_COLOR = '#1a1a1a';
const RADIANCE_COLOR = '#e8e8e8';

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let lastTime = null;

// === CELL CLASS ===
class Cell {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.state = 'T1';
    this.phase = Math.random() * Math.PI * 2;
    this.torsion = T_SPECS.T1.torsion;
    this.localTorsion = 0;
    this.wave = 0;
    this.swirl = 0;
  }
  
  get spec() { return T_SPECS[this.state]; }
  get dx() { return this.x - (COLS - 1) / 2; }
  get dy() { return this.y - (ROWS - 1) / 2; }
  get r() { return Math.sqrt(this.dx * this.dx + this.dy * this.dy); }
  get angle() { return Math.atan2(this.dy, this.dx); }
}

// === INITIALIZATION ===
function init() {
  calculateCellSize();
  cells = [];
  
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      cells.push(new Cell(x, y));
    }
  }
  
  canvas.width = COLS * CELL_SIZE;
  canvas.height = ROWS * CELL_SIZE;
  
  steps = 0;
  totalTransitions = 0;
  lastTime = null;
  
  document.getElementById('colCount').textContent = COLS;
  document.getElementById('rowCount').textContent = ROWS;
  
  draw();
}

// === GRID CONTROLS ===
function addColumn() { if (COLS < 24) { COLS++; init(); } }
function removeColumn() { if (COLS > 6) { COLS--; init(); } }
function addRow() { if (ROWS < 18) { ROWS++; init(); } }
function removeRow() { if (ROWS > 4) { ROWS--; init(); } }

// === GET NEIGHBORS ===
function getNeighbors(cell) {
  const neighbors = [];
  const coords = [
    [cell.x - 1, cell.y], [cell.x + 1, cell.y],
    [cell.x, cell.y - 1], [cell.x, cell.y + 1]
  ];
  for (const [nx, ny] of coords) {
    if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
      neighbors.push(cells[ny * COLS + nx]);
    }
  }
  return neighbors;
}

// === EVOLUTION ===
function evolve(dt) {
  let transitionsThisFrame = 0;
  
  for (const cell of cells) {
    cell.wave = Math.sin(cell.r * waveFreq - cell.phase) * 0.5 + 0.5;
    cell.swirl = Math.sin(cell.angle + cell.phase * swirlFactor) * 0.5 + 0.5;
    
    const neighbors = getNeighbors(cell);
    let higherNeighbors = 0;
    for (const n of neighbors) {
      if (n.state === 'T2' || n.state === 'T3') higherNeighbors++;
    }
    const neighborInfluence = higherNeighbors / Math.max(1, neighbors.length);
    
    const noise = (Math.random() - 0.5) * jitter;
    cell.localTorsion = 0.5 * cell.wave + 0.3 * cell.swirl + 0.4 * neighborInfluence + noise;
    cell.localTorsion = Math.max(0, Math.min(1, cell.localTorsion));
  }
  
  for (const cell of cells) {
    const oldState = cell.state;
    
    if (cell.localTorsion >= t23Threshold) cell.state = 'T3';
    else if (cell.localTorsion >= t12Threshold) cell.state = 'T2';
    else cell.state = 'T1';
    
    if (cell.state !== oldState) transitionsThisFrame++;
    
    cell.torsion = T_SPECS[cell.state].torsion;
    cell.phase += dt * 2.0;
  }
  
  totalTransitions += transitionsThisFrame;
  steps++;
}

// === DRAWING ===
function drawCell(cell) {
  const cx = cell.x * CELL_SIZE + CELL_SIZE / 2;
  const cy = cell.y * CELL_SIZE + CELL_SIZE / 2;
  const spec = cell.spec;
  
  const pulse = 1 + 0.15 * Math.sin(cell.phase);
  const majorR = CELL_SIZE * 0.42 * pulse;
  const girth = spec.girth * girthMult * CELL_SIZE * 0.25;
  const minorR = Math.max(3, majorR - girth);
  const rotation = cell.angle + cell.phase * swirlFactor * 0.5;
  
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rotation);
  
  const tubeThickness = majorR - minorR;
  const creepAmount = cell.localTorsion * 0.4;
  const massThickness = tubeThickness * (0.25 + creepAmount * spec.mass);
  const massOuterR = minorR + massThickness;
  
  const massAngle = spec.mass * 360;
  const massStart = 90 - massAngle / 2;
  const massEnd = 90 + massAngle / 2;
  
  const alpha = 0.7 + cell.wave * 0.3;
  
  // Radiance
  ctx.beginPath();
  ctx.arc(0, 0, majorR, 0, Math.PI * 2);
  ctx.arc(0, 0, minorR, Math.PI * 2, 0, true);
  ctx.closePath();
  ctx.fillStyle = RADIANCE_COLOR;
  ctx.globalAlpha = alpha;
  ctx.fill();
  ctx.globalAlpha = 1.0;
  
  ctx.strokeStyle = spec.color;
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Mass on inner rim
  ctx.beginPath();
  ctx.arc(0, 0, massOuterR, massStart * Math.PI / 180, massEnd * Math.PI / 180);
  ctx.arc(0, 0, minorR, massEnd * Math.PI / 180, massStart * Math.PI / 180, true);
  ctx.closePath();
  ctx.fillStyle = MASS_COLOR;
  ctx.fill();
  
  // Creep tendrils
  if (creepAmount > 0.1) {
    const tendrilWidth = 10 * Math.PI / 180;
    const tendrilHeight = tubeThickness * creepAmount * 1.2;
    
    ctx.beginPath();
    ctx.arc(0, 0, minorR + tendrilHeight, (massStart - tendrilWidth) * Math.PI / 180, massStart * Math.PI / 180);
    ctx.arc(0, 0, minorR, massStart * Math.PI / 180, (massStart - tendrilWidth) * Math.PI / 180, true);
    ctx.closePath();
    ctx.fill();
    
    ctx.beginPath();
    ctx.arc(0, 0, minorR + tendrilHeight, massEnd * Math.PI / 180, (massEnd + tendrilWidth) * Math.PI / 180);
    ctx.arc(0, 0, minorR, (massEnd + tendrilWidth) * Math.PI / 180, massEnd * Math.PI / 180, true);
    ctx.closePath();
    ctx.fill();
  }
  
  ctx.beginPath();
  ctx.arc(0, 0, minorR, 0, Math.PI * 2);
  ctx.strokeStyle = spec.color;
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.5;
  ctx.stroke();
  ctx.globalAlpha = 1.0;
  
  ctx.restore();
}

function draw() {
  ctx.fillStyle = BG_COLOR;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.strokeStyle = GRID_COLOR;
  ctx.lineWidth = 1;
  
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath();
    ctx.moveTo(x * CELL_SIZE + 0.5, 0);
    ctx.lineTo(x * CELL_SIZE + 0.5, canvas.height);
    ctx.stroke();
  }
  
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * CELL_SIZE + 0.5);
    ctx.lineTo(canvas.width, y * CELL_SIZE + 0.5);
    ctx.stroke();
  }
  
  for (const cell of cells) {
    drawCell(cell);
  }
  
  updateMetrics();
}

function updateMetrics() {
  document.getElementById('metricTime').textContent = steps;
  const avgTorsion = cells.reduce((sum, c) => sum + c.localTorsion, 0) / cells.length;
  document.getElementById('metricTorsion').textContent = avgTorsion.toFixed(2);
  
  let t1 = 0, t2 = 0, t3 = 0;
  for (const cell of cells) {
    if (cell.state === 'T1') t1++;
    else if (cell.state === 'T2') t2++;
    else t3++;
  }
  
  document.getElementById('metricT1').textContent = t1;
  document.getElementById('metricT2').textContent = t2;
  document.getElementById('metricT3').textContent = t3;
  document.getElementById('metricTransitions').textContent = totalTransitions;
}

// === UI CONTROLS ===
function togglePause() {
  isPaused = !isPaused;
  document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
}

function reset() { init(); }

function updateSpeed() {
  simSpeed = parseFloat(document.getElementById('speed').value);
  document.getElementById('speedVal').textContent = simSpeed.toFixed(2) + 'x';
}

function updateWaveFreq() {
  waveFreq = parseFloat(document.getElementById('waveFreq').value);
  document.getElementById('waveFreqVal').textContent = waveFreq.toFixed(2);
}

function updateSwirl() {
  swirlFactor = parseFloat(document.getElementById('swirl').value);
  document.getElementById('swirlVal').textContent = swirlFactor.toFixed(2);
}

function updateJitter() {
  jitter = parseFloat(document.getElementById('jitter').value);
  document.getElementById('jitterVal').textContent = jitter.toFixed(2);
}

function updateT12() {
  t12Threshold = parseFloat(document.getElementById('t12').value);
  document.getElementById('t12Val').textContent = t12Threshold.toFixed(2);
}

function updateT23() {
  t23Threshold = parseFloat(document.getElementById('t23').value);
  document.getElementById('t23Val').textContent = t23Threshold.toFixed(2);
}

function updateGirth() {
  girthMult = parseFloat(document.getElementById('girth').value);
  document.getElementById('girthVal').textContent = girthMult.toFixed(1) + 'x';
}

// === RESIZE HANDLER ===
window.addEventListener('resize', () => {
  calculateCellSize();
  canvas.width = COLS * CELL_SIZE;
  canvas.height = ROWS * CELL_SIZE;
});

// === ANIMATION LOOP ===
function animate(timestamp) {
  if (lastTime === null) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  
  if (!isPaused) evolve(dt * simSpeed);
  draw();
  requestAnimationFrame(animate);
}

// === START ===
init();
requestAnimationFrame(animate);
</script>

</body>
</html>
