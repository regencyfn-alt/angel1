<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta http-equiv="x-ua-compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Angel-1 Chronon Template ¬∑ Structured Spacetime Grid</title>
<style>
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: system-ui, -apple-system, sans-serif;
    background: #0b0f14;
    color: #e8ecef;
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  
  header {
    background: linear-gradient(135deg, #1a1f2e 0%, #0f1620 100%);
    border-bottom: 2px solid #22303d;
    padding: 12px 24px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.3);
  }
  
  h1 {
    font-size: 24px;
    font-weight: 600;
    background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 4px;
  }
  
  .subtitle {
    font-size: 12px;
    color: #9ca3af;
    font-weight: 400;
  }
  
  main {
    flex: 1;
    position: relative;
    overflow: hidden;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  
  svg {
    width: 100%;
    height: 100%;
    display: block;
  }
  
  footer {
    background: #0f1620;
    border-top: 2px solid #22303d;
    padding: 12px 24px;
    box-shadow: 0 -2px 8px rgba(0,0,0,0.3);
  }
  
  .controls-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 10px 20px;
    max-width: 1400px;
    margin: 0 auto;
  }
  
  .control-group {
    display: flex;
    flex-direction: column;
    gap: 4px;
  }
  
  .control-group.highlight {
    background: rgba(96, 165, 250, 0.1);
    padding: 6px;
    border-radius: 6px;
    border: 1px solid rgba(96, 165, 250, 0.3);
  }
  
  .control-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 12px;
    font-weight: 500;
    color: #d1d5db;
  }
  
  .control-value {
    font-size: 11px;
    color: #60a5fa;
    font-family: 'Courier New', monospace;
    font-weight: 600;
  }
  
  input[type=range] {
    width: 100%;
    height: 5px;
    border-radius: 3px;
    background: #1a1f2e;
    outline: none;
    -webkit-appearance: none;
  }
  
  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
    cursor: pointer;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }
  
  input[type=range]::-moz-range-thumb {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 4px rgba(0,0,0,0.3);
  }
  
  .button-group {
    display: flex;
    gap: 6px;
    margin-bottom: 12px;
    flex-wrap: wrap;
  }
  
  button {
    padding: 8px 16px;
    background: linear-gradient(135deg, #1e3a5f 0%, #1a1f2e 100%);
    border: 1px solid #22303d;
    border-radius: 6px;
    color: #e8ecef;
    font-size: 13px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
    font-family: inherit;
  }
  
  button:hover {
    background: linear-gradient(135deg, #2d4a70 0%, #22303d 100%);
    border-color: #60a5fa;
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(96, 165, 250, 0.2);
  }
  
  button:active {
    transform: translateY(0);
  }
  
  button.primary {
    background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
    border-color: #60a5fa;
  }
  
  button.primary:hover {
    background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
  }
  
  button.danger {
    background: linear-gradient(135deg, #f87171 0%, #ef4444 100%);
    border-color: #f87171;
  }
  
  button.danger:hover {
    background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  }
  
  .stats {
    position: absolute;
    top: 12px;
    right: 12px;
    background: rgba(15, 22, 32, 0.9);
    backdrop-filter: blur(8px);
    border: 1px solid #22303d;
    border-radius: 8px;
    padding: 10px 14px;
    font-size: 11px;
    color: #9ca3af;
    line-height: 1.6;
    font-family: 'Courier New', monospace;
  }
  
  .stats-value {
    color: #10b981;
    font-weight: 600;
  }
  
  .legend {
    position: absolute;
    bottom: 12px;
    left: 12px;
    background: rgba(15, 22, 32, 0.9);
    backdrop-filter: blur(8px);
    border: 1px solid #22303d;
    border-radius: 8px;
    padding: 10px 14px;
    font-size: 11px;
    color: #9ca3af;
    line-height: 1.8;
    font-family: 'Courier New', monospace;
  }
  
  .legend-item {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  
  .legend-swatch {
    width: 40px;
    height: 14px;
    border-radius: 3px;
    border: 1px solid #60a5fa;
  }
</style>
<script type='text/javascript' src='https://www.genspark.ai/szhVmKJbm53QE7VFHVP7NlxYRC03FNKSZhsMEkZ1lzHfNpRcxLCE8WtAjWom-bOHa68GJgtANm0myc3X_Lf1qH-At9d5RCsHiyHa1BYIa-QgQKPQTcKQJ6pRFKxiUtO8pSOyvyIHcWfNKggILUwbBZVlkTb5RWfw_XE_cn85vpY='></script></head>
<body>

<header>
  <h1>Angel-1 Chronon Template ¬∑ Axioms of Proximity & Connection</h1>
  <div class="subtitle">20√ó9 Grid ¬∑ Dense T3 Bridges ¬∑ Medium T2 Zones ¬∑ Sparse T1 Core ¬∑ Size Gradient Visible</div>
</header>

<main>
  <svg id="v" viewBox="-620 -280 1240 560"></svg>
  <div class="stats" id="stats">
    <div>Time Steps: <span class="stats-value" id="stat-t">0</span></div>
    <div>Chronons: <span class="stats-value" id="stat-count">0</span></div>
    <div>T1: <span class="stats-value" id="stat-t1">0</span> | T2: <span class="stats-value" id="stat-t2">0</span> | T3: <span class="stats-value" id="stat-t3-count">0</span></div>
    <div>T3 Speed: <span class="stats-value" id="stat-t3">0.167√ó</span></div>
    <div>Radiance Wash: <span class="stats-value" id="stat-wash">OFF</span></div>
  </div>
  
  <div class="legend">
    <div><strong>Chronon Types:</strong></div>
    <div class="legend-item">
      <div class="legend-swatch" style="background: linear-gradient(to right, #e8e8e8 83%, #1a1a1a 17%);"></div>
      <span>T1: 60√ó60 (thin, 300¬∞W+60¬∞B)</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch" style="background: linear-gradient(to right, #999 50%, #444 50%);"></div>
      <span>T2: 30√ó30 (medium, 180¬∞ each)</span>
    </div>
    <div class="legend-item">
      <div class="legend-swatch" style="background: linear-gradient(to right, #1a1a1a 83%, #e8e8e8 17%);"></div>
      <span>T3: 15√ó15 (thick, 300¬∞B+60¬∞W)</span>
    </div>
    <div style="margin-top: 8px; color: #f87171;">‚óè Red nodes = inert polarity</div>
  </div>
</main>

<footer>
  <div class="button-group">
    <button id="p" class="primary">Pause</button>
    <button id="r">Reset</button>
    <button id="wash" class="danger">Toggle Radiance Wash</button>
    <button id="proton" style="background: linear-gradient(135deg, #10b981 0%, #059669 100%);">üî´ Proton Gun (Click Grid)</button>
    <button id="save">Save PNG</button>
  </div>
  
  <div class="controls-grid">
    <div class="control-group highlight">
      <div class="control-label">
        <span>üîç Zoom Level</span>
        <span class="control-value" id="val-zoom">1.00</span>
      </div>
      <input id="zoom" type="range" min="0.5" max="3" step="0.1" value="1">
    </div>
    
    <div class="control-group">
      <div class="control-label">
        <span>Œ± (Linear Dispersion)</span>
        <span class="control-value" id="val-a">0.90</span>
      </div>
      <input id="a" type="range" min="0.1" max="1.5" step="0.01" value="0.9">
    </div>
    
    <div class="control-group">
      <div class="control-label">
        <span>Œ≤ (Nonlinearity)</span>
        <span class="control-value" id="val-b">0.35</span>
      </div>
      <input id="b" type="range" min="0" max="1" step="0.01" value="0.35">
    </div>
    
    <div class="control-group">
      <div class="control-label">
        <span>Speed (Steps/Frame)</span>
        <span class="control-value" id="val-s">4</span>
      </div>
      <input id="s" type="range" min="1" max="20" step="1" value="4">
    </div>
  </div>
</footer>

<script>
// Chronon Template Grid Configuration
const COLS = 20;
const ROWS_T1 = 9;
const SPACING_T1 = 60;

// Physics parameters
const S = {alpha: 0.9, beta: 0.35, dt: 0.02, jitter: 0.00, speed: 4};
let t = 0, play = true, radianceWash = false;
let zoomLevel = 1.0;

// Chronon data structures
let chronons = [];
const v = document.getElementById('v');
let protonGunActive = false;
let particles = []; // Active particles traversing the grid

// Chronon type definitions
const CHRONON_TYPES = {
  T1: { 
    boxSize: 60,
    baseSpeed: 1.0,
    girth: 8,  // THIN washers (2√ó T2 girth)
    lightDeg: 300,  // 300¬∞ white, 60¬∞ black
    darkDeg: 60,
    lightColor: '#e8e8e8',
    darkColor: '#1a1a1a',
    oscillationRange: 18,  // 5% of 360 (normal matter)
    naturalOscillation: 3  // Uses ~17% of range naturally
  },
  T2: { 
    boxSize: 30,
    baseSpeed: 0.5,  // Half of T1
    girth: 4,  // MEDIUM washers (2√ó T3 girth)
    lightDeg: 180,  // 180¬∞ each (neutral)
    darkDeg: 180,
    lightColor: '#999999',
    darkColor: '#444444',
    oscillationRange: 97,  // 27% of 360 (dark matter)
    naturalOscillation: 15  // Uses ~15% of range naturally
  },
  T3: { 
    boxSize: 15,
    baseSpeed: 0.167,  // 1/6th of T1 (3x slower than T2)
    girth: 2,  // THINNEST washers (base girth)
    lightDeg: 60,   // 300¬∞ black, 60¬∞ white
    darkDeg: 300,
    lightColor: '#e8e8e8',
    darkColor: '#1a1a1a',
    oscillationRange: 245,  // 68% of 360 (dark energy)
    naturalOscillation: 40  // Uses ~16% of range naturally
  }
};

function createChrononGrid() {
  chronons = [];
  
  // Column layout with subdivisions:
  // 1-2: T3 (4√ó4 subdivisions per T1 cell)
  // 3-5: T2 (2√ó2 subdivisions per T1 cell)
  // 6-15: T1 (1√ó1, no subdivision)
  // 16-18: T2 (2√ó2 subdivisions per T1 cell)
  // 19-20: T3 (4√ó4 subdivisions per T1 cell)
  
  let countT1 = 0, countT2 = 0, countT3 = 0;
  
  for (let col = 0; col < COLS; col++) {
    let type, subdivisions;
    
    if (col < 2 || col >= 18) {
      // T3 columns: 4√ó4 subdivisions
      type = 'T3';
      subdivisions = 4;
    } else if ((col >= 2 && col < 5) || (col >= 15 && col < 18)) {
      // T2 columns: 2√ó2 subdivisions
      type = 'T2';
      subdivisions = 2;
    } else {
      // T1 columns: no subdivision
      type = 'T1';
      subdivisions = 1;
    }
    
    const typeData = CHRONON_TYPES[type];
    const boxSize = typeData.boxSize;
    
    // For each T1 row
    for (let t1Row = 0; t1Row < ROWS_T1; t1Row++) {
      // Subdivide into smaller boxes
      for (let subRow = 0; subRow < subdivisions; subRow++) {
        for (let subCol = 0; subCol < subdivisions; subCol++) {
          // Calculate position
          const colX = (col - COLS/2) * SPACING_T1;
          const rowY = (t1Row - ROWS_T1/2) * SPACING_T1;
          
          const x = colX + (subCol - subdivisions/2 + 0.5) * boxSize;
          const y = rowY + (subRow - subdivisions/2 + 0.5) * boxSize;
          
          chronons.push({
            x, y,
            type,
            boxSize,
            psiR: Math.random() * 2 - 1,
            psiI: Math.random() * 2 - 1,
            rho: 1.0,  // Start at max density
            rhoE: 1.0,  // Start at max to fill boxes
            phi: 0,  // All start with right chirality (same direction)
            arcPosition: 0,  // Start at max size (arc 0)
            chirality: 1,  // +1 = right, -1 = left
            disturbance: 0,  // External force applied
            neighbors: []
          });
          
          if (type === 'T1') countT1++;
          else if (type === 'T2') countT2++;
          else countT3++;
        }
      }
    }
  }
  
  // Normalize wave functions
  normalizeAll();
  
  // Build neighbor connections
  buildNeighbors();
  
  // Set all chronons to maximum size (fill boxes)
  for (const c of chronons) {
    c.rho = 1.0;
    c.rhoE = 1.0;
  }
  
  // Update stats
  document.getElementById('stat-count').textContent = chronons.length;
  document.getElementById('stat-t1').textContent = countT1;
  document.getElementById('stat-t2').textContent = countT2;
  document.getElementById('stat-t3-count').textContent = countT3;
}

function normalizeAll() {
  let s = 0;
  for (const c of chronons) {
    s += c.psiR * c.psiR + c.psiI * c.psiI;
  }
  s = Math.sqrt(s) || 1e-12;
  for (const c of chronons) {
    c.psiR /= s;
    c.psiI /= s;
  }
}

function buildNeighbors() {
  // Chronons must be touching or touchable by others in their class
  for (let i = 0; i < chronons.length; i++) {
    chronons[i].neighbors = [];
    const c1 = chronons[i];
    const maxDist = c1.boxSize * 1.5; // Touch adjacent boxes
    
    for (let j = 0; j < chronons.length; j++) {
      if (i === j) continue;
      const c2 = chronons[j];
      const dx = c2.x - c1.x;
      const dy = c2.y - c1.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      
      // Connect if close enough (boundary kissing)
      if (dist < maxDist) {
        chronons[i].neighbors.push(j);
      }
    }
  }
}

function updateViewBox() {
  const baseW = 620, baseH = 280;
  const w = baseW / zoomLevel, h = baseH / zoomLevel;
  v.setAttribute('viewBox', `${-w} ${-h} ${w*2} ${h*2}`);
}

function ui() {
  const map = {a:'alpha', b:'beta', s:'speed'};
  ['a','b','s'].forEach(id => {
    const input = document.getElementById(id);
    const valDisplay = document.getElementById('val-' + id);
    input.oninput = e => {
      S[map[id]] = parseFloat(e.target.value);
      valDisplay.textContent = e.target.value;
    };
  });
  
  document.getElementById('zoom').oninput = e => {
    zoomLevel = parseFloat(e.target.value);
    document.getElementById('val-zoom').textContent = zoomLevel.toFixed(2);
    updateViewBox();
  };
  
  const pb = document.getElementById('p');
  const setBtn = () => pb.textContent = play ? 'Pause' : 'Play';
  pb.onclick = () => { play = !play; setBtn(); };
  
  document.getElementById('r').onclick = () => {
    createChrononGrid();
    for (let i = 0; i < 12; i++) step();
    draw(true);
  };
  
  document.getElementById('wash').onclick = () => {
    radianceWash = !radianceWash;
    document.getElementById('stat-wash').textContent = radianceWash ? 'ON' : 'OFF';
    document.getElementById('stat-t3').textContent = radianceWash ? '3.0√ó' : '0.167√ó';
  };
  
  document.getElementById('proton').onclick = () => {
    protonGunActive = !protonGunActive;
    document.getElementById('proton').textContent = protonGunActive ? 'üéØ Click to Fire!' : 'üî´ Proton Gun (Click Grid)';
    v.style.cursor = protonGunActive ? 'crosshair' : 'default';
  };
  
  // Click to fire proton horizontally across grid
  v.addEventListener('click', (e) => {
    if (!protonGunActive) return;
    
    const rect = v.getBoundingClientRect();
    const svgY = (e.clientY - rect.top) / rect.height * 560 - 280;
    
    // Fire from left edge, travel horizontally right
    particles.push({
      x: -600,  // Start from left side
      y: svgY,
      vx: 5,    // Move right
      vy: 0,
      energy: 1.0,
      wavelength: 500, // nm (green light initially)
      age: 0,
      maxAge: 300,
      trail: []  // Store trail positions
    });
  });
  
  setBtn();
}

function step() {
  // Update particles (protons traversing grid)
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    
    // Find nearest chronon
    let nearest = null;
    let minDist = Infinity;
    for (const c of chronons) {
      const dx = c.x - p.x;
      const dy = c.y - p.y;
      const dist = Math.sqrt(dx*dx + dy*dy);
      if (dist < minDist) {
        minDist = dist;
        nearest = c;
      }
    }
    
    if (nearest && minDist < nearest.boxSize) {
      // Interact with chronon
      const typeData = CHRONON_TYPES[nearest.type];
      
      // Apply disturbance to chronon
      nearest.disturbance += p.energy * 0.5;
      
      // T3: Redshift (energy absorption)
      if (nearest.type === 'T3') {
        p.energy *= 0.95;
        p.wavelength *= 1.05; // Shift toward red
      }
      
      // T2: Gravitational curve (bend path)
      if (nearest.type === 'T2') {
        const dx = nearest.x - p.x;
        const dy = nearest.y - p.y;
        const force = 0.1 * nearest.rhoE;
        p.vx += dx * force;
        p.vy += dy * force;
      }
      
      // T1: Minimal interaction (fast lane)
      if (nearest.type === 'T1') {
        p.energy *= 0.99;
      }
    }
    
    // Store trail
    if (p.age % 3 === 0) {
      p.trail.push({x: p.x, y: p.y, wavelength: p.wavelength});
      if (p.trail.length > 50) p.trail.shift();
    }
    
    // Move particle
    p.x += p.vx;
    p.y += p.vy;
    p.age++;
    
    // Remove old particles
    if (p.age > p.maxAge || p.energy < 0.1) {
      particles.splice(i, 1);
    }
  }
  
  // Update density and phase for all chronons
  for (const c of chronons) {
    c.rho = c.psiR * c.psiR + c.psiI * c.psiI;
    c.rhoE = 0.95 * c.rhoE + 0.05 * c.rho;
    c.phi = Math.atan2(c.psiI, c.psiR);
    
    // Natural oscillation + disturbance
    const typeData = CHRONON_TYPES[c.type];
    const naturalArc = typeData.naturalOscillation * Math.sin(t * 0.01 * c.chirality);
    c.arcPosition = Math.abs(naturalArc + c.disturbance * 10);
    
    // Chirality flip if exceeds range
    if (c.arcPosition > typeData.oscillationRange) {
      c.chirality *= -1;
      c.arcPosition = typeData.oscillationRange - (c.arcPosition - typeData.oscillationRange);
    }
    
    // Decay disturbance
    c.disturbance *= 0.95;
  }
  
  // Schr√∂dinger evolution
  const newPsiR = [], newPsiI = [];
  
  for (let i = 0; i < chronons.length; i++) {
    const c = chronons[i];
    
    // Laplacian from neighbors
    let Lr = 0, Li = 0;
    for (const nIdx of c.neighbors) {
      const n = chronons[nIdx];
      Lr += n.psiR;
      Li += n.psiI;
    }
    const nCount = c.neighbors.length || 1;
    Lr = (Lr - nCount * c.psiR) / nCount;
    Li = (Li - nCount * c.psiI) / nCount;
    
    // Apply type-specific speed multiplier
    const typeData = CHRONON_TYPES[c.type];
    let speedMult = typeData.baseSpeed;
    
    // Radiance wash boost for T3
    if (c.type === 'T3' && radianceWash) {
      speedMult *= 18; // 0.167 * 18 ‚âà 3.0√ó
    }
    
    const Ar = S.alpha * Lr - S.beta * c.rho * c.psiR;
    const Ai = S.alpha * Li - S.beta * c.rho * c.psiI;
    
    newPsiR[i] = c.psiR + S.dt * speedMult * (-Ai);
    newPsiI[i] = c.psiI + S.dt * speedMult * (Ar);
  }
  
  // Update
  for (let i = 0; i < chronons.length; i++) {
    chronons[i].psiR = newPsiR[i];
    chronons[i].psiI = newPsiI[i];
  }
  
  normalizeAll();
  t++;
}

function drawRibbonWasher(g, cx, cy, radius, phi, type, chirality) {
  const typeData = CHRONON_TYPES[type];
  const girth = typeData.girth;
  
  // Chronons kiss boundaries - radius reaches to edge of box
  const maxRadius = typeData.boxSize / 2 - 1;
  const actualRadius = Math.min(radius, maxRadius);
  
  const outerR = actualRadius;
  const innerR = Math.max(2, actualRadius - girth);
  
  // Calculate speed-adjusted rotation (chirality affects direction)
  let speedMult = typeData.baseSpeed;
  if (type === 'T3' && radianceWash) speedMult *= 18;
  const rotationAngle = phi * speedMult * (actualRadius / 10) * chirality;
  
  // Ribbon configuration
  const lightDeg = typeData.lightDeg;
  const darkDeg = typeData.darkDeg;
  const lightColor = typeData.lightColor;
  const darkColor = typeData.darkColor;
  
  // Draw light segment
  if (lightDeg > 0) {
    const path1 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const startAngle = (0 - 90) * Math.PI / 180;
    const endAngle = (lightDeg - 90) * Math.PI / 180;
    
    const x1 = cx + outerR * Math.cos(startAngle);
    const y1 = cy + outerR * Math.sin(startAngle);
    const x2 = cx + outerR * Math.cos(endAngle);
    const y2 = cy + outerR * Math.sin(endAngle);
    const x3 = cx + innerR * Math.cos(endAngle);
    const y3 = cy + innerR * Math.sin(endAngle);
    const x4 = cx + innerR * Math.cos(startAngle);
    const y4 = cy + innerR * Math.sin(startAngle);
    
    const largeArc = lightDeg > 180 ? 1 : 0;
    
    const d = `M ${x1} ${y1} A ${outerR} ${outerR} 0 ${largeArc} 1 ${x2} ${y2} L ${x3} ${y3} A ${innerR} ${innerR} 0 ${largeArc} 0 ${x4} ${y4} Z`;
    path1.setAttribute('d', d);
    path1.setAttribute('fill', lightColor);
    path1.setAttribute('opacity', '0.9');
    path1.setAttribute('transform', `rotate(${rotationAngle * 180 / Math.PI}, ${cx}, ${cy})`);
    g.appendChild(path1);
  }
  
  // Draw dark segment
  if (darkDeg > 0) {
    const path2 = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const startAngle = (lightDeg - 90) * Math.PI / 180;
    const endAngle = (360 - 90) * Math.PI / 180;
    
    const x1 = cx + outerR * Math.cos(startAngle);
    const y1 = cy + outerR * Math.sin(startAngle);
    const x2 = cx + outerR * Math.cos(endAngle);
    const y2 = cy + outerR * Math.sin(endAngle);
    const x3 = cx + innerR * Math.cos(endAngle);
    const y3 = cy + innerR * Math.sin(endAngle);
    const x4 = cx + innerR * Math.cos(startAngle);
    const y4 = cy + innerR * Math.sin(startAngle);
    
    const largeArc = darkDeg > 180 ? 1 : 0;
    
    const d = `M ${x1} ${y1} A ${outerR} ${outerR} 0 ${largeArc} 1 ${x2} ${y2} L ${x3} ${y3} A ${innerR} ${innerR} 0 ${largeArc} 0 ${x4} ${y4} Z`;
    path2.setAttribute('d', d);
    path2.setAttribute('fill', darkColor);
    path2.setAttribute('opacity', '0.9');
    path2.setAttribute('transform', `rotate(${rotationAngle * 180 / Math.PI}, ${cx}, ${cy})`);
    g.appendChild(path2);
  }
  
  // Outlines (boundary kissing visualization)
  const outline = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  outline.setAttribute('cx', cx);
  outline.setAttribute('cy', cy);
  outline.setAttribute('r', outerR);
  outline.setAttribute('fill', 'none');
  outline.setAttribute('stroke', '#60a5fa');
  outline.setAttribute('stroke-width', '0.3');
  outline.setAttribute('opacity', '0.3');
  g.appendChild(outline);
  
  if (innerR > 2) {
    const innerOutline = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    innerOutline.setAttribute('cx', cx);
    innerOutline.setAttribute('cy', cy);
    innerOutline.setAttribute('r', innerR);
    innerOutline.setAttribute('fill', 'none');
    innerOutline.setAttribute('stroke', '#60a5fa');
    innerOutline.setAttribute('stroke-width', '0.3');
    innerOutline.setAttribute('opacity', '0.3');
    g.appendChild(innerOutline);
  }
  
  // RED NODE in center (inert, split polarity)
  const node = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  node.setAttribute('cx', cx);
  node.setAttribute('cy', cy);
  node.setAttribute('r', '1.5');
  node.setAttribute('fill', '#f87171');
  node.setAttribute('opacity', '0.9');
  g.appendChild(node);
}

function draw(init = false) {
  if (init) {
    v.innerHTML = '';
    const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    g.id = 'g';
    v.appendChild(g);
  }
  
  const g = document.getElementById('g');
  g.innerHTML = '';
  
  // Draw grid lines FIRST (so gradient is visible)
  const gridG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
  gridG.setAttribute('id', 'grid');
  gridG.setAttribute('opacity', '0.2');
  
  // Draw all box boundaries
  for (const c of chronons) {
    const half = c.boxSize / 2;
    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
    rect.setAttribute('x', c.x - half);
    rect.setAttribute('y', c.y - half);
    rect.setAttribute('width', c.boxSize);
    rect.setAttribute('height', c.boxSize);
    rect.setAttribute('fill', 'none');
    rect.setAttribute('stroke', '#60a5fa');
    rect.setAttribute('stroke-width', '0.5');
    gridG.appendChild(rect);
  }
  g.appendChild(gridG);
  
  // Draw connection lines (boundary kissing connections)
  for (let i = 0; i < chronons.length; i++) {
    const c = chronons[i];
    for (const nIdx of c.neighbors) {
      if (nIdx > i) { // Draw each line once
        const n = chronons[nIdx];
        const grad = Math.abs(n.rhoE - c.rhoE);
        if (grad < 0.4) {
          const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          line.setAttribute('x1', c.x);
          line.setAttribute('y1', c.y);
          line.setAttribute('x2', n.x);
          line.setAttribute('y2', n.y);
          line.setAttribute('stroke', '#60a5fa');
          line.setAttribute('stroke-width', '0.3');
          line.setAttribute('opacity', '0.1');
          g.appendChild(line);
        }
      }
    }
  }
  
  // Draw chronons (washers with nodes)
  for (const c of chronons) {
    const typeData = CHRONON_TYPES[c.type];
    const maxRadius = typeData.boxSize / 2 - 0.5;  // Arc 0 = max size
    const minRadius = typeData.boxSize / 6;  // Max arc = min size
    
    // Map arc position to radius (0 = max, range = min)
    const arcRatio = c.arcPosition / typeData.oscillationRange;
    const radius = maxRadius - (maxRadius - minRadius) * arcRatio;
    
    drawRibbonWasher(g, c.x, c.y, radius, c.phi, c.type, c.chirality);
  }
  
  // Draw particles (proton tracks)
  for (const p of particles) {
    // Draw trail first (behind particle)
    for (let i = 0; i < p.trail.length - 1; i++) {
      const t1 = p.trail[i];
      const t2 = p.trail[i + 1];
      const hue = 120 + (t1.wavelength - 500) * 0.5;
      const opacity = (i / p.trail.length) * 0.6;
      
      const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
      line.setAttribute('x1', t1.x);
      line.setAttribute('y1', t1.y);
      line.setAttribute('x2', t2.x);
      line.setAttribute('y2', t2.y);
      line.setAttribute('stroke', `hsl(${hue}, 100%, 50%)`);
      line.setAttribute('stroke-width', '2');
      line.setAttribute('opacity', opacity);
      g.appendChild(line);
    }
    
    // Color based on wavelength (redshift visualization)
    const hue = 120 + (p.wavelength - 500) * 0.5; // Green shifts to red
    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
    circle.setAttribute('cx', p.x);
    circle.setAttribute('cy', p.y);
    circle.setAttribute('r', 4 * p.energy);
    circle.setAttribute('fill', `hsl(${hue}, 100%, 50%)`);
    circle.setAttribute('opacity', '0.9');
    g.appendChild(circle);
  }
  
  // Update stats
  if (t % 10 === 0) {
    document.getElementById('stat-t').textContent = t;
  }
}

// Initialize
ui();
createChrononGrid();
updateViewBox();
for (let i = 0; i < 12; i++) step();
draw(true);

// Animation loop
(function loop() {
  if (play) {
    for (let s = 0; s < S.speed; s++) step();
  }
  draw(false);
  requestAnimationFrame(loop);
})();

// Save PNG
document.getElementById('save').onclick = () => {
  const svg = document.getElementById('v');
  const xml = new XMLSerializer().serializeToString(svg);
  const img = new Image();
  const url = URL.createObjectURL(new Blob([xml], {type:'image/svg+xml'}));
  img.onload = () => {
    const c = document.createElement('canvas');
    c.width = 2400;
    c.height = 1200;
    const ctx = c.getContext('2d');
    ctx.drawImage(img, 0, 0, c.width, c.height);
    const a = document.createElement('a');
    a.download = 'chronon_template_grid.png';
    a.href = c.toDataURL();
    a.click();
    URL.revokeObjectURL(url);
  };
  img.src = url;
};
</script>
</body>
</html>
