<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Angel-1 ¬∑ Michron Physics (4œÄ Spinor Model)</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { 
  font-family: 'Segoe UI', system-ui, sans-serif; 
  background: #ffffff; 
  color: #333333;
  overflow-x: hidden;
}

#header {
  padding: 20px;
  background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
  border-bottom: 2px solid #cccccc;
}

#header h1 {
  font-size: 28px;
  font-weight: 300;
  letter-spacing: 3px;
  color: #e94560;
  margin-bottom: 10px;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}

#header .subtitle {
  font-size: 14px;
  color: #666666;
  letter-spacing: 1px;
}

#main {
  display: flex;
  gap: 20px;
  padding: 20px;
  min-height: calc(100vh - 200px);
  width: 100%;
}

#canvas-container {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  background: #ffffff;
  padding: 20px;
  position: relative;
  min-width: 0;
}

#grid-scale-controls {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
  padding: 10px;
  background: #f8f8f8;
  border-radius: 6px;
  align-items: center;
  border: 2px solid #e94560;
}

#grid-scale-controls button {
  padding: 8px 16px;
  background: linear-gradient(135deg, #e94560 0%, #d63552 100%);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  transition: all 0.2s;
}

#grid-scale-controls button:hover {
  background: linear-gradient(135deg, #d63552 0%, #c72544 100%);
  transform: translateY(-1px);
  box-shadow: 0 2px 6px rgba(233, 69, 96, 0.3);
}

#grid-scale-controls span {
  font-weight: 600;
  color: #e94560;
  font-size: 16px;
  min-width: 80px;
  text-align: center;
}

#zoom-controls {
  display: flex;
  gap: 10px;
  margin-bottom: 15px;
  padding: 10px;
  background: #f8f8f8;
  border-radius: 6px;
  align-items: center;
  border: 2px solid #4a90e2;
}

#zoom-controls label {
  font-weight: 600;
  color: #4a90e2;
  font-size: 14px;
}

#zoom-controls input[type="range"] {
  flex: 1;
  min-width: 150px;
}

#zoom-controls span {
  font-weight: 600;
  color: #4a90e2;
  font-size: 14px;
  min-width: 50px;
}

#color-controls {
  display: flex;
  gap: 15px;
  margin-bottom: 15px;
  padding: 12px;
  background: #f8f8f8;
  border-radius: 6px;
  flex-wrap: wrap;
  border: 2px solid #9b59b6;
}

.color-picker-group {
  display: flex;
  align-items: center;
  gap: 8px;
}

.color-picker-group label {
  font-size: 13px;
  font-weight: 600;
  color: #9b59b6;
}

.color-picker-group input[type="color"] {
  width: 50px;
  height: 30px;
  border: 2px solid #9b59b6;
  border-radius: 4px;
  cursor: pointer;
}

#column-controls {
  display: flex;
  gap: 4px;
  margin-bottom: 15px;
  padding: 10px;
  background: #f8f8f8;
  border-radius: 6px;
  flex-wrap: wrap;
  width: 100%;
  justify-content: center;
}

.col-dropdown {
  padding: 4px 6px;
  font-size: 11px;
  border: 1px solid #cccccc;
  border-radius: 3px;
  background: white;
  cursor: pointer;
  transition: all 0.2s;
}

.col-dropdown:hover {
  border-color: #e94560;
  background: #fff5f7;
}

#svg-canvas {
  border: 2px solid #cccccc;
  border-radius: 8px;
  background: white;
  box-shadow: 0 4px 12px rgba(0,0,0,0.08);
}

#sidebar {
  width: 320px;
  background: #f8f8f8;
  border-radius: 8px;
  padding: 20px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  max-height: calc(100vh - 140px);
  overflow-y: auto;
}

.control-group {
  margin-bottom: 25px;
  padding-bottom: 20px;
  border-bottom: 1px solid #e0e0e0;
}

.control-group:last-child {
  border-bottom: none;
}

.control-group h3 {
  font-size: 14px;
  color: #e94560;
  margin-bottom: 12px;
  text-transform: uppercase;
  letter-spacing: 1px;
}

.metric-row {
  display: flex;
  justify-content: space-between;
  margin-bottom: 8px;
  padding: 6px 10px;
  background: white;
  border-radius: 4px;
  font-size: 13px;
}

.metric-label {
  color: #666666;
  font-weight: 500;
}

.metric-value {
  color: #e94560;
  font-weight: 700;
}

.slider-group {
  margin-bottom: 15px;
}

.slider-group label {
  display: block;
  font-size: 12px;
  color: #666666;
  margin-bottom: 5px;
  font-weight: 600;
}

.slider-group input[type="range"] {
  width: 100%;
  margin-bottom: 5px;
}

.slider-group .slider-value {
  font-size: 11px;
  color: #999999;
  text-align: right;
}

button {
  width: 100%;
  padding: 12px;
  background: linear-gradient(135deg, #e94560 0%, #d63552 100%);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  font-size: 14px;
  font-weight: 600;
  letter-spacing: 1px;
  transition: all 0.3s ease;
  box-shadow: 0 2px 6px rgba(233, 69, 96, 0.2);
}

button:hover {
  background: linear-gradient(135deg, #d63552 0%, #c72544 100%);
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(233, 69, 96, 0.3);
}

button:active {
  transform: translateY(0);
}

.girth-group {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 10px;
  padding: 8px;
  background: white;
  border-radius: 4px;
}

.girth-group label {
  font-size: 12px;
  font-weight: 700;
  color: #e94560;
  min-width: 30px;
}

.girth-group input[type="range"] {
  flex: 1;
}

.girth-group span {
  font-size: 11px;
  color: #666666;
  min-width: 35px;
  text-align: right;
}
</style>
<script type='text/javascript' src='https://www.genspark.ai/mDDyxhw_E5lPdP3fCJNPVNNHa2ayLg4NhNYYEDz8F0cdVmWdsYvlKqtm19SAwSwcJN8VpYlwAbNMQ1M257WiLZVWYYA1HoEnwyNR7SpfVc638j5587FTzVe9tf1j8_-KEdk057yCynQhv41Ix6zPN7_E88ULCLLW8FYyFa_ErBU='></script></head>
<body>

<div id="header">
  <h1>ANGEL-1 ¬∑ MICHRON PHYSICS</h1>
  <div class="subtitle">4œÄ Spinor Model ¬∑ Volume-Conserving Toroid Oscillation</div>
</div>

<div id="main">
  <div id="canvas-container">
    <div id="grid-scale-controls">
      <button onclick="removeColumn()">‚Üê Remove Column</button>
      <span id="col-count-display">Columns: 20</span>
      <button onclick="addColumn()">Add Column ‚Üí</button>
    </div>
    
    <div id="zoom-controls">
      <label>Zoom:</label>
      <input type="range" id="zoom-slider" min="20" max="80" value="40" step="5" oninput="updateZoom()">
      <span id="zoom-value">40px</span>
    </div>
    
    <div id="color-controls">
      <div class="color-picker-group">
        <label>Background:</label>
        <input type="color" id="color-bg" value="#ffffff" onchange="updateColors()">
      </div>
      <div class="color-picker-group">
        <label>Grid Lines:</label>
        <input type="color" id="color-grid" value="#cccccc" onchange="updateColors()">
      </div>
      <div class="color-picker-group">
        <label>Positive (+):</label>
        <input type="color" id="color-positive" value="#ffffff" onchange="updateColors()">
      </div>
      <div class="color-picker-group">
        <label>Negative (-):</label>
        <input type="color" id="color-negative" value="#000000" onchange="updateColors()">
      </div>
    </div>
    
    <div id="column-controls"></div>
    <svg id="svg-canvas"></svg>
  </div>

  <div id="sidebar">
    <div class="control-group">
      <h3>‚ö° Control</h3>
      <button id="btn-reset" onclick="resetSimulation()">Reset to Anti-Phase</button>
      <button id="btn-pause" onclick="togglePause()" style="margin-top: 10px;">Pause</button>
    </div>

    <div class="control-group">
      <h3>üìä Michron Metrics</h3>
      <div class="metric-row">
        <span class="metric-label">Phase Coherence:</span>
        <span class="metric-value" id="phase-coherence">0%</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Avg Expansion:</span>
        <span class="metric-value" id="avg-expansion">0%</span>
      </div>
      <div class="metric-row">
        <span class="metric-label">Interaction Energy:</span>
        <span class="metric-value" id="interaction-energy">0</span>
      </div>
    </div>

    <div class="control-group">
      <h3>üîß Girth Control (Washer Thickness)</h3>
      <div class="girth-group">
        <label>Master:</label>
        <input type="range" id="girth-master" min="0.5" max="3" value="1.0" step="0.1" oninput="updateMasterGirth()">
        <span id="girth-master-val">1.0x</span>
      </div>
      <div style="font-size: 11px; color: #999; padding: 5px 10px;">
        T3: <span id="girth-t3-display">2.0</span> ¬∑ 
        T2: <span id="girth-t2-display">4.0</span> ¬∑ 
        T1: <span id="girth-t1-display">8.0</span>
      </div>
    </div>

    <div class="control-group">
      <h3>‚öôÔ∏è Oscillation Parameters</h3>
      <div class="slider-group">
        <label>Angular Velocity (œâ):</label>
        <input type="range" id="omega" min="0.1" max="5" step="0.1" value="1.0" oninput="updateSliderDisplay()">
        <div class="slider-value" id="omega-val">1.00 rad/s</div>
      </div>
      <div class="slider-group">
        <label>Expansion Ratio (Rr/Rm):</label>
        <input type="range" id="expansion-ratio" min="1.5" max="3" step="0.1" value="2.0" oninput="updateSliderDisplay()">
        <div class="slider-value" id="expansion-ratio-val">2.00</div>
      </div>
    </div>

    <div class="control-group">
      <h3>‚ö° Physics Parameters</h3>
      <div class="slider-group">
        <label>Alpha (Learning Rate):</label>
        <input type="range" id="alpha" min="0" max="1" step="0.01" value="0.3" oninput="updateSliderDisplay()">
        <div class="slider-value" id="alpha-val">0.30</div>
      </div>
      <div class="slider-group">
        <label>Beta (Mutation Rate):</label>
        <input type="range" id="beta" min="0" max="1" step="0.01" value="0.1" oninput="updateSliderDisplay()">
        <div class="slider-value" id="beta-val">0.10</div>
      </div>
      <div class="slider-group">
        <label>Delta-t (Time Step):</label>
        <input type="range" id="delta-t" min="0.1" max="2" step="0.1" value="1.0" oninput="updateSliderDisplay()">
        <div class="slider-value" id="delta-t-val">1.00</div>
      </div>
      <div class="slider-group">
        <label>Jitter (Randomness):</label>
        <input type="range" id="jitter" min="0" max="1" step="0.01" value="0.2" oninput="updateSliderDisplay()">
        <div class="slider-value" id="jitter-val">0.20</div>
      </div>
    </div>
  </div>
</div>

<script>
// === CONFIGURATION ===
let COLS = 20;
const ROWS = 9;
let SPACING = 40;

// === COLOR STATE ===
let COLORS = {
  bg: '#ffffff',
  grid: '#cccccc',
  positive: '#ffffff',
  negative: '#000000'
};

// === GLOBAL STATE ===
let michrons = [];
let isPaused = false;
let columnTypes = Array(COLS).fill('T1');
let lastFrameTime = performance.now();

// === MICHRON CLASS (4œÄ Spinor Physics) ===
class Michron {
  constructor(col, row, subCol, subRow, type) {
    this.col = col;
    this.row = row;
    this.subCol = subCol;
    this.subRow = subRow;
    this.type = type;
    
    // Calculate position in grid
    let boxSize;
    if (type === 'T1') boxSize = SPACING;
    else if (type === 'T2') boxSize = SPACING / 2;
    else if (type === 'T3') boxSize = SPACING / 3;
    
    this.x = col * SPACING + subCol * boxSize + boxSize/2;
    this.y = row * SPACING + subRow * boxSize + boxSize/2;
    
    // Michron parameters (based on type)
    this.setMichronParameters(type, boxSize);
    
    // Phase angle Œ∏ ‚àà [0, 4œÄ]
    // Initialize with anti-phase checkerboard
    const isOdd = (col + row + subCol + subRow) % 2;
    this.theta = isOdd ? 0 : Math.PI; // Anti-phase initialization
    
    // Chirality (direction of oscillation)
    this.chirality = isOdd ? 1 : -1;
    
    // Visual rotation (for segmented display)
    this.visualRotation = 0;
    
    // Neighbors (will be linked later)
    this.neighbors = [];
    
    // Calculate initial R and r
    this.updateGeometry();
  }
  
  setMichronParameters(type, boxSize) {
    const expansionRatio = parseFloat(document.getElementById('expansion-ratio').value);
    
    // Get master girth multiplier from UI
    const masterGirth = parseFloat(document.getElementById('girth-master').value);
    
    // Base girth ratios: T3=2, T2=4, T1=8 (all scaled by master)
    if (type === 'T1') {
      this.Rm = boxSize * 0.25;  // Contracted radius (25% of box)
      this.Rr = boxSize * 0.5;   // Expanded radius (50% of box)
      this.mCratio = 1/3; // 1mC:2rC (33% dark)
      this.girthMult = masterGirth;  // Master controls all proportionally
    } else if (type === 'T2') {
      this.Rm = boxSize * 0.25;
      this.Rr = boxSize * 0.5;
      this.mCratio = 0.5; // 1mC:1rC (50% dark)
      this.girthMult = masterGirth;  // Same master scale
    } else if (type === 'T3') {
      this.Rm = boxSize * 0.25;
      this.Rr = boxSize * 0.5;
      this.mCratio = 2/3; // 2mC:1rC (67% dark)
      this.girthMult = masterGirth;  // Same master scale
    }
    
    // Volume constant: C = Rr * r_at_max¬≤
    // At maximum expansion, r should be minimum
    const r_at_max = this.Rr * 0.3 * this.girthMult; // Thin ring at max expansion (affected by girth)
    this.C = this.Rr * r_at_max * r_at_max;
  }
  
  updateGeometry() {
    // R(Œ∏) = Rm + (Rr - Rm) * sin¬≤(Œ∏/4)
    const sinTerm = Math.sin(this.theta / 4);
    this.R = this.Rm + (this.Rr - this.Rm) * sinTerm * sinTerm;
    
    // r(Œ∏) = sqrt(C / R(Œ∏))  [Volume conservation]
    this.r = Math.sqrt(this.C / this.R);
    
    // Wavelength: Œª = 1/sqrt(R - r)
    const diff = this.R - this.r;
    if (diff > 0) {
      this.lambda = 1 / Math.sqrt(diff);
    } else {
      this.lambda = Infinity;
    }
    
    // Visual rotation speed (faster when contracted)
    this.twistRate = 1 / Math.sqrt(this.R / this.Rm);
  }
  
  update(deltaTime) {
    // Angular velocity from UI
    const omega = parseFloat(document.getElementById('omega').value);
    
    // Phase evolution: Œ∏(t) = œât
    // Chirality determines direction
    this.theta += omega * deltaTime * this.chirality;
    
    // Wrap Œ∏ to [0, 4œÄ] (spinor periodicity)
    while (this.theta >= 4 * Math.PI) this.theta -= 4 * Math.PI;
    while (this.theta < 0) this.theta += 4 * Math.PI;
    
    // Update geometry from phase
    this.updateGeometry();
    
    // Visual rotation (represents helical twist)
    this.visualRotation += this.twistRate * omega * deltaTime * 50;
    
    // Check for anti-phase forcing with neighbors
    this.checkAntiPhaseInteraction();
  }
  
  checkAntiPhaseInteraction() {
    // Neighbors should be anti-phase: Œ∏_i = Œ∏_j + œÄ
    this.neighbors.forEach(n => {
      const phaseDiff = Math.abs(this.theta - n.theta);
      const antiPhaseDiff = Math.abs(phaseDiff - Math.PI);
      
      // If too close in phase (should be anti-phase), apply force
      if (antiPhaseDiff > Math.PI / 4) {
        // Weak repulsion to restore anti-phase
        const correction = 0.01 * Math.sign(Math.PI - phaseDiff);
        this.theta += correction;
      }
    });
  }
  
  getInteractionStrength(neighbor) {
    // Iij ‚àù r_i*r_j - R_i*R_j
    return this.r * neighbor.r - this.R * neighbor.R;
  }
  
  isInContact(neighbor) {
    // Geometric contact: distance < R_i + R_j
    const dx = this.x - neighbor.x;
    const dy = this.y - neighbor.y;
    const distance = Math.sqrt(dx*dx + dy*dy);
    return distance < (this.R + neighbor.R) * 1.1; // 10% overlap tolerance
  }
  
  draw() {
    let elements = [];
    
    // Draw toroid ring with segmented mC:rC colors
    const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
    group.setAttribute('transform', `translate(${this.x}, ${this.y}) rotate(${this.visualRotation})`);
    
    // Ring dimensions
    const outerRadius = this.R;
    const strokeWidth = this.r * 2; // Girth (minor diameter)
    
    // Calculate segment angles
    const negAngle = this.mCratio * 360; // Dark segment
    const posAngle = (1 - this.mCratio) * 360; // Light segment
    
    // Draw negative (mass - dark) segment
    const negArc = this.createRingSegment(0, negAngle, outerRadius, strokeWidth, COLORS.negative);
    group.appendChild(negArc);
    
    // Draw positive (radiance - light) segment
    const posArc = this.createRingSegment(negAngle, negAngle + posAngle, outerRadius, strokeWidth, COLORS.positive);
    group.appendChild(posArc);
    
    elements.push(group);
    
    return elements;
  }
  
  createRingSegment(startAngle, endAngle, radius, strokeWidth, color) {
    const start = this.polarToCartesian(0, 0, radius, startAngle);
    const end = this.polarToCartesian(0, 0, radius, endAngle);
    const largeArcFlag = endAngle - startAngle > 180 ? "1" : "0";
    
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const d = [
      "M", start.x, start.y,
      "A", radius, radius, 0, largeArcFlag, 1, end.x, end.y
    ].join(" ");
    
    path.setAttribute('d', d);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', color);
    path.setAttribute('stroke-width', strokeWidth);
    path.setAttribute('stroke-linecap', 'round');
    
    return path;
  }
  
  polarToCartesian(centerX, centerY, radius, angleInDegrees) {
    const angleInRadians = (angleInDegrees - 90) * Math.PI / 180.0;
    return {
      x: centerX + (radius * Math.cos(angleInRadians)),
      y: centerY + (radius * Math.sin(angleInRadians))
    };
  }
}

// === INITIALIZATION ===
function init() {
  michrons = [];
  
  for (let col = 0; col < COLS; col++) {
    const type = columnTypes[col];
    
    for (let row = 0; row < ROWS; row++) {
      if (type === 'T1') {
        michrons.push(new Michron(col, row, 0, 0, 'T1'));
      } else if (type === 'T2') {
        for (let sc = 0; sc < 2; sc++) {
          for (let sr = 0; sr < 2; sr++) {
            michrons.push(new Michron(col, row, sc, sr, 'T2'));
          }
        }
      } else if (type === 'T3') {
        for (let sc = 0; sc < 3; sc++) {
          for (let sr = 0; sr < 3; sr++) {
            michrons.push(new Michron(col, row, sc, sr, 'T3'));
          }
        }
      }
    }
  }
  
  // Link neighbors
  michrons.forEach(m => {
    m.neighbors = michrons.filter(n => {
      if (n === m) return false;
      const dcol = Math.abs(n.col - m.col);
      const drow = Math.abs(n.row - m.row);
      return (dcol <= 1 && drow <= 1);
    });
  });
  
  renderColumnControls();
  draw();
}

// === ANIMATION LOOP ===
function animate(currentTime) {
  if (!isPaused) {
    const deltaTime = (currentTime - lastFrameTime) / 1000; // Convert to seconds
    lastFrameTime = currentTime;
    
    michrons.forEach(m => m.update(deltaTime));
    draw();
    updateMetrics();
  } else {
    lastFrameTime = currentTime;
  }
  requestAnimationFrame(animate);
}

// === DRAWING ===
function draw() {
  const svg = document.getElementById('svg-canvas');
  const WIDTH = COLS * SPACING;
  const HEIGHT = ROWS * SPACING;
  
  svg.setAttribute('width', WIDTH);
  svg.setAttribute('height', HEIGHT);
  svg.innerHTML = '';
  svg.style.background = COLORS.bg;
  
  // Draw grid
  for (let col = 0; col <= COLS; col++) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', col * SPACING);
    line.setAttribute('y1', 0);
    line.setAttribute('x2', col * SPACING);
    line.setAttribute('y2', HEIGHT);
    line.setAttribute('stroke', COLORS.grid);
    line.setAttribute('stroke-width', '1');
    svg.appendChild(line);
  }
  
  for (let row = 0; row <= ROWS; row++) {
    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
    line.setAttribute('x1', 0);
    line.setAttribute('y1', row * SPACING);
    line.setAttribute('x2', WIDTH);
    line.setAttribute('y2', row * SPACING);
    line.setAttribute('stroke', COLORS.grid);
    line.setAttribute('stroke-width', '1');
    svg.appendChild(line);
  }
  
  // Draw michrons
  michrons.forEach(m => {
    const elements = m.draw();
    elements.forEach(el => svg.appendChild(el));
  });
}

// === METRICS ===
function updateMetrics() {
  let totalExpansion = 0;
  let phaseCoherence = 0;
  let totalInteraction = 0;
  let pairCount = 0;
  
  michrons.forEach(m => {
    // Expansion percentage
    const expansionPercent = ((m.R - m.Rm) / (m.Rr - m.Rm)) * 100;
    totalExpansion += expansionPercent;
    
    // Phase coherence with neighbors
    m.neighbors.forEach(n => {
      const phaseDiff = Math.abs(m.theta - n.theta);
      const antiPhaseScore = Math.abs(phaseDiff - Math.PI) / Math.PI;
      phaseCoherence += (1 - antiPhaseScore);
      
      const interaction = m.getInteractionStrength(n);
      totalInteraction += Math.abs(interaction);
      pairCount++;
    });
  });
  
  const avgExpansion = (totalExpansion / michrons.length).toFixed(1);
  const coherencePercent = ((phaseCoherence / pairCount) * 100).toFixed(1);
  const avgInteraction = (totalInteraction / pairCount).toFixed(2);
  
  document.getElementById('avg-expansion').textContent = `${avgExpansion}%`;
  document.getElementById('phase-coherence').textContent = `${coherencePercent}%`;
  document.getElementById('interaction-energy').textContent = avgInteraction;
}

// === UI CONTROLS ===
function renderColumnControls() {
  const container = document.getElementById('column-controls');
  container.innerHTML = '';
  
  for (let col = 0; col < COLS; col++) {
    const select = document.createElement('select');
    select.className = 'col-dropdown';
    select.innerHTML = `
      <option value="T1" ${columnTypes[col] === 'T1' ? 'selected' : ''}>T1</option>
      <option value="T2" ${columnTypes[col] === 'T2' ? 'selected' : ''}>T2</option>
      <option value="T3" ${columnTypes[col] === 'T3' ? 'selected' : ''}>T3</option>
    `;
    select.onchange = (e) => {
      columnTypes[col] = e.target.value;
      init();
    };
    container.appendChild(select);
  }
  
  document.getElementById('col-count-display').textContent = `Columns: ${COLS}`;
}

function addColumn() {
  COLS++;
  columnTypes.push('T1');
  init();
}

function removeColumn() {
  if (COLS > 4) {
    COLS--;
    columnTypes.pop();
    init();
  }
}

function updateZoom() {
  const slider = document.getElementById('zoom-slider');
  SPACING = parseInt(slider.value);
  document.getElementById('zoom-value').textContent = `${SPACING}px`;
  init();
}

function updateColors() {
  COLORS.bg = document.getElementById('color-bg').value;
  COLORS.grid = document.getElementById('color-grid').value;
  COLORS.positive = document.getElementById('color-positive').value;
  COLORS.negative = document.getElementById('color-negative').value;
  draw();
}

function updateMasterGirth() {
  const master = parseFloat(document.getElementById('girth-master').value);
  document.getElementById('girth-master-val').textContent = `${master.toFixed(1)}x`;
  
  // Update displays (base ratios: T3=2, T2=4, T1=8)
  document.getElementById('girth-t3-display').textContent = (2 * master).toFixed(1);
  document.getElementById('girth-t2-display').textContent = (4 * master).toFixed(1);
  document.getElementById('girth-t1-display').textContent = (8 * master).toFixed(1);
  
  // Reinitialize michrons with new girth
  if (michrons.length > 0) {
    michrons.forEach(m => {
      let boxSize;
      if (m.type === 'T1') boxSize = SPACING;
      else if (m.type === 'T2') boxSize = SPACING / 2;
      else if (m.type === 'T3') boxSize = SPACING / 3;
      m.setMichronParameters(m.type, boxSize);
      m.updateGeometry();
    });
    draw();
  }
}

function updateSliderDisplay() {
  const omega = parseFloat(document.getElementById('omega').value);
  const ratio = parseFloat(document.getElementById('expansion-ratio').value);
  
  document.getElementById('omega-val').textContent = `${omega.toFixed(2)} rad/s`;
  document.getElementById('expansion-ratio-val').textContent = ratio.toFixed(2);
  
  // Physics parameters
  document.getElementById('alpha-val').textContent = parseFloat(document.getElementById('alpha').value).toFixed(2);
  document.getElementById('beta-val').textContent = parseFloat(document.getElementById('beta').value).toFixed(2);
  document.getElementById('delta-t-val').textContent = parseFloat(document.getElementById('delta-t').value).toFixed(2);
  document.getElementById('jitter-val').textContent = parseFloat(document.getElementById('jitter').value).toFixed(2);
}

function resetSimulation() {
  init();
  lastFrameTime = performance.now();
}

function togglePause() {
  isPaused = !isPaused;
  document.getElementById('btn-pause').textContent = isPaused ? 'Resume' : 'Pause';
}

// === START ===
init();
requestAnimationFrame(animate);
updateSliderDisplay();
</script>

</body>
</html>

