<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ANGEL-1 ¬∑ Michron Physics Dashboard</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: #0b0f14;
  color: #e8ecef;
  min-height: 100vh;
}

.header {
  background: linear-gradient(135deg, #1a1f2e 0%, #0f1620 100%);
  border-bottom: 2px solid #22303d;
  padding: 16px 24px;
}

.header h1 {
  font-size: 24px;
  background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 4px;
}

.header .subtitle {
  color: #9ca3af;
  font-size: 12px;
}

.main {
  display: flex;
  gap: 20px;
  padding: 20px;
}

.canvas-section {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sidebar {
  width: 300px;
  display: flex;
  flex-direction: column;
  gap: 16px;
}

.panel {
  background: #1a1f2e;
  border: 1px solid #22303d;
  border-radius: 8px;
  padding: 16px;
}

.panel h3 {
  color: #60a5fa;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 12px;
  display: flex;
  align-items: center;
  gap: 6px;
}

.grid-controls {
  display: flex;
  gap: 8px;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
}

.grid-controls button {
  padding: 8px 16px;
  background: linear-gradient(135deg, #1e3a5f 0%, #1a1f2e 100%);
  border: 1px solid #22303d;
  border-radius: 4px;
  color: #e8ecef;
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
}

.grid-controls button:hover {
  border-color: #60a5fa;
  transform: translateY(-1px);
}

.grid-controls span {
  color: #60a5fa;
  font-weight: 600;
  min-width: 100px;
  text-align: center;
}

.type-selectors {
  display: flex;
  gap: 4px;
  flex-wrap: wrap;
  justify-content: center;
  margin-top: 8px;
}

.type-selectors select {
  padding: 4px 6px;
  font-size: 10px;
  background: #0b0f14;
  border: 1px solid #22303d;
  border-radius: 3px;
  color: #e8ecef;
  cursor: pointer;
}

.playback {
  display: flex;
  gap: 8px;
}

.playback button {
  flex: 1;
  padding: 10px;
  border: 1px solid #22303d;
  border-radius: 6px;
  color: #e8ecef;
  font-size: 13px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.playback button.primary {
  background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
  border-color: #60a5fa;
}

.playback button.secondary {
  background: linear-gradient(135deg, #1e3a5f 0%, #1a1f2e 100%);
}

.slider-group {
  margin-bottom: 12px;
}

.slider-group:last-child {
  margin-bottom: 0;
}

.slider-group label {
  display: flex;
  justify-content: space-between;
  font-size: 12px;
  color: #d1d5db;
  margin-bottom: 4px;
}

.slider-group .value {
  color: #60a5fa;
  font-family: 'Courier New', monospace;
  font-weight: 600;
}

input[type="range"] {
  width: 100%;
  height: 4px;
  border-radius: 2px;
  background: #0b0f14;
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
  cursor: pointer;
}

.color-row {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

.color-item {
  display: flex;
  align-items: center;
  gap: 6px;
}

.color-item label {
  font-size: 11px;
  color: #9ca3af;
}

.color-item input[type="color"] {
  width: 32px;
  height: 24px;
  border: 1px solid #22303d;
  border-radius: 3px;
  cursor: pointer;
  background: none;
}

.metrics-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 8px;
}

.metric {
  background: #0b0f14;
  border-radius: 4px;
  padding: 8px;
  text-align: center;
}

.metric .label {
  font-size: 10px;
  color: #9ca3af;
  margin-bottom: 2px;
}

.metric .value {
  font-size: 16px;
  font-weight: 700;
  color: #10b981;
  font-family: 'Courier New', monospace;
}

.canvas-container {
  background: #1a1f2e;
  border: 2px solid #22303d;
  border-radius: 8px;
  padding: 16px;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 400px;
}

canvas {
  border: 1px solid #22303d;
  border-radius: 4px;
}

.canvas-with-rows {
  display: flex;
  gap: 8px;
  align-items: center;
}

.row-selectors {
  display: flex;
  flex-direction: column;
  gap: 2px;
}

.row-selectors select {
  padding: 2px 4px;
  font-size: 9px;
  background: #0b0f14;
  border: 1px solid #22303d;
  border-radius: 2px;
  color: #e8ecef;
  cursor: pointer;
  width: 36px;
}

.info-box {
  background: rgba(96, 165, 250, 0.1);
  border: 1px solid rgba(96, 165, 250, 0.3);
  border-radius: 6px;
  padding: 12px;
  font-size: 11px;
  line-height: 1.6;
  color: #9ca3af;
}

.info-box strong {
  color: #60a5fa;
}
</style>
</head>
<body>

<div class="header">
  <h1>ANGEL-1 ¬∑ MICHRON PHYSICS</h1>
  <div class="subtitle">Radial Wave Propagation ¬∑ Torsion-Driven State Transitions ¬∑ Inner-Rim Mass</div>
</div>

<div class="main">
  <div class="canvas-section">
    <div class="panel">
      <div class="grid-controls">
        <button onclick="removeColumn()">‚àí Col</button>
        <span id="colCount">Columns: 12</span>
        <button onclick="addColumn()">+ Col</button>
        <button onclick="removeRow()">‚àí Row</button>
        <span id="rowCount">Rows: 8</span>
        <button onclick="addRow()">+ Row</button>
      </div>
    </div>

    <div class="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <div class="sidebar">
    <div class="panel">
      <h3>‚ö° Control</h3>
      <div class="playback">
        <button id="pauseBtn" class="primary" onclick="togglePause()">Pause</button>
        <button class="secondary" onclick="reset()">Reset</button>
      </div>
    </div>

    <div class="panel">
      <h3>üìä Metrics</h3>
      <div class="metrics-grid">
        <div class="metric">
          <div class="label">Time Steps</div>
          <div class="value" id="metricTime">0</div>
        </div>
        <div class="metric">
          <div class="label">Avg Torsion</div>
          <div class="value" id="metricTorsion">0.00</div>
        </div>
        <div class="metric">
          <div class="label">T1 Cells</div>
          <div class="value" id="metricT1" style="color:#3bd5ff;">0</div>
        </div>
        <div class="metric">
          <div class="label">T2 Cells</div>
          <div class="value" id="metricT2" style="color:#ffd86a;">0</div>
        </div>
        <div class="metric">
          <div class="label">T3 Cells</div>
          <div class="value" id="metricT3" style="color:#ff4b6a;">0</div>
        </div>
        <div class="metric">
          <div class="label">Transitions</div>
          <div class="value" id="metricTransitions">0</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>‚è±Ô∏è Speed</h3>
      <div class="slider-group">
        <label>
          <span>Simulation Speed</span>
          <span class="value" id="speedVal">1.0x</span>
        </label>
        <input type="range" id="speed" min="0.25" max="4" step="0.25" value="1" oninput="updateSpeed()">
      </div>
    </div>

    <div class="panel">
      <h3>üåä Wave Dynamics</h3>
      <div class="slider-group">
        <label>
          <span>Wave Frequency</span>
          <span class="value" id="waveFreqVal">0.90</span>
        </label>
        <input type="range" id="waveFreq" min="0.3" max="2.0" step="0.1" value="0.9" oninput="updateWaveFreq()">
      </div>
      <div class="slider-group">
        <label>
          <span>Swirl Factor</span>
          <span class="value" id="swirlVal">0.30</span>
        </label>
        <input type="range" id="swirl" min="0" max="1" step="0.05" value="0.3" oninput="updateSwirl()">
      </div>
      <div class="slider-group">
        <label>
          <span>Jitter</span>
          <span class="value" id="jitterVal">0.20</span>
        </label>
        <input type="range" id="jitter" min="0" max="0.5" step="0.05" value="0.2" oninput="updateJitter()">
      </div>
    </div>

    <div class="panel">
      <h3>üåÄ Torsion Thresholds</h3>
      <div class="slider-group">
        <label>
          <span>T1‚ÜîT2 Threshold</span>
          <span class="value" id="t12Val">0.50</span>
        </label>
        <input type="range" id="t12" min="0.2" max="0.6" step="0.05" value="0.5" oninput="updateT12()">
      </div>
      <div class="slider-group">
        <label>
          <span>T2‚ÜîT3 Threshold</span>
          <span class="value" id="t23Val">0.70</span>
        </label>
        <input type="range" id="t23" min="0.5" max="0.9" step="0.05" value="0.7" oninput="updateT23()">
      </div>
    </div>

    <div class="panel">
      <h3>üîß Girth</h3>
      <div class="slider-group">
        <label>
          <span>Master Girth</span>
          <span class="value" id="girthVal">1.0x</span>
        </label>
        <input type="range" id="girth" min="0.5" max="2" step="0.1" value="1" oninput="updateGirth()">
      </div>
    </div>

    <div class="info-box">
      <strong>Wave Mechanics (Agent 1):</strong><br>
      ‚Ä¢ Radial wave expands from center<br>
      ‚Ä¢ Swirl adds rotational component<br>
      ‚Ä¢ Torsion = wave + swirl + neighbors<br><br>
      <strong>State Transitions:</strong><br>
      T1 (radiant): torsion &lt; 0.50<br>
      T2 (EM): 0.50 ‚â§ torsion &lt; 0.70<br>
      T3 (mass): torsion ‚â• 0.70
    </div>
  </div>
</div>

<script>
// === CONFIGURATION ===
let COLS = 12;
let ROWS = 8;
const CELL_SIZE = 40;

// T-Class specifications
const T_SPECS = {
  T1: { 
    girth: 0.25, 
    mass: 0.33,
    torsion: 0.2,
    color: '#3bd5ff'   // cyan - radiant
  },
  T2: { 
    girth: 0.45, 
    mass: 0.50,
    torsion: 0.55,
    color: '#ffd86a'   // gold - EM mesophase
  },
  T3: { 
    girth: 0.65, 
    mass: 0.90,
    torsion: 0.85,
    color: '#ff4b6a'   // red - mass-locked
  }
};

// === STATE ===
let isPaused = false;
let steps = 0;
let totalTransitions = 0;

// Per-cell state
let cells = [];

// Parameters
let simSpeed = 1.0;
let waveFreq = 0.9;
let swirlFactor = 0.3;
let jitter = 0.2;
let t12Threshold = 0.5;
let t23Threshold = 0.7;
let girthMult = 1.0;

// Colors
const BG_COLOR = '#0b0f14';
const GRID_COLOR = '#182034';
const MASS_COLOR = '#1a1a1a';
const RADIANCE_COLOR = '#e8e8e8';

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

let lastTime = null;

// === CELL CLASS ===
class Cell {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.state = 'T1';
    this.phase = Math.random() * Math.PI * 2;
    this.torsion = T_SPECS.T1.torsion;
    this.localTorsion = 0;  // computed each frame
    this.wave = 0;
    this.swirl = 0;
  }
  
  get spec() {
    return T_SPECS[this.state];
  }
  
  // Distance and angle from center
  get dx() { return this.x - (COLS - 1) / 2; }
  get dy() { return this.y - (ROWS - 1) / 2; }
  get r() { return Math.sqrt(this.dx * this.dx + this.dy * this.dy); }
  get angle() { return Math.atan2(this.dy, this.dx); }
}

// === INITIALIZATION ===
function init() {
  cells = [];
  
  for (let y = 0; y < ROWS; y++) {
    for (let x = 0; x < COLS; x++) {
      cells.push(new Cell(x, y));
    }
  }
  
  canvas.width = COLS * CELL_SIZE;
  canvas.height = ROWS * CELL_SIZE;
  
  steps = 0;
  totalTransitions = 0;
  lastTime = null;
  
  draw();
}

// === GRID CONTROLS ===
function addColumn() {
  if (COLS < 20) { COLS++; init(); }
}
function removeColumn() {
  if (COLS > 6) { COLS--; init(); }
}
function addRow() {
  if (ROWS < 14) { ROWS++; init(); }
}
function removeRow() {
  if (ROWS > 4) { ROWS--; init(); }
}

// === GET NEIGHBORS ===
function getNeighbors(cell) {
  const neighbors = [];
  const coords = [
    [cell.x - 1, cell.y],
    [cell.x + 1, cell.y],
    [cell.x, cell.y - 1],
    [cell.x, cell.y + 1]
  ];
  
  for (const [nx, ny] of coords) {
    if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
      neighbors.push(cells[ny * COLS + nx]);
    }
  }
  
  return neighbors;
}

// === EVOLUTION (from Agent 1) ===
function evolve(dt) {
  let transitionsThisFrame = 0;
  
  // First pass: compute local torsion for each cell
  for (const cell of cells) {
    // Radial wave: expanding from center
    cell.wave = Math.sin(cell.r * waveFreq - cell.phase) * 0.5 + 0.5;
    
    // Swirl: rotational component
    cell.swirl = Math.sin(cell.angle + cell.phase * swirlFactor) * 0.5 + 0.5;
    
    // Neighbor influence
    const neighbors = getNeighbors(cell);
    let higherNeighbors = 0;
    for (const n of neighbors) {
      if (n.state === 'T2' || n.state === 'T3') higherNeighbors++;
    }
    const neighborInfluence = higherNeighbors / Math.max(1, neighbors.length);
    
    // Noise
    const noise = (Math.random() - 0.5) * jitter;
    
    // Combined local torsion
    cell.localTorsion = 0.5 * cell.wave + 0.3 * cell.swirl + 0.4 * neighborInfluence + noise;
    cell.localTorsion = Math.max(0, Math.min(1, cell.localTorsion));
  }
  
  // Second pass: state transitions based on torsion
  for (const cell of cells) {
    const oldState = cell.state;
    
    if (cell.localTorsion >= t23Threshold) {
      cell.state = 'T3';
    } else if (cell.localTorsion >= t12Threshold) {
      cell.state = 'T2';
    } else {
      cell.state = 'T1';
    }
    
    if (cell.state !== oldState) {
      transitionsThisFrame++;
    }
    
    cell.torsion = T_SPECS[cell.state].torsion;
    
    // Advance phase (controls wave speed)
    cell.phase += dt * 2.0;
  }
  
  totalTransitions += transitionsThisFrame;
  steps++;
}

// === DRAWING ===
function drawCell(cell) {
  const cx = cell.x * CELL_SIZE + CELL_SIZE / 2;
  const cy = cell.y * CELL_SIZE + CELL_SIZE / 2;
  const spec = cell.spec;
  
  // Pulse based on wave (breathing effect)
  const pulse = 1 + 0.15 * Math.sin(cell.phase);
  
  // Washer dimensions
  const majorR = CELL_SIZE * 0.42 * pulse;
  const girth = spec.girth * girthMult * CELL_SIZE * 0.25;
  const minorR = Math.max(3, majorR - girth);
  
  // Rotation follows the swirl
  const rotation = cell.angle + cell.phase * swirlFactor * 0.5;
  
  ctx.save();
  ctx.translate(cx, cy);
  ctx.rotate(rotation);
  
  // Tube thickness
  const tubeThickness = majorR - minorR;
  
  // Mass creep based on torsion (higher torsion = more creep)
  const creepAmount = cell.localTorsion * 0.4;
  const massThickness = tubeThickness * (0.25 + creepAmount * spec.mass);
  const massOuterR = minorR + massThickness;
  
  // Angular extent of mass on inner rim
  const massAngle = spec.mass * 360;
  const massStart = 90 - massAngle / 2;
  const massEnd = 90 + massAngle / 2;
  
  // Draw radiance (outer ring) - with state color tint
  ctx.beginPath();
  ctx.arc(0, 0, majorR, 0, Math.PI * 2);
  ctx.arc(0, 0, minorR, Math.PI * 2, 0, true);
  ctx.closePath();
  
  // Blend white with state color based on wave
  const alpha = 0.7 + cell.wave * 0.3;
  ctx.fillStyle = RADIANCE_COLOR;
  ctx.globalAlpha = alpha;
  ctx.fill();
  ctx.globalAlpha = 1.0;
  
  // State color glow on outer edge
  ctx.strokeStyle = spec.color;
  ctx.lineWidth = 2;
  ctx.stroke();
  
  // Draw mass (black) on inner rim
  ctx.beginPath();
  ctx.arc(0, 0, massOuterR, massStart * Math.PI / 180, massEnd * Math.PI / 180);
  ctx.arc(0, 0, minorR, massEnd * Math.PI / 180, massStart * Math.PI / 180, true);
  ctx.closePath();
  ctx.fillStyle = MASS_COLOR;
  ctx.fill();
  
  // Creep tendrils
  if (creepAmount > 0.1) {
    const tendrilWidth = 10 * Math.PI / 180;
    const tendrilHeight = tubeThickness * creepAmount * 1.2;
    
    // Left tendril
    ctx.beginPath();
    ctx.arc(0, 0, minorR + tendrilHeight, 
            (massStart - tendrilWidth) * Math.PI / 180, 
            massStart * Math.PI / 180);
    ctx.arc(0, 0, minorR, 
            massStart * Math.PI / 180, 
            (massStart - tendrilWidth) * Math.PI / 180, true);
    ctx.closePath();
    ctx.fill();
    
    // Right tendril
    ctx.beginPath();
    ctx.arc(0, 0, minorR + tendrilHeight, 
            massEnd * Math.PI / 180, 
            (massEnd + tendrilWidth) * Math.PI / 180);
    ctx.arc(0, 0, minorR, 
            (massEnd + tendrilWidth) * Math.PI / 180, 
            massEnd * Math.PI / 180, true);
    ctx.closePath();
    ctx.fill();
  }
  
  // Inner rim highlight with state color
  ctx.beginPath();
  ctx.arc(0, 0, minorR, 0, Math.PI * 2);
  ctx.strokeStyle = spec.color;
  ctx.lineWidth = 1;
  ctx.globalAlpha = 0.5;
  ctx.stroke();
  ctx.globalAlpha = 1.0;
  
  ctx.restore();
}

function draw() {
  // Clear
  ctx.fillStyle = BG_COLOR;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  // Grid lines
  ctx.strokeStyle = GRID_COLOR;
  ctx.lineWidth = 1;
  
  for (let x = 0; x <= COLS; x++) {
    ctx.beginPath();
    ctx.moveTo(x * CELL_SIZE + 0.5, 0);
    ctx.lineTo(x * CELL_SIZE + 0.5, canvas.height);
    ctx.stroke();
  }
  
  for (let y = 0; y <= ROWS; y++) {
    ctx.beginPath();
    ctx.moveTo(0, y * CELL_SIZE + 0.5);
    ctx.lineTo(canvas.width, y * CELL_SIZE + 0.5);
    ctx.stroke();
  }
  
  // Draw cells
  for (const cell of cells) {
    drawCell(cell);
  }
  
  updateMetrics();
}

function updateMetrics() {
  document.getElementById('metricTime').textContent = steps;
  
  // Average torsion
  const avgTorsion = cells.reduce((sum, c) => sum + c.localTorsion, 0) / cells.length;
  document.getElementById('metricTorsion').textContent = avgTorsion.toFixed(2);
  
  // Count states
  let t1 = 0, t2 = 0, t3 = 0;
  for (const cell of cells) {
    if (cell.state === 'T1') t1++;
    else if (cell.state === 'T2') t2++;
    else t3++;
  }
  
  document.getElementById('metricT1').textContent = t1;
  document.getElementById('metricT2').textContent = t2;
  document.getElementById('metricT3').textContent = t3;
  document.getElementById('metricTransitions').textContent = totalTransitions;
  
  document.getElementById('colCount').textContent = `Columns: ${COLS}`;
  document.getElementById('rowCount').textContent = `Rows: ${ROWS}`;
}

// === UI CONTROLS ===
function togglePause() {
  isPaused = !isPaused;
  document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
}

function reset() {
  init();
}

function updateSpeed() {
  simSpeed = parseFloat(document.getElementById('speed').value);
  document.getElementById('speedVal').textContent = simSpeed.toFixed(2) + 'x';
}

function updateWaveFreq() {
  waveFreq = parseFloat(document.getElementById('waveFreq').value);
  document.getElementById('waveFreqVal').textContent = waveFreq.toFixed(2);
}

function updateSwirl() {
  swirlFactor = parseFloat(document.getElementById('swirl').value);
  document.getElementById('swirlVal').textContent = swirlFactor.toFixed(2);
}

function updateJitter() {
  jitter = parseFloat(document.getElementById('jitter').value);
  document.getElementById('jitterVal').textContent = jitter.toFixed(2);
}

function updateT12() {
  t12Threshold = parseFloat(document.getElementById('t12').value);
  document.getElementById('t12Val').textContent = t12Threshold.toFixed(2);
}

function updateT23() {
  t23Threshold = parseFloat(document.getElementById('t23').value);
  document.getElementById('t23Val').textContent = t23Threshold.toFixed(2);
}

function updateGirth() {
  girthMult = parseFloat(document.getElementById('girth').value);
  document.getElementById('girthVal').textContent = girthMult.toFixed(1) + 'x';
}

// === ANIMATION LOOP ===
function animate(timestamp) {
  if (lastTime === null) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;
  
  if (!isPaused) {
    evolve(dt * simSpeed);
  }
  
  draw();
  requestAnimationFrame(animate);
}

// === START ===
init();
requestAnimationFrame(animate);
</script>

</body>
</html>
