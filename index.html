<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ANGEL-1 · Wave Flow System</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: #0b0f14;
  color: #e8ecef;
  min-height: 100vh;
  padding: 20px;
}

.container {
  max-width: 1200px;
  margin: 0 auto;
}

h1 {
  font-size: 32px;
  font-weight: 700;
  background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  margin-bottom: 8px;
}

.subtitle {
  color: #9ca3af;
  font-size: 14px;
  margin-bottom: 20px;
}

.controls {
  display: flex;
  gap: 12px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

button {
  padding: 10px 20px;
  background: linear-gradient(135deg, #1e3a5f 0%, #1a1f2e 100%);
  border: 1px solid #22303d;
  border-radius: 6px;
  color: #e8ecef;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

button:hover {
  background: linear-gradient(135deg, #2d4a70 0%, #22303d 100%);
  border-color: #60a5fa;
  transform: translateY(-1px);
}

button.primary {
  background: linear-gradient(135deg, #60a5fa 0%, #3b82f6 100%);
  border-color: #60a5fa;
}

.metrics {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 16px;
  margin-bottom: 20px;
}

.metric-card {
  background: #1a1f2e;
  border: 1px solid #22303d;
  border-radius: 8px;
  padding: 16px;
}

.metric-label {
  color: #9ca3af;
  font-size: 13px;
  margin-bottom: 4px;
}

.metric-value {
  color: #10b981;
  font-size: 24px;
  font-weight: 700;
  font-family: 'Courier New', monospace;
}

.params {
  background: #1a1f2e;
  border: 1px solid #22303d;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 20px;
}

.params h3 {
  color: #e8ecef;
  font-size: 16px;
  margin-bottom: 16px;
}

.param-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 16px;
}

.param-item {
  display: flex;
  flex-direction: column;
  gap: 6px;
}

.param-item label {
  color: #d1d5db;
  font-size: 13px;
  display: flex;
  justify-content: space-between;
}

.param-value {
  color: #60a5fa;
  font-family: 'Courier New', monospace;
  font-weight: 600;
}

input[type="range"] {
  width: 100%;
  height: 6px;
  border-radius: 3px;
  background: #0b0f14;
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
  cursor: pointer;
}

input[type="range"]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
  cursor: pointer;
  border: none;
}

.canvas-container {
  background: #1a1f2e;
  border: 2px solid #22303d;
  border-radius: 8px;
  padding: 20px;
  margin-bottom: 20px;
  display: flex;
  justify-content: center;
}

canvas {
  display: block;
  border: 1px solid #22303d;
  border-radius: 4px;
}

.info {
  background: rgba(96, 165, 250, 0.1);
  border: 1px solid rgba(96, 165, 250, 0.3);
  border-radius: 8px;
  padding: 16px;
}

.info h3 {
  color: #60a5fa;
  font-size: 16px;
  margin-bottom: 12px;
}

.info ul {
  list-style: none;
  padding: 0;
}

.info li {
  color: #d1d5db;
  font-size: 13px;
  line-height: 1.8;
  padding-left: 20px;
  position: relative;
}

.info li:before {
  content: "•";
  position: absolute;
  left: 0;
  color: #60a5fa;
}
</style>
</head>
<body>

<div class="container">
  <h1>ANGEL-1 · Wave Flow System</h1>
  <div class="subtitle">Organic Flow · No Death States · T1/T2 Torsion Mechanics · Dark Energy = 68% Extended Zone</div>

  <div class="controls">
    <button id="pauseBtn" class="primary">Pause</button>
    <button id="resetBtn">Reset</button>
  </div>

  <div class="metrics">
    <div class="metric-card">
      <div class="metric-label">Time Steps</div>
      <div class="metric-value" id="timeSteps">0</div>
    </div>
    <div class="metric-card">
      <div class="metric-label">Avg Energy</div>
      <div class="metric-value" id="avgEnergy">0.0000</div>
    </div>
    <div class="metric-card">
      <div class="metric-label">Grid Size</div>
      <div class="metric-value" id="gridSize">8×6</div>
    </div>
  </div>

  <div class="params">
    <h3>Wave Parameters</h3>
    <div class="param-grid">
      <div class="param-item">
        <label>
          <span>Speed</span>
          <span class="param-value" id="speedVal">1.0x</span>
        </label>
        <input type="range" id="speed" min="0.1" max="3" step="0.1" value="1.0">
      </div>
      <div class="param-item">
        <label>
          <span>α (Dispersion)</span>
          <span class="param-value" id="alphaVal">0.90</span>
        </label>
        <input type="range" id="alpha" min="0.1" max="1.5" step="0.01" value="0.9">
      </div>
      <div class="param-item">
        <label>
          <span>β (Nonlinearity)</span>
          <span class="param-value" id="betaVal">0.35</span>
        </label>
        <input type="range" id="beta" min="0" max="1" step="0.01" value="0.35">
      </div>
      <div class="param-item">
        <label>
          <span>Jitter (Chaos)</span>
          <span class="param-value" id="jitterVal">0.20</span>
        </label>
        <input type="range" id="jitter" min="0" max="1" step="0.01" value="0.2">
      </div>
      <div class="param-item">
        <label>
          <span>Grid Columns</span>
          <span class="param-value" id="colsVal">8</span>
        </label>
        <input type="range" id="cols" min="4" max="16" step="1" value="8">
      </div>
      <div class="param-item">
        <label>
          <span>Grid Rows</span>
          <span class="param-value" id="rowsVal">6</span>
        </label>
        <input type="range" id="rows" min="3" max="12" step="1" value="6">
      </div>
    </div>
  </div>

  <div class="canvas-container">
    <canvas id="canvas"></canvas>
  </div>

  <div class="info">
    <h3>Wave Flow Mechanics & Dark Energy Connection</h3>
    <ul>
      <li><strong>Continuous evolution:</strong> Complex wave function (ψ = ψᴿ + iψᴵ) - no death states</li>
      <li><strong>Laplacian coupling:</strong> Each cell coupled to neighbors via wave diffusion</li>
      <li><strong>T1 oscillation:</strong> 135° total (45° left + 90° right) - 33% mass, 67% radiance</li>
      <li><strong>T2 oscillation:</strong> 67.5° total (22.5° left + 45° right) - 50% mass, 50% radiance</li>
      <li><strong>Safe zones:</strong> 42.6% of oscillation range = bound mass component</li>
      <li><strong>Extended zones:</strong> 57.4% of oscillation range = free radiance</li>
      <li><strong>Dark Energy = 68%:</strong> The radiance-dominated extended oscillation zones</li>
      <li><strong>Phase-driven rotation:</strong> φ = atan2(ψᴵ, ψᴿ) determines washer orientation</li>
      <li><strong>Organic flow:</strong> Energy sweeps across grid like breathing fabric of spacetime</li>
    </ul>
  </div>
</div>

<script>
// Configuration
let COLS = 8;
let ROWS = 6;
const CELL_SIZE = 60;
let isPaused = false;

// Wave parameters
let alpha = 0.9;
let beta = 0.35;
let dt = 0.02;
let jitter = 0.2;
let speed = 1.0;

// State
let psiR = [];
let psiI = [];
let rho = [];
let rhoE = [];
let phi = [];
let grid = [];
let t = 0;

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Initialize
function init() {
  const n = COLS * ROWS;
  
  // Random initial wave function
  psiR = Array(n).fill(0).map(() => Math.random() * 2 - 1);
  psiI = Array(n).fill(0).map(() => Math.random() * 2 - 1);
  rho = Array(n).fill(0);
  rhoE = Array(n).fill(0);
  phi = Array(n).fill(0);
  
  // Normalize
  normalize();
  
  // Build grid
  grid = [];
  for (let row = 0; row < ROWS; row++) {
    for (let col = 0; col < COLS; col++) {
      grid.push({
        x: (col - COLS / 2 + 0.5) * CELL_SIZE,
        y: (row - ROWS / 2 + 0.5) * CELL_SIZE,
        col,
        row
      });
    }
  }
  
  t = 0;
  
  // Update canvas size
  const width = COLS * CELL_SIZE;
  const height = ROWS * CELL_SIZE;
  canvas.width = width;
  canvas.height = height;
  
  document.getElementById('gridSize').textContent = `${COLS}×${ROWS}`;
}

function normalize() {
  let sum = 0;
  for (let i = 0; i < psiR.length; i++) {
    sum += psiR[i] * psiR[i] + psiI[i] * psiI[i];
  }
  const norm = Math.sqrt(sum) || 1e-12;
  for (let i = 0; i < psiR.length; i++) {
    psiR[i] /= norm;
    psiI[i] /= norm;
  }
}

function getNeighbors(i) {
  const neighbors = [];
  const col = i % COLS;
  const row = Math.floor(i / COLS);
  
  if (col > 0) neighbors.push(i - 1);
  if (col < COLS - 1) neighbors.push(i + 1);
  if (row > 0) neighbors.push(i - COLS);
  if (row < ROWS - 1) neighbors.push(i + COLS);
  
  return neighbors;
}

function laplacian(arr, i) {
  const neighbors = getNeighbors(i);
  let sum = 0;
  for (const n of neighbors) {
    sum += arr[n];
  }
  return sum - neighbors.length * arr[i];
}

function step() {
  const n = psiR.length;
  
  // Calculate density and phase
  for (let i = 0; i < n; i++) {
    rho[i] = psiR[i] * psiR[i] + psiI[i] * psiI[i];
    rhoE[i] = 0.95 * rhoE[i] + 0.05 * rho[i];
    phi[i] = Math.atan2(psiI[i], psiR[i]);
  }
  
  // Evolve wave function
  const newPsiR = [];
  const newPsiI = [];
  
  for (let i = 0; i < n; i++) {
    const Lr = laplacian(psiR, i);
    const Li = laplacian(psiI, i);
    const r = rho[i];
    
    const Ar = alpha * Lr - beta * r * psiR[i];
    const Ai = alpha * Li - beta * r * psiI[i];
    
    newPsiR[i] = psiR[i] + dt * (-Ai) + (Math.random() * 2 - 1) * jitter * 0.02;
    newPsiI[i] = psiI[i] + dt * Ar + (Math.random() * 2 - 1) * jitter * 0.02;
  }
  
  psiR = newPsiR;
  psiI = newPsiI;
  normalize();
  
  t++;
}

function drawWasher(x, y, radius, phase) {
  // Apply T1 rotation limits (135° total: 45° left + 90° right)
  let degrees = ((phase * 180 / Math.PI) % 360 + 360) % 360;
  let constrainedPhase = phase;
  
  if (degrees > 90 && degrees < 180) {
    constrainedPhase = 90 * Math.PI / 180;
  } else if (degrees > 180 && degrees < 315) {
    constrainedPhase = -45 * Math.PI / 180;
  }
  
  const thickness = 8;
  
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(constrainedPhase);
  
  // Black half (left)
  ctx.beginPath();
  ctx.arc(0, 0, radius, Math.PI / 2, 3 * Math.PI / 2);
  ctx.arc(0, 0, Math.max(1, radius - thickness), 3 * Math.PI / 2, Math.PI / 2, true);
  ctx.closePath();
  ctx.fillStyle = '#1a1a1a';
  ctx.fill();
  
  // White half (right)
  ctx.beginPath();
  ctx.arc(0, 0, radius, -Math.PI / 2, Math.PI / 2);
  ctx.arc(0, 0, Math.max(1, radius - thickness), Math.PI / 2, -Math.PI / 2, true);
  ctx.closePath();
  ctx.fillStyle = '#e8e8e8';
  ctx.fill();
  
  // Outline
  ctx.beginPath();
  ctx.arc(0, 0, radius, 0, 2 * Math.PI);
  ctx.strokeStyle = 'rgba(233, 69, 96, 0.6)';
  ctx.lineWidth = 1;
  ctx.stroke();
  
  ctx.restore();
}

function draw() {
  const width = canvas.width;
  const height = canvas.height;
  
  // Clear
  ctx.fillStyle = '#0b0f14';
  ctx.fillRect(0, 0, width, height);
  
  // Draw grid
  ctx.strokeStyle = '#22303d';
  ctx.lineWidth = 1;
  for (let i = 0; i <= COLS; i++) {
    ctx.beginPath();
    ctx.moveTo(i * CELL_SIZE, 0);
    ctx.lineTo(i * CELL_SIZE, height);
    ctx.stroke();
  }
  for (let i = 0; i <= ROWS; i++) {
    ctx.beginPath();
    ctx.moveTo(0, i * CELL_SIZE);
    ctx.lineTo(width, i * CELL_SIZE);
    ctx.stroke();
  }
  
  // Draw connections
  const maxRho = Math.max(1e-12, ...rhoE);
  for (let i = 0; i < grid.length; i++) {
    const neighbors = getNeighbors(i);
    for (const n of neighbors) {
      if (i < n) {
        const grad = Math.abs(rhoE[n] - rhoE[i]);
        if (grad < 0.6 / grid.length) {
          ctx.beginPath();
          ctx.moveTo(grid[i].x + width / 2, grid[i].y + height / 2);
          ctx.lineTo(grid[n].x + width / 2, grid[n].y + height / 2);
          ctx.strokeStyle = 'rgba(96, 165, 250, 0.25)';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      }
    }
  }
  
  // Draw washers
  const MIN_RADIUS = 8;
  const MAX_RADIUS = CELL_SIZE / 2 - 2;
  
  for (let i = 0; i < grid.length; i++) {
    const p = grid[i];
    const rsrc = rhoE[i];
    const radius = MIN_RADIUS + (MAX_RADIUS - MIN_RADIUS) * (rsrc / maxRho);
    
    drawWasher(
      p.x + width / 2,
      p.y + height / 2,
      radius,
      phi[i]
    );
  }
  
  // Update metrics
  const avgEnergy = rhoE.reduce((a, b) => a + b, 0) / rhoE.length;
  document.getElementById('timeSteps').textContent = t;
  document.getElementById('avgEnergy').textContent = avgEnergy.toFixed(4);
}

function animate() {
  if (!isPaused) {
    for (let s = 0; s < Math.ceil(speed * 5); s++) {
      step();
    }
  }
  draw();
  requestAnimationFrame(animate);
}

// UI Controls
document.getElementById('pauseBtn').onclick = () => {
  isPaused = !isPaused;
  document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
};

document.getElementById('resetBtn').onclick = () => {
  init();
};

document.getElementById('speed').oninput = (e) => {
  speed = parseFloat(e.target.value);
  document.getElementById('speedVal').textContent = speed.toFixed(1) + 'x';
};

document.getElementById('alpha').oninput = (e) => {
  alpha = parseFloat(e.target.value);
  document.getElementById('alphaVal').textContent = alpha.toFixed(2);
};

document.getElementById('beta').oninput = (e) => {
  beta = parseFloat(e.target.value);
  document.getElementById('betaVal').textContent = beta.toFixed(2);
};

document.getElementById('jitter').oninput = (e) => {
  jitter = parseFloat(e.target.value);
  document.getElementById('jitterVal').textContent = jitter.toFixed(2);
};

document.getElementById('cols').oninput = (e) => {
  COLS = parseInt(e.target.value);
  document.getElementById('colsVal').textContent = COLS;
  init();
};

document.getElementById('rows').oninput = (e) => {
  ROWS = parseInt(e.target.value);
  document.getElementById('rowsVal').textContent = ROWS;
  init();
};

// Start
init();
animate();
</script>

</body>
</html>
