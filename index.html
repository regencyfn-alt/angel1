<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ANGEL-1 · Chronomic Network</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  background: #0a0c10;
  color: #e8ecef;
  min-height: 100vh;
}

.header {
  background: linear-gradient(135deg, #1a1f2e 0%, #0f1620 100%);
  border-bottom: 2px solid #22303d;
  padding: 16px 24px;
}

.header h1 {
  font-size: 22px;
  background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  margin-bottom: 4px;
}

.header .subtitle {
  color: #9ca3af;
  font-size: 11px;
}

.main {
  display: flex;
  gap: 16px;
  padding: 16px;
  height: calc(100vh - 80px);
}

.canvas-section {
  flex: 1;
  display: flex;
  flex-direction: column;
  gap: 12px;
}

.sidebar {
  width: 280px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  overflow-y: auto;
}

.panel {
  background: #1a1f2e;
  border: 1px solid #22303d;
  border-radius: 8px;
  padding: 14px;
}

.panel h3 {
  color: #60a5fa;
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 1px;
  margin-bottom: 10px;
}

.canvas-container {
  background: #12161e;
  border: 2px solid #22303d;
  border-radius: 8px;
  flex: 1;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
}

canvas {
  border-radius: 4px;
}

.playback {
  display: flex;
  gap: 8px;
}

.playback button {
  flex: 1;
  padding: 10px;
  border: 1px solid #22303d;
  border-radius: 6px;
  color: #e8ecef;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

.playback button.primary {
  background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
  border-color: #3b82f6;
}

.playback button.secondary {
  background: linear-gradient(135deg, #1e3a5f 0%, #1a1f2e 100%);
}

.playback button:hover {
  transform: translateY(-1px);
}

.slider-group {
  margin-bottom: 10px;
}

.slider-group:last-child {
  margin-bottom: 0;
}

.slider-group label {
  display: flex;
  justify-content: space-between;
  font-size: 11px;
  color: #d1d5db;
  margin-bottom: 4px;
}

.slider-group .value {
  color: #60a5fa;
  font-family: 'Courier New', monospace;
  font-weight: 600;
}

input[type="range"] {
  width: 100%;
  height: 4px;
  border-radius: 2px;
  background: #0b0f14;
  outline: none;
  -webkit-appearance: none;
}

input[type="range"]::-webkit-slider-thumb {
  -webkit-appearance: none;
  width: 12px;
  height: 12px;
  border-radius: 50%;
  background: linear-gradient(135deg, #60a5fa 0%, #10b981 100%);
  cursor: pointer;
}

.metrics-grid {
  display: grid;
  grid-template-columns: 1fr 1fr 1fr;
  gap: 6px;
}

.metric {
  background: #0b0f14;
  border-radius: 4px;
  padding: 8px 6px;
  text-align: center;
}

.metric .label {
  font-size: 9px;
  color: #9ca3af;
  margin-bottom: 2px;
}

.metric .value {
  font-size: 14px;
  font-weight: 700;
  font-family: 'Courier New', monospace;
}

.metric .value.t1 { color: #3bd5ff; }
.metric .value.t2 { color: #ffd86a; }
.metric .value.t3 { color: #ff4b6a; }
.metric .value.conn { color: #10b981; }

.legend {
  display: flex;
  gap: 12px;
  justify-content: center;
  flex-wrap: wrap;
}

.legend-item {
  display: flex;
  align-items: center;
  gap: 6px;
  font-size: 10px;
}

.legend-dot {
  width: 10px;
  height: 10px;
  border-radius: 50%;
}

.info-box {
  background: rgba(96, 165, 250, 0.08);
  border: 1px solid rgba(96, 165, 250, 0.2);
  border-radius: 6px;
  padding: 10px;
  font-size: 10px;
  line-height: 1.5;
  color: #9ca3af;
}

.info-box strong {
  color: #60a5fa;
}

.phase-diagram {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 8px;
  background: #0b0f14;
  border-radius: 4px;
  font-size: 10px;
}

.phase-arrow {
  color: #4b5563;
}

.phase-label {
  padding: 4px 8px;
  border-radius: 3px;
  font-weight: 600;
}

.phase-label.t1 { background: rgba(59, 213, 255, 0.2); color: #3bd5ff; }
.phase-label.t2 { background: rgba(255, 216, 106, 0.2); color: #ffd86a; }
.phase-label.t3 { background: rgba(255, 75, 106, 0.2); color: #ff4b6a; }
</style>
</head>
<body>

<div class="header">
  <h1>ANGEL-1 · CHRONOMIC NETWORK</h1>
  <div class="subtitle">Hierarchical Torsion Field · T1→4×T2→8×T3 Subdivision · Connection-Based Persistence</div>
</div>

<div class="main">
  <div class="canvas-section">
    <div class="canvas-container">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <div class="sidebar">
    <div class="panel">
      <h3>Control</h3>
      <div class="playback">
        <button id="pauseBtn" class="primary" onclick="togglePause()">Pause</button>
        <button class="secondary" onclick="reset()">Reset</button>
        <button class="secondary" onclick="subdivideSelected()">Subdivide</button>
      </div>
    </div>

    <div class="panel">
      <h3>Phase Hierarchy</h3>
      <div class="phase-diagram">
        <span class="phase-label t1">T1</span>
        <span class="phase-arrow">→ 4×</span>
        <span class="phase-label t2">T2</span>
        <span class="phase-arrow">→ 2×</span>
        <span class="phase-label t3">T3</span>
      </div>
      <div style="margin-top: 8px; font-size: 10px; color: #6b7280; text-align: center;">
        Click chronon to select · Subdivide breaks down phase
      </div>
    </div>

    <div class="panel">
      <h3>Field Metrics</h3>
      <div class="metrics-grid">
        <div class="metric">
          <div class="label">T1 (Fluid)</div>
          <div class="value t1" id="metricT1">0</div>
        </div>
        <div class="metric">
          <div class="label">T2 (Meso)</div>
          <div class="value t2" id="metricT2">0</div>
        </div>
        <div class="metric">
          <div class="label">T3 (Crystal)</div>
          <div class="value t3" id="metricT3">0</div>
        </div>
        <div class="metric">
          <div class="label">Total</div>
          <div class="value conn" id="metricTotal">0</div>
        </div>
        <div class="metric">
          <div class="label">Connections</div>
          <div class="value conn" id="metricConn">0</div>
        </div>
        <div class="metric">
          <div class="label">Field Sum</div>
          <div class="value conn" id="metricSum">0</div>
        </div>
      </div>
    </div>

    <div class="panel">
      <h3>Dynamics</h3>
      <div class="slider-group">
        <label>
          <span>Connection Decay</span>
          <span class="value" id="decayVal">0.02</span>
        </label>
        <input type="range" id="decay" min="0" max="0.1" step="0.005" value="0.02" oninput="updateDecay()">
      </div>
      <div class="slider-group">
        <label>
          <span>Subdivision Threshold</span>
          <span class="value" id="subThreshVal">0.70</span>
        </label>
        <input type="range" id="subThresh" min="0.3" max="0.9" step="0.05" value="0.7" oninput="updateSubThresh()">
      </div>
      <div class="slider-group">
        <label>
          <span>Wave Speed</span>
          <span class="value" id="waveSpeedVal">1.0</span>
        </label>
        <input type="range" id="waveSpeed" min="0.2" max="3" step="0.1" value="1" oninput="updateWaveSpeed()">
      </div>
    </div>

    <div class="panel">
      <h3>Mass-Radiance</h3>
      <div class="slider-group">
        <label>
          <span>Complementarity (C)</span>
          <span class="value" id="compVal">0.50</span>
        </label>
        <input type="range" id="comp" min="0" max="1" step="0.05" value="0.5" oninput="updateComp()">
      </div>
      <div style="font-size: 10px; color: #6b7280; margin-top: 6px;">
        C→0: Mass dominant (slow, contracted)<br>
        C→1: Radiance dominant (fast, expanded)
      </div>
    </div>

    <div class="panel">
      <h3>Legend</h3>
      <div class="legend">
        <div class="legend-item">
          <div class="legend-dot" style="background: #3bd5ff;"></div>
          <span>T1 Fluid</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background: #ffd86a;"></div>
          <span>T2 Meso</span>
        </div>
        <div class="legend-item">
          <div class="legend-dot" style="background: #ff4b6a;"></div>
          <span>T3 Crystal</span>
        </div>
      </div>
    </div>

    <div class="info-box">
      <strong>Chronomic Network (CHR Theory):</strong><br>
      • T1: Fluid phase, largest tori, radiant<br>
      • T2: Mesophase, 4× smaller, EM domain<br>
      • T3: Crystalline, 8× smaller, mass-locked<br>
      • Isolated chronons decay (Connection Axiom)<br>
      • Field sum stored in connection weights<br><br>
      <strong>Controls:</strong> Click to select, Subdivide to break down
    </div>
  </div>
</div>

<script>
// === CHRONOMIC NETWORK SIMULATION ===
// Based on CHR Theory: Temporal Primacy framework

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');

// Size ratios based on theory: T1 → 4×T2 → 8×T3
const PHASE_CONFIG = {
  T1: {
    sizeRatio: 1.0,      // Base size
    massQuotient: 0.33,  // Low mass
    speed: 1.0,          // Fast
    color: '#3bd5ff',    // Cyan - radiant
    subdivides: 4        // Becomes 4 T2s
  },
  T2: {
    sizeRatio: 0.5,      // Half size
    massQuotient: 0.55,  // Medium mass
    speed: 0.6,          // Medium
    color: '#ffd86a',    // Gold - EM mesophase
    subdivides: 2        // Becomes 2 T3s
  },
  T3: {
    sizeRatio: 0.35,     // Smallest
    massQuotient: 0.90,  // High mass
    speed: 0.25,         // Slowest
    color: '#ff4b6a',    // Red - mass-locked
    subdivides: 0        // Cannot subdivide further
  }
};

// Parameters
let decayRate = 0.02;
let subdivisionThreshold = 0.7;
let waveSpeed = 1.0;
let globalComplementarity = 0.5;

// State
let chronons = [];
let selectedChronon = null;
let isPaused = false;
let fieldSum = 0;  // Accumulated field memory
let lastTime = null;

// Chronon class - represents a single temporal unit
class Chronon {
  constructor(x, y, phase = 'T1', parent = null) {
    this.id = Math.random().toString(36).substr(2, 9);
    this.x = x;
    this.y = y;
    this.phase = phase;
    this.parent = parent;
    this.children = [];

    // 9D state space (simplified to key parameters)
    this.theta = Math.random() * Math.PI * 2;      // Rotation phase
    this.chi = Math.random() > 0.5 ? 1 : -1;       // Chirality
    this.R = PHASE_CONFIG[phase].sizeRatio;        // Girth
    this.C = globalComplementarity;                 // Complementarity
    this.omega = PHASE_CONFIG[phase].speed;        // Angular frequency

    // Connection and persistence
    this.connectionWeight = 1.0;  // Starts fully connected
    this.neighbors = [];
    this.torsion = 0;
    this.accumulatedTorsion = 0;  // Memory of field history

    // Visual
    this.pulsePhase = Math.random() * Math.PI * 2;
  }

  get config() {
    return PHASE_CONFIG[this.phase];
  }

  get baseSize() {
    return 50 * this.config.sizeRatio;
  }

  // Update chronon state
  update(dt) {
    if (isPaused) return;

    const speed = this.omega * waveSpeed;

    // Advance rotation
    this.theta += dt * speed * 2;
    this.pulsePhase += dt * speed * 3;

    // Calculate local torsion from neighbors
    let neighborTorsion = 0;
    let higherPhaseNeighbors = 0;

    for (const neighbor of this.neighbors) {
      const phaseDiff = Math.abs(this.theta - neighbor.theta);
      neighborTorsion += Math.sin(phaseDiff) * neighbor.connectionWeight;

      if (this.getPhaseOrder(neighbor.phase) > this.getPhaseOrder(this.phase)) {
        higherPhaseNeighbors++;
      }
    }

    if (this.neighbors.length > 0) {
      neighborTorsion /= this.neighbors.length;
    }

    // Torsion combines self-rotation, neighbor influence, and chirality
    this.torsion = 0.5 + 0.3 * Math.sin(this.theta) + 0.2 * neighborTorsion;
    this.torsion *= (1 + 0.1 * this.chi);
    this.torsion = Math.max(0, Math.min(1, this.torsion));

    // Accumulate torsion (field memory)
    this.accumulatedTorsion += this.torsion * dt * 0.1;

    // Connection decay (Connection Axiom: isolated chronons decay)
    if (this.neighbors.length === 0) {
      this.connectionWeight -= decayRate * dt * 10;
    } else {
      // Strengthen connections with active neighbors
      const avgNeighborConnection = this.neighbors.reduce((sum, n) => sum + n.connectionWeight, 0) / this.neighbors.length;
      this.connectionWeight += (avgNeighborConnection - this.connectionWeight) * dt * 0.5;
    }

    this.connectionWeight = Math.max(0, Math.min(1, this.connectionWeight));

    // Auto-subdivision when torsion exceeds threshold
    if (this.torsion > subdivisionThreshold && this.config.subdivides > 0 && this.children.length === 0) {
      // Mark for subdivision (handled in main loop to avoid mutation during iteration)
      this.shouldSubdivide = true;
    }
  }

  getPhaseOrder(phase) {
    return { 'T1': 0, 'T2': 1, 'T3': 2 }[phase];
  }

  // Subdivide into smaller chronons
  subdivide() {
    if (this.config.subdivides === 0) return [];

    const nextPhase = this.phase === 'T1' ? 'T2' : 'T3';
    const count = this.config.subdivides;
    const childSize = PHASE_CONFIG[nextPhase].sizeRatio * 50;
    const spread = this.baseSize * 0.4;

    const newChronons = [];

    for (let i = 0; i < count; i++) {
      const angle = (i / count) * Math.PI * 2 + this.theta;
      const offsetX = Math.cos(angle) * spread;
      const offsetY = Math.sin(angle) * spread;

      const child = new Chronon(
        this.x + offsetX,
        this.y + offsetY,
        nextPhase,
        this
      );

      // Inherit some properties
      child.chi = this.chi * (i % 2 === 0 ? 1 : -1);
      child.accumulatedTorsion = this.accumulatedTorsion / count;
      child.connectionWeight = this.connectionWeight * 0.8;

      this.children.push(child);
      newChronons.push(child);
    }

    return newChronons;
  }

  // Draw the chronon
  draw(ctx, isSelected = false) {
    const size = this.baseSize;
    const pulse = 1 + 0.1 * Math.sin(this.pulsePhase);
    const alpha = 0.3 + 0.7 * this.connectionWeight;

    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.theta * 0.5);

    // Outer glow based on connection weight
    if (this.connectionWeight > 0.3) {
      const gradient = ctx.createRadialGradient(0, 0, size * 0.3, 0, 0, size * pulse);
      gradient.addColorStop(0, this.config.color + '40');
      gradient.addColorStop(1, this.config.color + '00');
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, size * pulse, 0, Math.PI * 2);
      ctx.fill();
    }

    // Main torus (as washer shape)
    const outerR = size * 0.8 * pulse;
    const innerR = size * 0.3 * pulse;
    const massAngle = this.config.massQuotient * Math.PI * 2;

    // Radiance ring (white/colored)
    ctx.globalAlpha = alpha;
    ctx.beginPath();
    ctx.arc(0, 0, outerR, 0, Math.PI * 2);
    ctx.arc(0, 0, innerR, Math.PI * 2, 0, true);
    ctx.closePath();
    ctx.fillStyle = `rgba(255, 255, 255, ${0.6 + 0.4 * this.C})`;
    ctx.fill();

    // Colored edge
    ctx.strokeStyle = this.config.color;
    ctx.lineWidth = 2;
    ctx.stroke();

    // Mass region (dark) - size based on mass quotient
    const massR = innerR + (outerR - innerR) * this.config.massQuotient * 0.6;
    ctx.beginPath();
    ctx.arc(0, 0, massR, -massAngle/2, massAngle/2);
    ctx.arc(0, 0, innerR, massAngle/2, -massAngle/2, true);
    ctx.closePath();
    ctx.fillStyle = '#1a1a1a';
    ctx.fill();

    // Torsion indicator (inner glow intensity)
    if (this.torsion > 0.5) {
      ctx.beginPath();
      ctx.arc(0, 0, innerR * 0.8, 0, Math.PI * 2);
      ctx.fillStyle = this.config.color + Math.floor(this.torsion * 80).toString(16).padStart(2, '0');
      ctx.fill();
    }

    // Selection indicator
    if (isSelected) {
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 3;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(0, 0, outerR + 8, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    ctx.restore();

    // Draw connections to neighbors
    ctx.globalAlpha = 0.15 * this.connectionWeight;
    ctx.strokeStyle = this.config.color;
    ctx.lineWidth = 1;
    for (const neighbor of this.neighbors) {
      ctx.beginPath();
      ctx.moveTo(this.x, this.y);
      ctx.lineTo(neighbor.x, neighbor.y);
      ctx.stroke();
    }
    ctx.globalAlpha = 1;
  }

  // Check if point is inside this chronon
  containsPoint(px, py) {
    const dx = px - this.x;
    const dy = py - this.y;
    return Math.sqrt(dx*dx + dy*dy) < this.baseSize;
  }
}

// Initialize simulation
function init() {
  canvas.width = canvas.parentElement.clientWidth - 4;
  canvas.height = canvas.parentElement.clientHeight - 4;

  chronons = [];
  selectedChronon = null;
  fieldSum = 0;

  // Create initial T1 chronons in a grid
  const cols = 4;
  const rows = 3;
  const spacing = 120;
  const offsetX = (canvas.width - (cols - 1) * spacing) / 2;
  const offsetY = (canvas.height - (rows - 1) * spacing) / 2;

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const chronon = new Chronon(
        offsetX + x * spacing,
        offsetY + y * spacing,
        'T1'
      );
      chronons.push(chronon);
    }
  }

  updateNeighbors();
  lastTime = null;
}

// Update neighbor connections
function updateNeighbors() {
  const connectionDistance = 150;

  for (const c of chronons) {
    c.neighbors = [];
    for (const other of chronons) {
      if (c === other) continue;
      const dx = c.x - other.x;
      const dy = c.y - other.y;
      const dist = Math.sqrt(dx*dx + dy*dy);

      // Connection distance scales with phase
      const maxDist = connectionDistance * (c.config.sizeRatio + other.config.sizeRatio) / 2;
      if (dist < maxDist) {
        c.neighbors.push(other);
      }
    }
  }
}

// Main update loop
function update(dt) {
  if (isPaused) return;

  // Update all chronons
  for (const c of chronons) {
    c.update(dt);
  }

  // Handle subdivisions
  const toSubdivide = chronons.filter(c => c.shouldSubdivide);
  for (const c of toSubdivide) {
    c.shouldSubdivide = false;
    const newChronons = c.subdivide();
    chronons.push(...newChronons);

    // Remove parent from active list (but keep reference)
    const idx = chronons.indexOf(c);
    if (idx > -1) {
      chronons.splice(idx, 1);
    }
  }

  // Remove decayed chronons
  chronons = chronons.filter(c => c.connectionWeight > 0.05);

  // Update neighbors if topology changed
  if (toSubdivide.length > 0) {
    updateNeighbors();
  }

  // Calculate field sum (memory)
  fieldSum = chronons.reduce((sum, c) => sum + c.accumulatedTorsion * c.connectionWeight, 0);
}

// Draw everything
function draw() {
  ctx.fillStyle = '#0a0c10';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw grid
  ctx.strokeStyle = '#1a1f2e';
  ctx.lineWidth = 1;
  const gridSize = 60;
  for (let x = 0; x < canvas.width; x += gridSize) {
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, canvas.height);
    ctx.stroke();
  }
  for (let y = 0; y < canvas.height; y += gridSize) {
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(canvas.width, y);
    ctx.stroke();
  }

  // Sort by phase for layering (T3 on top)
  const sorted = [...chronons].sort((a, b) =>
    a.getPhaseOrder(a.phase) - b.getPhaseOrder(b.phase)
  );

  // Draw chronons
  for (const c of sorted) {
    c.draw(ctx, c === selectedChronon);
  }

  // Update metrics
  const t1Count = chronons.filter(c => c.phase === 'T1').length;
  const t2Count = chronons.filter(c => c.phase === 'T2').length;
  const t3Count = chronons.filter(c => c.phase === 'T3').length;
  const totalConnections = chronons.reduce((sum, c) => sum + c.neighbors.length, 0) / 2;

  document.getElementById('metricT1').textContent = t1Count;
  document.getElementById('metricT2').textContent = t2Count;
  document.getElementById('metricT3').textContent = t3Count;
  document.getElementById('metricTotal').textContent = chronons.length;
  document.getElementById('metricConn').textContent = Math.floor(totalConnections);
  document.getElementById('metricSum').textContent = fieldSum.toFixed(1);
}

// Animation loop
function animate(timestamp) {
  if (lastTime === null) lastTime = timestamp;
  const dt = Math.min((timestamp - lastTime) / 1000, 0.1);
  lastTime = timestamp;

  update(dt);
  draw();

  requestAnimationFrame(animate);
}

// UI Controls
function togglePause() {
  isPaused = !isPaused;
  document.getElementById('pauseBtn').textContent = isPaused ? 'Resume' : 'Pause';
}

function reset() {
  init();
}

function subdivideSelected() {
  if (selectedChronon && selectedChronon.config.subdivides > 0) {
    const newChronons = selectedChronon.subdivide();
    chronons.push(...newChronons);

    const idx = chronons.indexOf(selectedChronon);
    if (idx > -1) {
      chronons.splice(idx, 1);
    }

    selectedChronon = null;
    updateNeighbors();
  }
}

function updateDecay() {
  decayRate = parseFloat(document.getElementById('decay').value);
  document.getElementById('decayVal').textContent = decayRate.toFixed(3);
}

function updateSubThresh() {
  subdivisionThreshold = parseFloat(document.getElementById('subThresh').value);
  document.getElementById('subThreshVal').textContent = subdivisionThreshold.toFixed(2);
}

function updateWaveSpeed() {
  waveSpeed = parseFloat(document.getElementById('waveSpeed').value);
  document.getElementById('waveSpeedVal').textContent = waveSpeed.toFixed(1);
}

function updateComp() {
  globalComplementarity = parseFloat(document.getElementById('comp').value);
  document.getElementById('compVal').textContent = globalComplementarity.toFixed(2);
  for (const c of chronons) {
    c.C = globalComplementarity;
  }
}

// Mouse interaction
canvas.addEventListener('click', (e) => {
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  selectedChronon = null;
  for (const c of chronons) {
    if (c.containsPoint(x, y)) {
      selectedChronon = c;
      break;
    }
  }
});

// Handle resize
window.addEventListener('resize', () => {
  canvas.width = canvas.parentElement.clientWidth - 4;
  canvas.height = canvas.parentElement.clientHeight - 4;
});

// Start
init();
requestAnimationFrame(animate);
</script>

</body>
</html>
